<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skier</title>
  
  <subtitle>游戏开发</subtitle>
  <link href="https://skierhou.github.io/atom.xml" rel="self"/>
  
  <link href="https://skierhou.github.io/"/>
  <updated>2021-12-21T12:19:32.482Z</updated>
  <id>https://skierhou.github.io/</id>
  
  <author>
    <name>Skier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity 开发一些记录</title>
    <link href="https://skierhou.github.io/2021/12/20/Unity/%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://skierhou.github.io/2021/12/20/Unity/%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2021-12-20T06:30:01.000Z</published>
    <updated>2021-12-21T12:19:32.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XLua开发的一些问题记录"><a href="#XLua开发的一些问题记录" class="headerlink" title="XLua开发的一些问题记录"></a>XLua开发的一些问题记录</h1><ol><li>C#枚举在lua中转Int：CS.System.Convert.ChangeType()</li><li>泛型函数使用：xlua.get_generic_method(instance, “func_name”); //成员函数传实例，静态函数传类型</li></ol><h1 id="RawImage使用扩展"><a href="#RawImage使用扩展" class="headerlink" title="RawImage使用扩展"></a>RawImage使用扩展</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用通用管理器UIModelManager，方便RawImage,RT加载卸载，以及RawImage与模型交互</p><h2 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h2><ol><li>对应每一张RawImage，由于显示不同都需要不同的Camera以及RT，将Camera.targetTexture设置成RT</li><li>模型加载卸载走项目通用方式</li><li>交互问题：在UI上我们只能点击这个RawImage，如果RawImage中只显示一个模型，那我们可以直接在UI上监听拖拽修改这个模型的旋转或者其他操作<br>但是这样做非常不友好，并不能精确的知道是否点中了这张RT上的模型，扩展一下改成世界坐标射线检测，这样不管RT上有多少模型都可以做交互</li><li>整理一下交互中射线检测计算思路：<br>(1) 拿到点击位置计算其在RawImage中的偏移值<br>(2) 将偏移值运算在相机的实际渲染高宽上<br>(3) 怎么获得相机实际渲染高宽：<br>正交相机：height=orthographicSize * 2， width = 宽高比<em>height<br>透视相机：height=tan(fov / 2) * near * 2， width = 宽高比</em>height<br>具体推算过程仔细看下这个公式就能知道，关于正交相机高度=size*2这个是Unity中的固定值</li><li>交互按需求自行添加，在UIRenderToTexture中监听IDragHandler, IBeginDragHandler, IEndDragHandler, IPointerClickHandler等即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void SetClickTarget(Vector2 clickPos)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过射线检测当前点击的模型</span><br><span class="line">    &#x2F;&#x2F; 拿到点击位置与UI位置的偏移百分比</span><br><span class="line">    Camera uiCamera &#x3D; Hooks.CameraManager.UICamera;</span><br><span class="line">    float width &#x3D; m_RawImage.rectTransform.rect.width;</span><br><span class="line">    float height &#x3D; m_RawImage.rectTransform.rect.height;</span><br><span class="line">    Vector2 screenPos &#x3D; RectTransformUtility.WorldToScreenPoint(uiCamera, transform.position);</span><br><span class="line">    screenPos +&#x3D; new Vector2(width * (0.5f - m_RawImage.rectTransform.pivot.x), height * (0.5f - m_RawImage.rectTransform.pivot.y));</span><br><span class="line">    Vector2 offset &#x3D; clickPos - screenPos;</span><br><span class="line">    offset &#x3D; new Vector2(offset.x &#x2F; width, offset.y &#x2F; height);</span><br><span class="line">    if (m_Camera.orthographic)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 正交相机的渲染大小height&#x3D;size*2， width &#x3D; 宽高比*height</span><br><span class="line">        float screenHeight &#x3D; m_Camera.orthographicSize * 2;</span><br><span class="line">        float screenWidth &#x3D; m_Camera.pixelWidth * 1.0f &#x2F; m_Camera.pixelHeight * screenHeight;</span><br><span class="line">        Vector3 startPoint &#x3D; m_Camera.transform.position + m_Camera.transform.right * offset.x * screenWidth + m_Camera.transform.up * offset.y * screenHeight;</span><br><span class="line"></span><br><span class="line">        Debug.DrawLine(startPoint, startPoint + m_Camera.transform.forward * 100, Color.red, 5f);</span><br><span class="line">        if (Physics.Raycast(startPoint, m_Camera.transform.forward, out RaycastHit hit, 100, 1 &lt;&lt; Constant.Layer.UIRenderToTarget))</span><br><span class="line">        &#123;</span><br><span class="line">            m_DragTarget &#x3D; hit.transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 透视相机通过FOV和near可以求height， width同正交相机</span><br><span class="line">        float screenHeight &#x3D; Mathf.Tan(m_Camera.fieldOfView * 0.5f * Mathf.Deg2Rad) * m_Camera.nearClipPlane * 2;</span><br><span class="line">        float screenWidth &#x3D; m_Camera.pixelWidth * 1.0f &#x2F; m_Camera.pixelHeight * screenHeight;</span><br><span class="line">        Vector3 endPoint &#x3D; m_Camera.transform.position + m_Camera.transform.forward * m_Camera.nearClipPlane</span><br><span class="line">            + m_Camera.transform.right * offset.x * screenWidth + m_Camera.transform.up * offset.y * screenHeight;</span><br><span class="line">        Vector3 dir &#x3D; (endPoint - m_Camera.transform.position).normalized;</span><br><span class="line"></span><br><span class="line">        Debug.DrawLine(m_Camera.transform.position, endPoint, Color.red, 5f);</span><br><span class="line">        if (Physics.Raycast(m_Camera.transform.position, dir, out RaycastHit hit, m_Camera.farClipPlane, 1 &lt;&lt; Constant.Layer.UIRenderToTarget))</span><br><span class="line">        &#123;</span><br><span class="line">            m_DragTarget &#x3D; hit.transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">namespace Gameplay</span><br><span class="line">&#123;</span><br><span class="line">    public class UIModelManager : ManagerBase</span><br><span class="line">    &#123;</span><br><span class="line">        private Stack&lt;Camera&gt; m_CameraPool &#x3D; new Stack&lt;Camera&gt;();</span><br><span class="line">        private Stack&lt;int&gt; m_IndexPool &#x3D; new Stack&lt;int&gt;();</span><br><span class="line">        private int m_PoolCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        private Transform m_UIModelRoot;</span><br><span class="line">        private Light m_UIModelLight;</span><br><span class="line"></span><br><span class="line">        public override void OnInitilize()</span><br><span class="line">        &#123;</span><br><span class="line">            base.OnInitilize();</span><br><span class="line"></span><br><span class="line">            m_UIModelRoot &#x3D; new GameObject(&quot;UIModelRoot&quot;).transform;</span><br><span class="line">            m_UIModelRoot.SetParentEx(null);</span><br><span class="line">            GameObject.DontDestroyOnLoad(m_UIModelRoot);</span><br><span class="line"></span><br><span class="line">            m_UIModelLight &#x3D; new GameObject(&quot;UIModelLight&quot;).GetOrAddComponent&lt;Light&gt;();</span><br><span class="line">            m_UIModelLight.transform.SetParentEx(m_UIModelRoot);</span><br><span class="line"></span><br><span class="line">            m_UIModelLight.transform.localEulerAngles &#x3D; new Vector3(36, 30, 0);</span><br><span class="line">            m_UIModelLight.cookieSize &#x3D; 10;</span><br><span class="line">            m_UIModelLight.type &#x3D; LightType.Directional;</span><br><span class="line">            m_UIModelLight.cullingMask &#x3D; 1 &lt;&lt; Constant.Layer.UI | 1 &lt;&lt; Constant.Layer.UIRenderToTarget;</span><br><span class="line">            m_UIModelLight.shadows &#x3D; LightShadows.None;</span><br><span class="line"></span><br><span class="line">            m_UIModelLight.gameObject.SetActive(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 加载一个模型到一张RawImage上</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public void LoadModelToRawImage(string path, RawImage rawImage, bool canDrag &#x3D; true, Vector3 offset &#x3D; default,</span><br><span class="line">            Quaternion rot &#x3D; default, Vector3 scale &#x3D; default, Action&lt;UIRenderToTexture, GameObject&gt; callback &#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            if (rawImage &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;RawImage Is Null!&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Hooks.GameObjectManager.SpawnAsync(path, (go) &#x3D;&gt; &#123;</span><br><span class="line">                if (go !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    UIRenderToTexture renderToTexture &#x3D; rawImage.GetComponent&lt;UIRenderToTexture&gt;();</span><br><span class="line">                    Vector3 pos;</span><br><span class="line">                    if (renderToTexture &#x3D;&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int index &#x3D; m_IndexPool.Count &gt; 0 ? m_IndexPool.Pop() : m_PoolCount++;</span><br><span class="line">                        pos &#x3D; new Vector3(10 * index, -10000, 0);</span><br><span class="line"></span><br><span class="line">                        renderToTexture &#x3D; rawImage.GetOrAddComponent&lt;UIRenderToTexture&gt;();</span><br><span class="line">                        renderToTexture.Init(pos, true, index);</span><br><span class="line">                        UpdateLight();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        pos &#x3D; new Vector3(10 * renderToTexture.Index, -10000, 0);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    go.SetLayerRecursively(Constant.Layer.UIRenderToTarget);</span><br><span class="line">                    go.transform.SetParent(m_UIModelRoot);</span><br><span class="line">                    go.transform.localPosition &#x3D; pos + offset;</span><br><span class="line">                    go.transform.localScale &#x3D; scale &#x3D;&#x3D; default ? Vector3.one : scale;</span><br><span class="line">                    go.transform.rotation &#x3D; rot;</span><br><span class="line">                    renderToTexture.AddTarget(go, canDrag);</span><br><span class="line"></span><br><span class="line">                    callback?.Invoke(renderToTexture, go);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 卸载单个</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public void UnLoadModelByRawImage(RawImage rawImage, GameObject go)</span><br><span class="line">        &#123;</span><br><span class="line">            if (rawImage !&#x3D; null &amp;&amp; go !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                UIRenderToTexture renderToTexture &#x3D; rawImage.GetComponent&lt;UIRenderToTexture&gt;();</span><br><span class="line">                int id &#x3D; go.GetInstanceID();</span><br><span class="line">                if (renderToTexture !&#x3D; null &amp;&amp; renderToTexture.Targets !&#x3D; null &amp;&amp; renderToTexture.Targets.ContainsKey(id))</span><br><span class="line">                &#123;</span><br><span class="line">                    renderToTexture.Targets.Remove(id);</span><br><span class="line">                    Hooks.GameObjectManager.Recycle(go);</span><br><span class="line">                    if (renderToTexture.Targets.Count &#x3D;&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        renderToTexture.ResetTarget();</span><br><span class="line">                        m_IndexPool.Push(renderToTexture.Index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                UpdateLight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 卸载所有</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public void UnLoadModelByRawImage(RawImage rawImage)</span><br><span class="line">        &#123;</span><br><span class="line">            if (rawImage !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                UIRenderToTexture renderToTexture &#x3D; rawImage.GetComponent&lt;UIRenderToTexture&gt;();</span><br><span class="line">                if (renderToTexture !&#x3D; null &amp;&amp; renderToTexture.Targets !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    foreach (var target in renderToTexture.Targets.Values)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Hooks.GameObjectManager.Recycle(target.gameObject);</span><br><span class="line">                    &#125;</span><br><span class="line">                    renderToTexture.ResetTarget();</span><br><span class="line">                    m_IndexPool.Push(renderToTexture.Index);</span><br><span class="line">                &#125;</span><br><span class="line">                UpdateLight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void UpdateLight()</span><br><span class="line">        &#123;</span><br><span class="line">            m_UIModelLight.gameObject.SetActive(m_CameraPool.Count &lt; m_PoolCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Camera SpawnCamera()</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_CameraPool.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Camera camera &#x3D; m_CameraPool.Pop();</span><br><span class="line">                camera.gameObject.SetActive(true);</span><br><span class="line">                return camera;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject go &#x3D; new GameObject(&quot;CameraRTT&quot;);</span><br><span class="line">                go.transform.SetParentEx(m_UIModelRoot);</span><br><span class="line">                Camera camera &#x3D; go.GetOrAddComponent&lt;Camera&gt;();</span><br><span class="line">                camera.fieldOfView &#x3D; 30;</span><br><span class="line">                camera.allowHDR &#x3D; false;</span><br><span class="line">                camera.backgroundColor &#x3D; Color.clear;</span><br><span class="line">                camera.useOcclusionCulling &#x3D; false;</span><br><span class="line">                camera.clearFlags &#x3D; CameraClearFlags.SolidColor;</span><br><span class="line">                camera.cullingMask &#x3D; 1 &lt;&lt; Constant.Layer.UIRenderToTarget;</span><br><span class="line">                camera.farClipPlane &#x3D; 30;</span><br><span class="line">                camera.orthographicSize &#x3D; 1;</span><br><span class="line"></span><br><span class="line">                return camera;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void RecyleCamera(Camera camera)</span><br><span class="line">        &#123;</span><br><span class="line">            if (camera !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                camera.targetTexture &#x3D; null;</span><br><span class="line">                camera.gameObject.SetActive(false);</span><br><span class="line">                m_CameraPool.Push(camera);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class UIRenderToTexture : MonoBehaviour, IDragHandler, IBeginDragHandler, IEndDragHandler, IPointerClickHandler</span><br><span class="line">    &#123;</span><br><span class="line">        public struct Target</span><br><span class="line">        &#123;</span><br><span class="line">            public GameObject gameObject;</span><br><span class="line">            public bool canDrag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private Camera m_Camera;</span><br><span class="line">        private RawImage m_RawImage;</span><br><span class="line">        private RenderTexture m_RenderTexture;</span><br><span class="line">        private Dictionary&lt;int, Target&gt; m_Targets;</span><br><span class="line">        private int m_Index;</span><br><span class="line">        private Transform m_DragTarget;</span><br><span class="line"></span><br><span class="line">        public Dictionary&lt;int, Target&gt; Targets &#x3D;&gt; m_Targets;</span><br><span class="line">        public int Index &#x3D;&gt; m_Index;</span><br><span class="line"></span><br><span class="line">        void OnEnable()</span><br><span class="line">        &#123;</span><br><span class="line">            InitCamera();</span><br><span class="line"></span><br><span class="line">            if (m_RawImage &#x3D;&#x3D; null)</span><br><span class="line">                m_RawImage &#x3D; GetComponent&lt;RawImage&gt;();</span><br><span class="line"></span><br><span class="line">            if (m_Targets !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (var target in m_Targets.Values)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(target.gameObject !&#x3D; null)</span><br><span class="line">                        target.gameObject.SetActive(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (m_RenderTexture &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RenderTexture &#x3D; RenderTexture.GetTemporary((int)m_RawImage.rectTransform.rect.width, (int)m_RawImage.rectTransform.rect.height, 1);</span><br><span class="line">                m_RenderTexture.name &#x3D; &quot;UIRenderToTexture&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            m_Camera.targetTexture &#x3D; m_RenderTexture;</span><br><span class="line">            m_RawImage.texture &#x3D; m_RenderTexture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void OnDisable()</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_Targets !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (var target in m_Targets.Values)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(target.gameObject !&#x3D; null)</span><br><span class="line">                        target.gameObject.SetActive(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (m_Camera !&#x3D; null)</span><br><span class="line">                Hooks.UIModelManager.RecyleCamera(m_Camera);</span><br><span class="line"></span><br><span class="line">            ReleaseRenderTexture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void OnDestroy()</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_Camera !&#x3D; null)</span><br><span class="line">                Hooks.UIModelManager.RecyleCamera(m_Camera);</span><br><span class="line">            ReleaseRenderTexture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void InitCamera(bool orth &#x3D; true)</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_Camera &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Camera &#x3D; Hooks.UIModelManager.SpawnCamera();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                m_Camera.gameObject.SetActive(true);</span><br><span class="line">            &#125;</span><br><span class="line">            m_Camera.orthographic &#x3D; orth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void ReleaseRenderTexture()</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_RenderTexture !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                RenderTexture.ReleaseTemporary(m_RenderTexture);</span><br><span class="line">                m_RenderTexture &#x3D; null;</span><br><span class="line">                m_RawImage.texture &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Init(Vector3 vec, bool orth, int index)</span><br><span class="line">        &#123;</span><br><span class="line">            InitCamera(orth);</span><br><span class="line">            m_Index &#x3D; index;</span><br><span class="line">            if (m_Camera)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Camera.transform.localPosition &#x3D; vec + new Vector3(0, 0, 20);</span><br><span class="line">                m_Camera.transform.localEulerAngles &#x3D; new Vector3(0, 180, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void AddTarget(GameObject target, bool canDrag)</span><br><span class="line">        &#123;</span><br><span class="line">            if (target)</span><br><span class="line">            &#123;</span><br><span class="line">                if (m_Targets &#x3D;&#x3D; null)</span><br><span class="line">                    m_Targets &#x3D; new Dictionary&lt;int, Target&gt;();</span><br><span class="line">                m_Targets.Add(target.GetInstanceID(), new Target &#123; gameObject &#x3D; target, canDrag &#x3D; canDrag &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void ResetTarget()</span><br><span class="line">        &#123;</span><br><span class="line">            m_Targets.Clear();</span><br><span class="line">            m_Targets &#x3D; null;</span><br><span class="line">            if (m_Camera !&#x3D; null)</span><br><span class="line">                Hooks.UIModelManager.RecyleCamera(m_Camera);</span><br><span class="line">            ReleaseRenderTexture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_Targets !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (var target in m_Targets.Values)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(m_DragTarget &#x3D;&#x3D; null || m_DragTarget.gameObject !&#x3D; target.gameObject)</span><br><span class="line">                        target.gameObject.transform.rotation &#x3D; Quaternion.Lerp(target.gameObject.transform.rotation, Quaternion.identity, Time.deltaTime * 5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void SetClickTarget(Vector2 clickPos)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过射线检测当前点击的模型</span><br><span class="line">            &#x2F;&#x2F; 拿到点击位置与UI位置的偏移百分比</span><br><span class="line">            Camera uiCamera &#x3D; Hooks.CameraManager.UICamera;</span><br><span class="line">            float width &#x3D; m_RawImage.rectTransform.rect.width;</span><br><span class="line">            float height &#x3D; m_RawImage.rectTransform.rect.height;</span><br><span class="line">            Vector2 screenPos &#x3D; RectTransformUtility.WorldToScreenPoint(uiCamera, transform.position);</span><br><span class="line">            screenPos +&#x3D; new Vector2(width * (0.5f - m_RawImage.rectTransform.pivot.x), height * (0.5f - m_RawImage.rectTransform.pivot.y));</span><br><span class="line">            Vector2 offset &#x3D; clickPos - screenPos;</span><br><span class="line">            offset &#x3D; new Vector2(offset.x &#x2F; width, offset.y &#x2F; height);</span><br><span class="line">            if (m_Camera.orthographic)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 正交相机的渲染大小height&#x3D;size*2， width &#x3D; 宽高比*height</span><br><span class="line">                float screenHeight &#x3D; m_Camera.orthographicSize * 2;</span><br><span class="line">                float screenWidth &#x3D; m_Camera.pixelWidth * 1.0f &#x2F; m_Camera.pixelHeight * screenHeight;</span><br><span class="line">                Vector3 startPoint &#x3D; m_Camera.transform.position + m_Camera.transform.right * offset.x * screenWidth + m_Camera.transform.up * offset.y * screenHeight;</span><br><span class="line"></span><br><span class="line">                Debug.DrawLine(startPoint, startPoint + m_Camera.transform.forward * 100, Color.red, 5f);</span><br><span class="line">                if (Physics.Raycast(startPoint, m_Camera.transform.forward, out RaycastHit hit, 100, 1 &lt;&lt; Constant.Layer.UIRenderToTarget))</span><br><span class="line">                &#123;</span><br><span class="line">                    m_DragTarget &#x3D; hit.transform;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 透视相机通过FOV和near可以求height， width同正交相机</span><br><span class="line">                float screenHeight &#x3D; Mathf.Tan(m_Camera.fieldOfView * 0.5f * Mathf.Deg2Rad) * m_Camera.nearClipPlane * 2;</span><br><span class="line">                float screenWidth &#x3D; m_Camera.pixelWidth * 1.0f &#x2F; m_Camera.pixelHeight * screenHeight;</span><br><span class="line">                Vector3 endPoint &#x3D; m_Camera.transform.position + m_Camera.transform.forward * m_Camera.nearClipPlane</span><br><span class="line">                    + m_Camera.transform.right * offset.x * screenWidth + m_Camera.transform.up * offset.y * screenHeight;</span><br><span class="line">                Vector3 dir &#x3D; (endPoint - m_Camera.transform.position).normalized;</span><br><span class="line"></span><br><span class="line">                Debug.DrawLine(m_Camera.transform.position, endPoint, Color.red, 5f);</span><br><span class="line">                if (Physics.Raycast(m_Camera.transform.position, dir, out RaycastHit hit, m_Camera.farClipPlane, 1 &lt;&lt; Constant.Layer.UIRenderToTarget))</span><br><span class="line">                &#123;</span><br><span class="line">                    m_DragTarget &#x3D; hit.transform;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnBeginDrag(PointerEventData eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            m_DragTarget &#x3D; null;</span><br><span class="line">            SetClickTarget(eventData.position);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 不能拖拽时置空</span><br><span class="line">            if (m_DragTarget !&#x3D; null &amp;&amp; m_Targets.TryGetValue(m_DragTarget.GetInstanceID(), out Target target) &amp;&amp; !target.canDrag)</span><br><span class="line">            &#123;</span><br><span class="line">                m_DragTarget &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnDrag(PointerEventData eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            if (m_DragTarget !&#x3D; null)</span><br><span class="line">                m_DragTarget.localEulerAngles -&#x3D; new Vector3(0, eventData.delta.x, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnEndDrag(PointerEventData eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            m_DragTarget &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnPointerClick(PointerEventData eventData)</span><br><span class="line">        &#123;</span><br><span class="line">            m_DragTarget &#x3D; null;</span><br><span class="line">            SetClickTarget(eventData.position);</span><br><span class="line"></span><br><span class="line">            if (m_DragTarget !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 点中模型，发送事件或者其他操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ScrollView扩展"><a href="#ScrollView扩展" class="headerlink" title="ScrollView扩展"></a>ScrollView扩展</h1>]]></content>
    
    
    <summary type="html">Unity 开发一些记录</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C# Task用法记录</title>
    <link href="https://skierhou.github.io/2021/12/01/CSharp/Task/"/>
    <id>https://skierhou.github.io/2021/12/01/CSharp/Task/</id>
    <published>2021-12-01T06:30:01.000Z</published>
    <updated>2021-12-21T12:17:27.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://www.cnblogs.com/zhaoshujie/p/11082753.html">超详细： https://www.cnblogs.com/zhaoshujie/p/11082753.html</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1">官方： https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>ThreadPool相比Thread来说具备了很多优势，但是ThreadPool却又存在一些使用上的不方便。比如：</p><ul><li>ThreadPool不支持线程的取消、完成、失败通知等交互性操作；</li><li>ThreadPool不支持线程执行的先后次序；</li></ul><h1 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h1><ol><li>函数标记async，则执行这个函数会启用一个线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static async Task Test()</span><br><span class="line">&#123;</span><br><span class="line">    await Task.Run(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; Just loop.</span><br><span class="line">        int ctr &#x3D; 0;</span><br><span class="line">        for (ctr &#x3D; 0; ctr &lt;&#x3D; 1000000; ctr++)</span><br><span class="line">        &#123; &#125;</span><br><span class="line">        Console.WriteLine(&quot;Finished &#123;0&#125; loop iterations&quot;,</span><br><span class="line">                            ctr);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(&quot;Finish111&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Task t = Task.Factory.StartNew(action);</li><li>Task t = new Task(action);<br> t.Start();    //new Task() 默认不会启动 需要主动启动</li><li>父任务包含子任务：关键是父任务中，创建子任务且设置TaskCreationOptions.AttachedToParent<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;string[]&gt; parent &#x3D; new Task&lt;string[]&gt;(state &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;创建并启动子任务</span><br><span class="line">    string[] result &#x3D; new string[2];</span><br><span class="line">        new Task(() &#x3D;&gt; &#123; Thread.Sleep(2000); result[0] &#x3D; &quot;我是子任务1。&quot;; &#125;, TaskCreationOptions.AttachedToParent).Start();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">parent.Start();</span><br><span class="line">&#x2F;&#x2F;等待子任务执行完，parent才算执行完成</span><br></pre></td></tr></table></figure></li></ol><h1 id="挂起函数-等待任务完成-注：’t’-代表Task实例"><a href="#挂起函数-等待任务完成-注：’t’-代表Task实例" class="headerlink" title="挂起函数 等待任务完成 注：’t’ 代表Task实例"></a>挂起函数 等待任务完成 注：’t’ 代表Task实例</h1><ol><li>等待1个，t.wait();</li><li>等待多个Task，Task.WaitAll(Task[]);</li><li>等待多个Task到其中第一个完成为止，Task.WaitAny(Task[])</li><li>Task完成后执行，t.ContinueWith(Action<Task>)</Task></li></ol><h1 id="Task-接口分析"><a href="#Task-接口分析" class="headerlink" title="Task 接口分析"></a>Task 接口分析</h1><ol><li><p>取消Task<br>设置Task的CancellationToken<br>var cts = new CancellationTokenSource();<br>cts.Cancel();</p></li><li><p>异常处理<br>单个任务：<br>Try{}<br>catch (Exception ex){}<br>多个任务：<br>Try{}<br>Catch(AggregateException ex){}</p></li><li><p>IProgress异步编程的进程通知<br>通过Report传入自定义T值，Progress执行委托</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void DoProcessing(IProgress&lt;int&gt; progress)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; 100; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(100);</span><br><span class="line">        if (progress !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            progress.Report(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static async Task Display()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;当前线程</span><br><span class="line">    var progress &#x3D; new Progress&lt;int&gt;(percent &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Clear();</span><br><span class="line">        Console.Write(&quot;&#123;0&#125;%&quot;, percent);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;线程池线程</span><br><span class="line">    await Task.Run(() &#x3D;&gt; DoProcessing(progress));</span><br><span class="line">    Console.WriteLine(&quot;&quot;);</span><br><span class="line">    Console.WriteLine(&quot;结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">C# Task用法记录</summary>
    
    
    
    <category term="Task" scheme="https://skierhou.github.io/categories/Task/"/>
    
    
    <category term="C#" scheme="https://skierhou.github.io/tags/C/"/>
    
    <category term="Task" scheme="https://skierhou.github.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>C# Thread记录</title>
    <link href="https://skierhou.github.io/2021/12/01/CSharp/Thread/"/>
    <id>https://skierhou.github.io/2021/12/01/CSharp/Thread/</id>
    <published>2021-12-01T06:30:01.000Z</published>
    <updated>2021-12-21T12:17:24.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://www.cnblogs.com/luxiaoxun/p/3280146.html">精简详细： https://www.cnblogs.com/luxiaoxun/p/3280146.html</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?redirectedfrom=MSDN&view=net-5.0">官网： https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?redirectedfrom=MSDN&amp;view=net-5.0</a><br><a href="https://www.cnblogs.com/chenwolong/p/AutoResetEvent.html">Event用法： https://www.cnblogs.com/chenwolong/p/AutoResetEvent.html</a><br><a href="https://www.cnblogs.com/yifengjianbai/p/5468449.html">Semaphore用法： https://www.cnblogs.com/yifengjianbai/p/5468449.html</a><br><a href="https://www.cnblogs.com/nele/p/5534580.html">Mutex用法： https://www.cnblogs.com/nele/p/5534580.html</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li>进程与线程：进程作为操作系统执行程序的基本单位，拥有应用程序的资源，进程包含线程，进程的资源被线程共享，线程不拥有资源。</li><li>前台线程和后台线程：通过Thread类新建线程默认为前台线程。当所有前台线程关闭时，所有的后台线程也会被直接终止，不会抛出异常。</li></ul><ol><li>普通Thread<br>Thread t1 = new Thread(new ThreadStart(TestMethod));   //不带参数<br>Thread t2 = new Thread(new ParameterizedThreadStart(TestMethod));   //带一个object参数</li></ol><table><thead><tr><th>函数</th><th align="center">注释</th></tr></thead><tbody><tr><td>Start();</td><td align="center">启动线程</td></tr><tr><td>Suspend();</td><td align="center">挂起线程</td></tr><tr><td>Resume();</td><td align="center">挂起线程</td></tr><tr><td>Abort();</td><td align="center">打断线程</td></tr><tr><td>Join();</td><td align="center">其他线程挂起，等待线程完成后执行之后的逻辑 与Task的Wait()类似</td></tr></tbody></table><ol start="2"><li><p>ThreadPool<br>作用：为了减少Thread创建销毁的开销<br>ThreadPool.QueueUserWorkItem(TestMethod, “Hello”);   //创建并开启线程，可传入一个object参数</p></li><li><p>AutoResetEvent和ManualResetEvent的使用：即信号量的使用<br>Event用法： <a href="https://www.cnblogs.com/chenwolong/p/AutoResetEvent.html">https://www.cnblogs.com/chenwolong/p/AutoResetEvent.html</a><br>构造函数：参数：true:非阻塞(不阻塞线程)，false：阻塞。<br>区别：AutoResetEvent在每次WaitOne()后自动Reset()信号，而ManualResetEvent不会自动Reset()信号，需要手动Reset()</p></li><li><p>Semaphore信号量：为了协调多个线程合理分配资源<br>Semaphore用法： <a href="https://www.cnblogs.com/yifengjianbai/p/5468449.html">https://www.cnblogs.com/yifengjianbai/p/5468449.html</a></p></li><li><p>Mutex互斥锁：同一时间只能有一个线程获取它<br>Mutex用法： <a href="https://www.cnblogs.com/nele/p/5534580.html">https://www.cnblogs.com/nele/p/5534580.html</a><br>构造：new Mutex();<br>申请：WaitOne();<br>释放：ReleaseMutex();</p></li><li><p>Monitor排他锁：<br>通过Monitor.Enter() 和 Monitor.Exit()实现排它锁的获取和释放，获取之后独占资源，不允许其他线程访问<br>lock()语法是简化版本理解为Monitor.Enter() 和 Monitor.Exit()的语法糖</p></li><li><p>WaitHandle：以上线程同步操作的公共基类<br>提供静态函数：WaitAll，WaitAny<br>WaitAll：等待一组WaitHandle全部完成，<br>WaitAny：等待一组WaitHandle中的一个完成，只要判断有完成的即结束等待，返回值：数组的索引，如没有执行完成的则返回-1</p></li></ol>]]></content>
    
    
    <summary type="html">C# Thread记录</summary>
    
    
    
    <category term="Thread" scheme="https://skierhou.github.io/categories/Thread/"/>
    
    
    <category term="C#" scheme="https://skierhou.github.io/tags/C/"/>
    
    <category term="Thread" scheme="https://skierhou.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>URP效果实现,从基础慢慢深入</title>
    <link href="https://skierhou.github.io/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://skierhou.github.io/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-30T06:30:01.000Z</published>
    <updated>2021-12-21T12:18:20.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>之前学习过入门精要，之后就很少接触了，现在接触URP，再学习一遍入门精要也顺便学习下HLSL，<br>主要是对着链接中的<a href="https://space.bilibili.com/5863867/article">URP HLSL入门学习</a>进行学习，会有一定自己的扩展</p><h1 id="基础光照模型"><a href="#基础光照模型" class="headerlink" title="基础光照模型"></a>基础光照模型</h1><h2 id="基础公式"><a href="#基础公式" class="headerlink" title="基础公式"></a>基础公式</h2><ul><li>Lambert：     max(0,dot(L,N))</li><li>HalfLambert： max(0,dot(L,N)) * 0.5 + 0.5</li><li>Phong：       pow(max(0,dot(reflect(-L,N), V)), Gloss)</li><li>BlinnPhong：  pow(max(0,dot(normalize(L+V), N)), Gloss)</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li><p>Lambert / HalfLambert</p><figure class="highlight plain"><figcaption><span>/ HalfLambert</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Lambert&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BaseColor (&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS:TEXCOORD1; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true); </span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            Light mylight &#x3D; GetMainLight(); </span><br><span class="line">            real4 LightColor &#x3D; real4(mylight.color, 1); </span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction);</span><br><span class="line">            float lambert &#x3D; dot(normalize(i.normalWS), lightDir);</span><br><span class="line">            float halfLambert &#x3D; lambert * 0.5f + 0.5f;</span><br><span class="line"></span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            return color * _BaseColor * halfLambert * LightColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Phong / BlinnPhong</p><figure class="highlight plain"><figcaption><span>/ BlinnPhong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Phong&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _GlossColor(&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;, Range(1, 256)) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _GlossColor;</span><br><span class="line">        float _Gloss;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS:TEXCOORD1;</span><br><span class="line">            float3 viewDirWS:TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.viewDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - TransformObjectToWorld(i.positionOS.xyz));&#x2F;&#x2F;得到世界空间的视图方向 </span><br><span class="line">            o.normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            Light mylight &#x3D; GetMainLight();</span><br><span class="line">            real4 LightColor &#x3D; real4(mylight.color, 1);</span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction);</span><br><span class="line">            float3 viewDir &#x3D; normalize(i.viewDirWS);</span><br><span class="line">            float3 worldNormal &#x3D; normalize(i.normalWS);</span><br><span class="line">            float phong &#x3D; pow(max(dot(reflect(-lightDir, worldNormal), viewDir), 0), _Gloss);</span><br><span class="line">            float blinnPhong &#x3D; pow(max(dot(normalize(lightDir + viewDir), worldNormal), 0), _Gloss);</span><br><span class="line"></span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            float4 diffuse &#x3D; LightColor * col * max(dot(lightDir, worldNormal), 0);</span><br><span class="line">            float4 specular &#x3D; _GlossColor * blinnPhong * LightColor;</span><br><span class="line">            return float4(specular.rgb + diffuse.rgb, col.a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>TransformObjectToHClip</li><li>TransformObjectToWorld</li><li>TransformObjectToWorldNormal</li><li>_WorldSpaceCameraPos</li><li>光照信息： #include “Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl”</li><li>SubShader{HLSLINCLUDE … ENDHLSL}  Pass{HLSLPROGRAM … ENDHLSL}   (第一次写Pass中写成HLSLEINCLUDE了，没报错效果又一直是错的，注意了！！！)</li></ul><h1 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h1><h2 id="基础简介"><a href="#基础简介" class="headerlink" title="基础简介"></a>基础简介</h2><ol><li><p>我们采用在世界坐标系下，在片元着色器中进行计算。<br>定义顶点着色器拿到数据的结构体，我们需要顶点位置，uv，顶点法线，顶点切线</p></li><li><p>获得世界坐标系下的：顶点位置，法线，切线，副切线<br>计算副切线时，叉乘法线，切线，并在乘切线的w值判断正负，在乘负奇数缩放影响因子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.BtangentWS&#x3D; cross(o.normal.xyz,o.tangent.xyz) * i.tangent.w;</span><br></pre></td></tr></table></figure></li><li><p>片元处理中采样法线贴图，得切线空间法线，在将其转换到世界空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float3x3 T2W &#x3D; &#123;i.tangentWS.xyz,i.BtangentWS.xyz,i.normalWS.xyz&#125;; </span><br><span class="line">float4 norTex &#x3D; SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex, i.uv);</span><br><span class="line">float3 nomralTS &#x3D; UnpackNormalScale(norTex, _NormalScale);</span><br><span class="line">normalTS.z&#x3D;pow((1-pow(normalTS.x,2)-pow(normalTS.y,2)),0.5); &#x2F;&#x2F;规范化法线 不影响x,y情况下规范化z轴</span><br><span class="line">float3 normalWS &#x3D; normalize(mul(normalTS,T2W));</span><br></pre></td></tr></table></figure></li><li><p>使用带入法线贴图计算后的法线用于后续计算即可。</p></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Normal&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        [Normal]_NormalTex(&quot;NormalTex&quot;, 2D) &#x3D; &quot;bump&quot;&#123;&#125;</span><br><span class="line">        _NormalScale(&quot;NormalScale&quot;, float) &#x3D; 1</span><br><span class="line">        [HDR]_SpecularColor(&quot;SpecularColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;,Range(1,256)) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_NormalTex);</span><br><span class="line">        SAMPLER(sampler_NormalTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _NormalTex_ST;</span><br><span class="line">        float _NormalScale;</span><br><span class="line">        float4 _SpecularColor;</span><br><span class="line">        float _Gloss;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float4 tangentOS:TANGENT;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float4 uv            : TEXCOORD0;</span><br><span class="line">            float4 normalWS:TEXCOORD1;</span><br><span class="line">            float4 tangentWS:TEXCOORD2;</span><br><span class="line">            float4 BtangentWS:TEXCOORD3;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS);</span><br><span class="line">            o.normalWS.xyz &#x3D; normalize(TransformObjectToWorldNormal(i.normalOS));</span><br><span class="line">            o.tangentWS.xyz &#x3D; normalize(TransformObjectToWorld(i.tangentOS));</span><br><span class="line">            o.BtangentWS.xyz &#x3D; cross(o.normalWS.xyz, o.tangentWS.xyz) * i.tangentOS.w * unity_WorldTransformParams.w;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 存一下世界空间坐标</span><br><span class="line">            float3 positionWS &#x3D; TransformObjectToWorld(i.positionOS);</span><br><span class="line">            o.tangentWS.w &#x3D; positionWS.x;</span><br><span class="line">            o.BtangentWS.w &#x3D; positionWS.y;</span><br><span class="line">            o.normalWS.w &#x3D; positionWS.z;</span><br><span class="line"></span><br><span class="line">            o.uv.xy &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.uv.zw &#x3D; TRANSFORM_TEX(i.uv, _NormalTex);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 norTex &#x3D; SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex, i.uv.zw);</span><br><span class="line">            float3 positionWS &#x3D; float3(i.tangentWS.w, i.BtangentWS.w, i.normalWS.w);</span><br><span class="line">            float3x3 T2W &#x3D; &#123;i.tangentWS.xyz, i.BtangentWS.xyz, i.normalWS.xyz&#125;;</span><br><span class="line"></span><br><span class="line">            float3 normalTS &#x3D; UnpackNormalScale(norTex, _NormalScale);</span><br><span class="line">            normalTS.z &#x3D; pow(1 - pow(normalTS.x, 2) - pow(normalTS.y, 2), 0.5f);    &#x2F;&#x2F;规范化</span><br><span class="line">            float3 normalWS &#x3D; mul(normalTS, T2W);</span><br><span class="line">            float3 viewDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - positionWS);</span><br><span class="line">            Light myLight &#x3D; GetMainLight();</span><br><span class="line">            float3 lightDir &#x3D; normalize(myLight.direction);</span><br><span class="line"></span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv.xy);</span><br><span class="line"></span><br><span class="line">            float halfLambert &#x3D; dot(normalWS, lightDir) * 0.5f + 0.5f;</span><br><span class="line">            float3 diffuse &#x3D; myLight.color * col.xyz * halfLambert;</span><br><span class="line">            float3 specular &#x3D; myLight.color * _SpecularColor.rgb * pow(dot(normalize(viewDirWS + lightDir), normalWS), _Gloss);</span><br><span class="line"></span><br><span class="line">            return float4(diffuse + specular, col.a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>规范化向量一般用normalize，在不想影响xy轴情况下可以使用勾股定理自己计算另一个轴的值</li><li>UnpackNormal，UnpackNormalScale</li><li>mul(), 矩阵相乘</li><li>为了节省空间，可以将一些值藏在部分多余参数中，比如这次代码中，将世界空间坐标xyz分别写在切线，副切线，法线的w值上</li></ul><h1 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h1><h2 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h2><p>不适用常规的模型uv，而是使用lambert/halflambert的值作为x轴或y轴，对渐变纹理图进行采样</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Ramp&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _RampTex(&quot;RampTex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_RampTex);</span><br><span class="line">        SAMPLER(sampler_RampTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _RampTex_ST;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS :TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.normalWS &#x3D; normalize(TransformObjectToWorldNormal(i.normalOS));</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">            Light light &#x3D; GetMainLight();</span><br><span class="line">            float3 lightDir &#x3D; normalize(light.direction);</span><br><span class="line">            float3 normalWS &#x3D; normalize(i.normalWS);</span><br><span class="line">            float halfLambert &#x3D; dot(lightDir, normalWS) * 0.5f + 0.5f;</span><br><span class="line">            float4 ramp &#x3D; SAMPLE_TEXTURE2D(_RampTex, sampler_RampTex, float2(halfLambert, 0.5f));</span><br><span class="line"></span><br><span class="line">            return ramp * col * float4(light.color, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AlphaTest"><a href="#AlphaTest" class="headerlink" title="AlphaTest"></a>AlphaTest</h1><h2 id="基础简介-1"><a href="#基础简介-1" class="headerlink" title="基础简介"></a>基础简介</h2><p>使用clip，在片元着色器对裁剪一些像素</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;AlphaTest&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BaseColor(&quot;BaseColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        [HDR]_BurnColor(&quot;BurnColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Cutoff (&quot;Cutoff&quot;, Range(0,1)) &#x3D; 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;TransparentCutout&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot; &quot;Queue&quot; &#x3D; &quot;AlphaTest&quot; &#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_RampTex);</span><br><span class="line">        SAMPLER(sampler_RampTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        float4 _BurnColor;</span><br><span class="line">        float _Cutoff;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _BaseColor;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; step(_Cutoff, col.r)  &#x3D;  (_Cutoff &lt;&#x3D; col.r ? 1 : 0)</span><br><span class="line">            clip(step(_Cutoff, col.r) - 0.01);</span><br><span class="line">            col &#x3D; lerp(col, _BurnColor, step(col.r, saturate(_Cutoff + 0.1))) ;</span><br><span class="line">            return col;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>clip()， 参数小于0则裁剪</li><li>step(a,b) 等价于  a &lt;= b ? 1 : 0， 用于优化shader代码中的if，else</li></ul><h1 id="AlphaBlend"><a href="#AlphaBlend" class="headerlink" title="AlphaBlend"></a>AlphaBlend</h1><h2 id="基础简介-2"><a href="#基础简介-2" class="headerlink" title="基础简介"></a>基础简介</h2><ol><li>关闭深度写入</li><li>渲染队列，渲染类型设置成Transparent 透明的</li><li>设置Blend</li></ol><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;AlphaBlend&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaTex(&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BaseColor(&quot;BaseColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123; </span><br><span class="line">        Tags&#123;</span><br><span class="line"></span><br><span class="line">        &quot;RenderPipeline&quot; &#x3D; &quot;UniversalRenderPipeline&quot;</span><br><span class="line"></span><br><span class="line">         &quot;IgnoreProjector&quot; &#x3D; &quot;True&quot;</span><br><span class="line"></span><br><span class="line">         &quot;RenderType&quot; &#x3D; &quot;Transparent&quot;</span><br><span class="line"></span><br><span class="line">         &quot;Queue&quot; &#x3D; &quot;Transparent&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ZWrite Off</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line">        TEXTURE2D(_AlphaTex);</span><br><span class="line">        SAMPLER(sampler_AlphaTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _AlphaTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float4 uv            : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS);</span><br><span class="line">            o.uv.xy &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.uv.zw &#x3D; TRANSFORM_TEX(i.uv, _AlphaTex);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv.xy) * _BaseColor;</span><br><span class="line">            float alpha &#x3D; SAMPLE_TEXTURE2D(_AlphaTex, sampler_AlphaTex, i.uv.zw).a;</span><br><span class="line">            return float4(col.rgb, alpha);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul><li>“IgnoreProjector” = “True”， 忽视</li></ul><h1 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>首先需要获取多光源，通过GetAdditionalLightsCount()，GetAdditionalLight(index, positionWS)两个函数处理多光源</li><li>将主光源计算后的颜色，叠加所有叠加光源颜色输出</li></ul><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;MulLight&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BaseColor (&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        [KeywordEnum(ON,OFF)]_ADD_LIGHT(&quot;AddLight&quot;,float) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS:TEXCOORD1; </span><br><span class="line">            float3 positionWS:TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true); </span><br><span class="line">            o.positionWS &#x3D; TransformObjectToWorld(i.positionOS.xyz);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            Light mylight &#x3D; GetMainLight(); </span><br><span class="line">            real4 LightColor &#x3D; real4(mylight.color, 1); </span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction);</span><br><span class="line">            float3 normalWS &#x3D; normalize(i.normalWS);</span><br><span class="line">            float halfLambert &#x3D; dot(normalWS, lightDir) * 0.5f + 0.5f;</span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _BaseColor * halfLambert * LightColor;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; AddLight</span><br><span class="line">            float4 addLightColor &#x3D; float4(0,0,0,1);</span><br><span class="line"></span><br><span class="line">            #if _ADD_LIGHT_ON</span><br><span class="line">            int lightCount &#x3D; GetAdditionalLightsCount();</span><br><span class="line">            for (int index &#x3D; 0; index &lt; lightCount; index++)</span><br><span class="line">            &#123;</span><br><span class="line">                Light light &#x3D; GetAdditionalLight(index, i.positionWS);</span><br><span class="line">                addLightColor +&#x3D; (dot(normalWS, normalize(light.direction)) * 0.5f + 0.5f) </span><br><span class="line">                    * real4(light.color, 1) * light.distanceAttenuation * light.shadowAttenuation;</span><br><span class="line">            &#125;</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            return color + addLightColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            #pragma shader_feature _ADD_LIGHT_ON _ADD_LIGHT_OFF</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul><li>shader枚举开关：<br>[KeywordEnum(ON,OFF)]_ADD_LIGHT(“AddLight”,float) = 1   //定义shader中的枚举 只有ON,OFF两个选项<br>#pragma shader_feature _ADD_LIGHT_ON _ADD_LIGHT_OFF     //定义shader_feature 规则：参数名_枚举名 （需要把所有定义的选项都放进去）<br>#if _ADD_LIGHT_ON … #endif  使用</li></ul><h1 id="阴影投射和接收"><a href="#阴影投射和接收" class="headerlink" title="阴影投射和接收"></a>阴影投射和接收</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ol><li><p>投射<br>使用官方写好的阴影投射Pass UsePass “Universal Render Pipeline/Lit/ShadowCaster”<br>使用官方写好的 不支持SRP Batcher， 因此自己写阴影投射Pass<br>参考”Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl”</p></li><li><p>接收<br>TransformWorldToShadowCoord(i.positionWS)     //获得shadowcoord<br>GetMainLight(shadowcoord).shadowAttenuation   //获得阴影值<br>#pragma multi_compile _ _MAIN_LIGHT_SHADOWS //开启阴影<br>#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE //级联阴影<br>#pragma multi_compile _ _SHADOWS_SOFT //柔化阴影，得到软阴影 </p></li><li><p>额外光源阴影接收</p></li></ol><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><ul><li><p>主光源阴影接收Shader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Shadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _GlossColor(&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;, Range(1, 256)) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _GlossColor;</span><br><span class="line">        float _Gloss;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS:TEXCOORD1;</span><br><span class="line">            float3 positionWS:TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.positionWS &#x3D; TransformObjectToWorld(i.positionOS.xyz);</span><br><span class="line">            o.normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            Light mylight &#x3D; GetMainLight(TransformWorldToShadowCoord(i.positionWS));</span><br><span class="line">            real4 LightColor &#x3D; real4(mylight.color, 1);</span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction);</span><br><span class="line">            float3 viewDir &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.positionWS);</span><br><span class="line">            float3 worldNormal &#x3D; normalize(i.normalWS);</span><br><span class="line">            float phong &#x3D; pow(max(dot(reflect(-lightDir, worldNormal), viewDir), 0), _Gloss);</span><br><span class="line">            float blinnPhong &#x3D; pow(max(dot(normalize(lightDir + viewDir), worldNormal), 0), _Gloss);</span><br><span class="line"></span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            float4 diffuse &#x3D; LightColor * col * max(dot(lightDir, worldNormal), 0) * mylight.shadowAttenuation;</span><br><span class="line">            float4 specular &#x3D; _GlossColor * blinnPhong * LightColor * mylight.shadowAttenuation;</span><br><span class="line">            return float4(specular.rgb + diffuse.rgb, col.a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS &#x2F;&#x2F;开启阴影</span><br><span class="line">            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE &#x2F;&#x2F;级联阴影</span><br><span class="line">            #pragma multi_compile _ _SHADOWS_SOFT &#x2F;&#x2F;柔化阴影，得到软阴影 </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">        UsePass &quot;Universal Render Pipeline&#x2F;Lit&#x2F;ShadowCaster&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>额外光源阴影接收Shader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AddLight</span><br><span class="line">float4 addLightColor &#x3D; float4(0, 0, 0, 1);</span><br><span class="line"></span><br><span class="line">#if _ADD_LIGHT_ON</span><br><span class="line">    #if defined(SHADOWS_SHADOWMASK) &amp;&amp; defined(LIGHTMAP_ON)</span><br><span class="line">        half4 shadowMask &#x3D; inputData.shadowMask;</span><br><span class="line">    #elif !defined (LIGHTMAP_ON)</span><br><span class="line">        half4 shadowMask &#x3D; unity_ProbesOcclusion;</span><br><span class="line">    #else</span><br><span class="line">        half4 shadowMask &#x3D; half4(1, 1, 1, 1);</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    int lightCount &#x3D; GetAdditionalLightsCount();</span><br><span class="line">    for (int index &#x3D; 0; index &lt; lightCount; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        Light light &#x3D; GetAdditionalLight(index, i.positionWS, shadowMask);</span><br><span class="line">        addLightColor +&#x3D; (dot(normalWS, normalize(light.direction)) * 0.5f + 0.5f)</span><br><span class="line">            * real4(light.color, 1) * light.distanceAttenuation * light.shadowAttenuation;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>主光源投射阴影</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;参考 &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;Shaders&#x2F;ShadowCasterPass.hlsl&quot;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Name &quot;ShadowCaster&quot;</span><br><span class="line">    Tags&#123;&quot;LightMode&quot; &#x3D; &quot;ShadowCaster&quot;&#125;</span><br><span class="line"></span><br><span class="line">    ZWrite On</span><br><span class="line">    ZTest LEqual</span><br><span class="line">    ColorMask 0</span><br><span class="line"></span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    #pragma vertex VertShadowCaster</span><br><span class="line">    #pragma fragment FragShadowCaster</span><br><span class="line"></span><br><span class="line">    Varyings VertShadowCaster(Attributes i)</span><br><span class="line">    &#123;</span><br><span class="line">        Varyings o;</span><br><span class="line">        o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">        float3 positionWS &#x3D; TransformObjectToWorld(i.positionOS.xyz);</span><br><span class="line">        float3 normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true);</span><br><span class="line">        Light light &#x3D; GetMainLight();</span><br><span class="line">        o.positionHS &#x3D; TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, light.direction.xyz));</span><br><span class="line">        </span><br><span class="line">        #if UNITY_REVERSED_Z</span><br><span class="line">            o.positionHS.z &#x3D; min(o.positionHS.z, o.positionHS.w * UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">        #else</span><br><span class="line">            o.positionHS.z &#x3D; max(o.positionHS.z, o.positionHS.w * UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">        #endif</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    half4 FragShadowCaster(Varyings i) :SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li>查看源码思路，最终需要得到阴影值，从Light中看到shadowAttenuation是我们需要的<br>通过 GetMainLight(shadowcoord) 或者 GetMainLight(float4 shadowCoord, float3 positionWS, half4 shadowMask) 获得的阴影会被赋值<br>调用了Shadow.hlsl中的 MainLightRealtimeShadow 以及 MainLightShadow<br>查看其中判断的宏可以发现需要 MAIN_LIGHT_CALCULATE_SHADOWS， 全局搜索发现开启 _MAIN_LIGHT_SHADOWS 后会定义MAIN_LIGHT_CALCULATE_SHADOWS<br>函数网里面跟进可以看到_MAIN_LIGHT_SHADOWS_CASCADE _SHADOWS_SOFT 还有其他一些宏，看使用情况开启即可</li></ul><p>GetMainLight需要参数 shadowcoord， 在Shadow.hlsl 查找shadowcoord 可以找到几个函数，<br>再看参数和调用地方，可以确认TransformWorldToShadowCoord函数我们可以直接使用</p><ul><li>初次看URP源码，先记录下在初次使用时寻找关键函数的思路</li></ul><h1 id="序列帧"><a href="#序列帧" class="headerlink" title="序列帧"></a>序列帧</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><ul><li>将一张序列帧图片分块，按块采样显示，间隔一定时间切换下一块</li></ul><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;SequenceFrame&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FrameRate(&quot;FrameRate&quot;,float) &#x3D; 10</span><br><span class="line">        _Sheet(&quot;Sheet&quot;,Vector) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float _FrameRate;</span><br><span class="line">        float4 _Sheet;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            float2 uv &#x3D; 0;</span><br><span class="line">            uv.x &#x3D;  i.uv.x &#x2F; _Sheet.x + frac(floor(_Time.y * _FrameRate) &#x2F; _Sheet.x);</span><br><span class="line">            uv.y &#x3D; i.uv.y &#x2F; _Sheet.y + 1 - frac(floor(_Time.y * _FrameRate &#x2F; _Sheet.x) &#x2F; _Sheet.y);</span><br><span class="line">            return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul><li>frac函数：取小数，frac(x) = x - (int)x;</li><li>_Time获取变化时间</li><li>图片左下角为(0,0)点，因此y轴需要反转一下</li></ul><h1 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h1><h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><p>实现效果：正方向始终朝向相机<br>思路：顶点着色器变换顶点坐标，使得渲染出来的模型朝向相机</p><ol><li>将所有操作都放在模型空间，使用模型空间坐标作为锚点，则锚点为(0,0,0)</li><li>根据顶点坐标的(x,y,z)重新计算顶点坐标 pos = center + right * x + up * y + z * fwd;</li><li>需要得出right, up, fwd，fwd为朝向相机的方向，通过相机朝向可以推出，需要求right和up，<br>假设我们的广告牌正方向都朝上则up = (0, 1, 0)， right = cross(up, fwd)<br>再重新计算up = cross(fwd, right) 得到up,right,fwd， 将计算结果作为模型空间顶点坐标进行其他计算即可</li></ol><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;ADS&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BaseColor (&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        ZWrite Off</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        Cull Off</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 normalWS:TEXCOORD1; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;重新计算顶点坐标</span><br><span class="line">            float3 cameraPosOS &#x3D; TransformWorldToObject(_WorldSpaceCameraPos.xyz);</span><br><span class="line">            float3 fwd &#x3D; normalize(cameraPosOS);</span><br><span class="line">            float3 up &#x3D; abs(fwd.y) &lt; 0.99f ? float3(0, 1, 0) : float3(0, 0, 1);</span><br><span class="line">            float3 right &#x3D; normalize(cross(up, fwd));</span><br><span class="line">            up &#x3D; normalize(cross(fwd, right));</span><br><span class="line">            float3x3 Matrix &#x3D; &#123; right, up, fwd &#125;;</span><br><span class="line">            float3 posOS &#x3D; mul(i.positionOS.xyz, Matrix); &#x2F;&#x2F; &#x3D; i.positionOS.x * right + i.positionOS.y * up + i.positionOS.z * fwd</span><br><span class="line"></span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(posOS);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.normalWS &#x3D; TransformObjectToWorldNormal(i.normalOS.xyz, true); </span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            Light mylight &#x3D; GetMainLight(); </span><br><span class="line">            real4 LightColor &#x3D; real4(mylight.color, 1); </span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction);</span><br><span class="line">            float lambert &#x3D; dot(normalize(i.normalWS), lightDir);</span><br><span class="line">            float halfLambert &#x3D; lambert * 0.5f + 0.5f;</span><br><span class="line"></span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            return color * _BaseColor * halfLambert * LightColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul><li>广告牌核心思想就是做顶点变换</li><li>使用cross叉乘得垂直向量，unity中的叉乘使用左手法则</li></ul><h1 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h1><h2 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h2><ul><li><p>首先需要抓屏，Build-in中通过grab pass或者传入RT，<br>URP中_CameraColorTexture得到当前屏幕同等分辨率的图像，它在opaque模型和skybox渲染完成之后抓取<br>通过:TEXTURE2D(_CameraColorTexture);SAMPLER(sampler_CameraColorTexture);获取<br>使用_CameraColorTexture必须设置中打开Opaque Texture选项<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/01.png" alt="设置Opaque" title="设置Opaque"></p></li><li><p>采样屏幕图像需要屏幕坐标：ComputeScreenPos(positionCS);<br>i.screenPos.xy / i.screenPos.w; //获取屏幕UV，需要做齐次除法</p></li><li><p>应用法线，对采样点进行偏移，可以使用世界空间法线或者切线空间法线<br>世界空间的法线由世界空间确定，会随着模型的旋转而变化；<br>切线空间的法线不随着模型的旋转而变换；</p></li><li><p>由于_CameraColorTextrue在Opaque之后，但在Transparent之前，因此透明物体无法显示<br>因此可以利用RenderFeature，Render Objects设置一个”LightMode”=”Grab”，在透明物体之后执行的透明队列<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/02.png" alt="设置RenderFeature" title="设置RenderFeature"></p></li></ul><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Glass&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _NormalTex(&quot;Normal&quot;,2D) &#x3D; &quot;bump&quot;&#123;&#125;</span><br><span class="line">        _NormalScale(&quot;NormalScale&quot;,Range(0,1)) &#x3D; 1</span><br><span class="line">        _BaseColor(&quot;BaseColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Amount(&quot;amount&quot;,float) &#x3D; 100</span><br><span class="line">        [KeywordEnum(WS_N,TS_N)]_NORMAL_STAGE(&quot;NormalStage&quot;,float) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot; &#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_NormalTex);</span><br><span class="line">        SAMPLER(sampler_NormalTex);</span><br><span class="line">        SAMPLER(_CameraColorTexture);</span><br><span class="line">        float4 _CameraColorTexture_TexelSize;&#x2F;&#x2F;该向量是非本shader独有，不能放在常量缓冲区</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _NormalTex_ST;</span><br><span class="line">        float _NormalScale;</span><br><span class="line">        float _Amount;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float4 tangentOS:TANGENT;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float4 normalWS:TEXCOORD1;</span><br><span class="line">            float4 tangentWS:TEXCOORD2;</span><br><span class="line">            float4 BtangentWS:TEXCOORD3;</span><br><span class="line">            float4 screenPos:TEXCOORD4;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            &#x2F;&#x2F; 使用以下函数 快速获取坐标，法线变换结果 ShaderVariablesFunctions.hlsl 引用 Core.hlsl即可</span><br><span class="line">            VertexPositionInputs input &#x3D; GetVertexPositionInputs(i.positionOS.xyz);</span><br><span class="line">            o.positionHS &#x3D; input.positionCS;</span><br><span class="line"></span><br><span class="line">            VertexNormalInputs normalInput &#x3D; GetVertexNormalInputs(i.normalOS, i.tangentOS);</span><br><span class="line">            o.normalWS.xyz &#x3D; normalInput.normalWS;</span><br><span class="line">            o.tangentWS.xyz &#x3D; normalInput.tangentWS;</span><br><span class="line">            o.BtangentWS.xyz &#x3D; normalInput.bitangentWS;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 存一下世界空间坐标</span><br><span class="line">            o.tangentWS.w &#x3D; input.positionWS.x;</span><br><span class="line">            o.BtangentWS.w &#x3D; input.positionWS.y;</span><br><span class="line">            o.normalWS.w &#x3D; input.positionWS.z;</span><br><span class="line"></span><br><span class="line">            o.screenPos &#x3D; ComputeScreenPos(input.positionCS);</span><br><span class="line"></span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _NormalTex);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 norTex &#x3D; SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex, i.uv);</span><br><span class="line">            float3 normalTS &#x3D; UnpackNormalScale(norTex, _NormalScale);</span><br><span class="line">            normalTS.z &#x3D; pow(1 - pow(normalTS.x, 2) - pow(normalTS.y, 2), 0.5f);    &#x2F;&#x2F;规范化</span><br><span class="line"></span><br><span class="line">#if _NORMAL_STAGE_WS_N</span><br><span class="line">            float3 positionWS &#x3D; float3(i.tangentWS.w, i.BtangentWS.w, i.normalWS.w);</span><br><span class="line">            float3x3 T2W &#x3D; &#123; i.tangentWS.xyz, i.BtangentWS.xyz, i.normalWS.xyz &#125;;</span><br><span class="line">            float3 normalWS &#x3D; mul(normalTS, T2W);</span><br><span class="line">            float2 SS_bias &#x3D; normalWS.xy * _Amount * _CameraColorTexture_TexelSize.xy;&#x2F;&#x2F;世界空间的法线由世界空间确定，会随着模型的旋转而变化</span><br><span class="line">#else</span><br><span class="line">            float2 SS_bias &#x3D; normalTS.xy * _Amount * _CameraColorTexture_TexelSize.xy;&#x2F;&#x2F;切线空间的法线不随着模型的旋转而变换</span><br><span class="line">#endif</span><br><span class="line">            float2 SS_texcoord &#x3D; i.screenPos.xy &#x2F; i.screenPos.w;&#x2F;&#x2F;获取屏幕UV</span><br><span class="line">            float4 glassColor &#x3D; tex2D(_CameraColorTexture, SS_texcoord + SS_bias);&#x2F;&#x2F;把最终的颜色输出到屏幕即可</span><br><span class="line"></span><br><span class="line">            return glassColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;Grab&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma shader_feature_local _NORMAL_STAGE_WS_N</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用ShaderVariablesFunctions.hlsl中的通用函数：<br>GetVertexPositionInputs(positionOS)，GetVertexNormalInputs(normalOS, tangentOS)<br>快速计算法线坐标变换以及法线</p></li><li><p>_CameraColorTexture只在运行时生效</p></li><li><p>_TextureName_TexelSize：图片的宽高，这个声明在CBuffer外<br>x = 1.0/width<br>y = 1.0/height<br>z = width<br>w = height</p></li><li><p>_TextureName_ST：图片的Tilling 和 Offset<br>x,y 对应 Tilling的 x,y<br>z,w 对应 Offset的 x,y</p></li><li><p>利用RenderFeature设置特殊的渲染方式</p></li></ul><h1 id="屏幕深度，护盾特效"><a href="#屏幕深度，护盾特效" class="headerlink" title="屏幕深度，护盾特效"></a>屏幕深度，护盾特效</h1><h2 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h2><ul><li><p>获取屏幕深度图 _CameraDepthTexture;<br>TEXUTRE2D(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture);<br>通过屏幕坐标采样：ComputeScreenPos(positionCS); 别忘了使用时齐次除法，这步操作通常再原片着色器</p></li><li><p>Linear01Depth(depth, _ZBufferParams) 获取0-1线性深度</p></li><li><p>URPSetting中需要打开深度图 <img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/01.png" alt="设置Opaque" title="设置Opaque"></p></li><li><p>护盾特效：需实现菲尼尔效果，扫光效果<br>菲尼尔效果 基础公式：F0 + (1 - F0) * pow(1.0 - dot(viewDirWS, normalWS), 5.0);<br>F0为材质的菲尼尔系数<br>通用沿y轴扫光效果：float flow=saturate(pow(1-abs(frac(i.positionWS.y<em>0.3-_Time.y</em>0.2)-0.5),10)<em>0.3);<br>float4 flowcolor=flow</em>_emissioncolor;</p></li></ul><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;DepthShield&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;MainTex&quot;,2D) &#x3D; &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BaseColor(&quot;BaseColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _F0 (&quot;F0&quot;, float) &#x3D; 0.01</span><br><span class="line">        _EmissionColor (&quot;EmissionColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Speed(&quot;Speed&quot;, float) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderType&quot; &#x3D; &quot;Transparent&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot; &#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_CameraDepthTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        float4 _EmissionColor;</span><br><span class="line">        float _F0;</span><br><span class="line">        float _Speed;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float4 screenPos:TEXCOORD1;</span><br><span class="line">            float3 positionWS:TEXCOORD2;</span><br><span class="line">            float3 normalWS:TEXCOORD3;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            &#x2F;&#x2F; 使用以下函数 快速获取坐标，法线变换结果 ShaderVariablesFunctions.hlsl 引用 Core.hlsl即可</span><br><span class="line">            VertexPositionInputs input &#x3D; GetVertexPositionInputs(i.positionOS.xyz);</span><br><span class="line">            o.positionHS &#x3D; input.positionCS;</span><br><span class="line">            o.positionWS &#x3D; input.positionWS;</span><br><span class="line">            o.screenPos &#x3D; ComputeScreenPos(input.positionCS);</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            o.normalWS &#x3D; normalize(TransformObjectToWorldNormal(i.normalOS.xyz));</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 col &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _BaseColor;</span><br><span class="line">            float2 uvSS &#x3D; i.screenPos.xy &#x2F; i.screenPos.w;&#x2F;&#x2F;获取屏幕UV</span><br><span class="line">            float4 depthColor &#x3D; SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, uvSS);</span><br><span class="line">            float screenDepth &#x3D; Linear01Depth(depthColor.a, _ZBufferParams);</span><br><span class="line"></span><br><span class="line">            float depth &#x3D; i.positionHS.z;</span><br><span class="line">            depth &#x3D; Linear01Depth(depth, _ZBufferParams);&#x2F;&#x2F;得到模型的线性深度</span><br><span class="line">            float edge &#x3D; saturate(depth - screenDepth + 0.005) * 100;&#x2F;&#x2F;计算接触光</span><br><span class="line"></span><br><span class="line">            float3 viewDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - i.positionWS);</span><br><span class="line"></span><br><span class="line">            float fresnel &#x3D; _F0 + (1 - _F0) * pow(1 - dot(viewDirWS, i.normalWS), 5);</span><br><span class="line">            float flow &#x3D; saturate(pow(1 - abs(frac(i.positionWS.y * 0.3 - _Time.y * _Speed) - 0.5), 10) * 0.3);</span><br><span class="line">            float flow1 &#x3D; saturate(pow(1 - abs(frac(i.positionWS.y * 0.5 - _Time.y * _Speed) - 0.5), 10) * 0.5);</span><br><span class="line">            float flow2 &#x3D; saturate(pow(1 - abs(frac(i.positionWS.y * 0.7 - _Time.y * _Speed) - 0.5), 10) * 0.7);</span><br><span class="line">            float4 flowcolor &#x3D; (flow + flow1 + flow2) * _EmissionColor;</span><br><span class="line"></span><br><span class="line">            return float4(col.rgb, fresnel + edge) + flowcolor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><ul><li>_ZBufferParams:  UnityInput.hlsl <a href="http://www.humus.name/temp/Linearize%20depth.txt">官方链接</a><br>// x = 1-far/near<br>// y = far/near<br>// z = x/far<br>// w = y/far<br>#if UNITY_REVERSED_Z<br>// x = -1+far/near<br>// y = 1<br>// z = x/far<br>// w = 1/far</li></ul><h1 id="特定物体描边效果"><a href="#特定物体描边效果" class="headerlink" title="特定物体描边效果"></a>特定物体描边效果</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.bilibili.com/read/cv6735961?spm_id_from=333.999.0.0">urp管线的自学hlsl之路 第二十五篇 Render Feature制作特定模型外描边</a></p><h2 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h2><p>整理一下描边过程：</p><ol><li><p>获得基础纯色图：按层级/渲染队列，过滤出需要渲染的物体，返回纯色<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E6%8F%8F%E8%BE%B901.png" alt="基础纯色图" title="基础纯色图"></p></li><li><p>对纯色图进行模糊操作<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E6%8F%8F%E8%BE%B902.png" alt="纯色图模糊" title="纯色图模糊"></p></li><li><p>纯色模糊图 - 纯色图：得到外描边图<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E6%8F%8F%E8%BE%B903.png" alt="外描边图" title="外描边图"></p></li><li><p>实际上模糊图 - 纯色图，内部边缘也会有一段负数渐变区，<br>将其显示出来相当于内描边，取绝对值abs，可以得到内外描边效果图<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E6%8F%8F%E8%BE%B904.png" alt="内外描边图" title="内外描边图"></p></li><li><p>将描边图与原图叠加输出</p></li></ol><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><ol><li><p>基础纯色图：<br>绘制之前需要设置一下输出目标：ConfigureTarget(temp);<br>最终是要将物体绘制出来：context.DrawRenderers(renderingData.cullResults, ref draw, ref filter);<br>设置FilteringSettings filter = new FilteringSettings(queue, layer);<br>设置DrawingSettings draw = CreateDrawingSettings(shaderTag, ref renderingData, renderingData.cameraData.defaultOpaqueSortFlags);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个pass 绘制纯色的图像</span><br><span class="line">    class DrawSoildColorPass : ScriptableRenderPass</span><br><span class="line">    &#123;</span><br><span class="line">        Setting mysetting &#x3D; null;</span><br><span class="line">        OutlineRenderFeather SelectOutline &#x3D; null;</span><br><span class="line">        ShaderTagId shaderTag &#x3D; new ShaderTagId(&quot;DepthOnly&quot;);&#x2F;&#x2F;只有在这个标签LightMode对应的shader才会被绘制</span><br><span class="line">        FilteringSettings filter;</span><br><span class="line"></span><br><span class="line">        public DrawSoildColorPass(Setting setting, OutlineRenderFeather render)</span><br><span class="line">        &#123;</span><br><span class="line">            mysetting &#x3D; setting;</span><br><span class="line">            SelectOutline &#x3D; render;</span><br><span class="line"></span><br><span class="line">            renderPassEvent &#x3D; setting.passEvent;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;过滤设定</span><br><span class="line">            RenderQueueRange queue &#x3D; new RenderQueueRange();</span><br><span class="line">            queue.lowerBound &#x3D; Mathf.Min(setting.QueueMax, setting.QueueMin);</span><br><span class="line">            queue.upperBound &#x3D; Mathf.Max(setting.QueueMax, setting.QueueMin);</span><br><span class="line">            filter &#x3D; new FilteringSettings(queue, setting.layer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp &#x3D; Shader.PropertyToID(&quot;_MyTempColor1&quot;);</span><br><span class="line"></span><br><span class="line">            RenderTextureDescriptor desc &#x3D; cameraTextureDescriptor;</span><br><span class="line">            cmd.GetTemporaryRT(temp, desc);</span><br><span class="line">            SelectOutline.solidcolorID &#x3D; temp;</span><br><span class="line">            ConfigureTarget(temp);  &#x2F;&#x2F;设置它的输出RT</span><br><span class="line">            ConfigureClear(ClearFlag.All, Color.black);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">            mysetting.mat.SetColor(&quot;_SoildColor&quot;, mysetting.color);</span><br><span class="line">            CommandBuffer cmd &#x3D; CommandBufferPool.Get(&quot;提取固有色pass&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;绘制设定</span><br><span class="line">            var draw &#x3D; CreateDrawingSettings(shaderTag, ref renderingData, renderingData.cameraData.defaultOpaqueSortFlags);</span><br><span class="line">            draw.overrideMaterial &#x3D; mysetting.mat;</span><br><span class="line">            draw.overrideMaterialPassIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;开始绘制（准备好了绘制设定和过滤设定）</span><br><span class="line">            context.DrawRenderers(renderingData.cullResults, ref draw, ref filter);</span><br><span class="line">            context.ExecuteCommandBuffer(cmd);</span><br><span class="line">            CommandBufferPool.Release(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>获取原图<br>renderer.cameraColorTarget;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)</span><br><span class="line">&#123;</span><br><span class="line">    if(setting.mat !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        RenderTargetIdentifier sour &#x3D; renderer.cameraColorTarget;   &#x2F;&#x2F;原图</span><br><span class="line">        renderer.EnqueuePass(_DrawSoildColorPass);</span><br><span class="line">        _DrawBlurPass.Setup(sour);</span><br><span class="line">        renderer.EnqueuePass(_DrawBlurPass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模糊图<br>拿到基础纯色图，进行模糊即可，模糊操作可以参考<br><a href="https://blog.csdn.net/poem_qianmo/article/details/105350519">高品质后处理：十种图像模糊算法的总结与实现</a><br><a href="%22%22">后处理效果汇总</a></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class DrawBlurPass : ScriptableRenderPass</span><br><span class="line">    &#123;</span><br><span class="line">        Setting setting &#x3D; null;</span><br><span class="line">        OutlineRenderFeather SelectOutline &#x3D; null;</span><br><span class="line">        RenderTargetIdentifier sour;</span><br><span class="line">        BlurBlitter _blurBlitter &#x3D; new BlurBlitter();</span><br><span class="line">        public DrawBlurPass(Setting setting, OutlineRenderFeather render)</span><br><span class="line">        &#123;</span><br><span class="line">            this.setting &#x3D; setting;</span><br><span class="line">            SelectOutline &#x3D; render;</span><br><span class="line"></span><br><span class="line">            renderPassEvent &#x3D; setting.passEvent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Setup(RenderTargetIdentifier sour)</span><br><span class="line">        &#123;</span><br><span class="line">            this.sour &#x3D; sour;</span><br><span class="line"></span><br><span class="line">            if (this.setting.ColorType &#x3D;&#x3D; Setting.EColorType.INcolorON)</span><br><span class="line">            &#123;</span><br><span class="line">                this.setting.mat.EnableKeyword(&quot;_INCOLORON&quot;);</span><br><span class="line">                this.setting.mat.DisableKeyword(&quot;_INCOLOROFF&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                this.setting.mat.EnableKeyword(&quot;_INCOLOROFF&quot;);</span><br><span class="line">                this.setting.mat.DisableKeyword(&quot;_INCOLORON&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">            CommandBuffer cmd &#x3D; CommandBufferPool.Get(&quot;颜色计算&quot;);</span><br><span class="line"></span><br><span class="line">            RenderTextureDescriptor renderTextureDescriptor &#x3D; renderingData.cameraData.cameraTargetDescriptor;</span><br><span class="line"></span><br><span class="line">            int SourID &#x3D; Shader.PropertyToID(&quot;_SourTex&quot;);</span><br><span class="line">            cmd.GetTemporaryRT(SourID, renderTextureDescriptor);</span><br><span class="line">            cmd.CopyTexture(sour, SourID);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;模糊处理</span><br><span class="line">            int BlurID &#x3D; Shader.PropertyToID(&quot;_BlurTex&quot;);</span><br><span class="line">            cmd.GetTemporaryRT(BlurID, renderTextureDescriptor);</span><br><span class="line">            _blurBlitter.SetSource(BlurID, renderTextureDescriptor);</span><br><span class="line"></span><br><span class="line">            _blurBlitter.downSample &#x3D; 1;</span><br><span class="line">            _blurBlitter.blurScale &#x3D; setting.blur;</span><br><span class="line">            _blurBlitter.iteratorCount &#x3D; setting.passloop;</span><br><span class="line">            _blurBlitter.blurType &#x3D; BlurType.Box;</span><br><span class="line"></span><br><span class="line">            _blurBlitter.Render(cmd);</span><br><span class="line"></span><br><span class="line">            cmd.Blit(SelectOutline.solidcolorID, sour, setting.mat, 1);&#x2F;&#x2F;在第1个pass里合并所有图像</span><br><span class="line"></span><br><span class="line">            cmd.ReleaseTemporaryRT(SelectOutline.solidcolorID);</span><br><span class="line">            cmd.ReleaseTemporaryRT(SourID);</span><br><span class="line">            cmd.ReleaseTemporaryRT(BlurID);</span><br><span class="line">            context.ExecuteCommandBuffer(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>合并图像<br>两个Pass都比较简单，不多说明了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Outline&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _SoildColor(&quot;SoildColor&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_SourTex);</span><br><span class="line">        SAMPLER(sampler_SourTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_BlurTex);</span><br><span class="line">        SAMPLER(sampler_BlurTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _SoildColor;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Pass 0 纯色</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line"></span><br><span class="line">            Varyings Vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o;</span><br><span class="line">                o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">                o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">                return _SoildColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Pass 1 合并图像</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert1</span><br><span class="line">            #pragma fragment Frag1</span><br><span class="line">            #pragma multi_compile_local _INCOLORON _INCOLOROFF</span><br><span class="line"></span><br><span class="line">            Varyings Vert1(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o;</span><br><span class="line">                o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">                o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 Frag1(Varyings i) :SV_Target&#123;</span><br><span class="line">                float4 blur &#x3D; SAMPLE_TEXTURE2D(_BlurTex, sampler_BlurTex, i.uv);</span><br><span class="line">                float4 sour &#x3D; SAMPLE_TEXTURE2D(_SourTex, sampler_SourTex, i.uv);</span><br><span class="line">                float4 soild &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                real4 color;</span><br><span class="line">#if _INCOLORON</span><br><span class="line">                color &#x3D; abs(blur - soild) + sour;</span><br><span class="line">#elif _INCOLOROFF</span><br><span class="line">                color &#x3D; saturate(blur - soild) + sour;</span><br><span class="line">#endif</span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><ul><li>获取基础纯色图的过程，是一个基础过滤物体到渲染的过程，可以参考URP源码RenderObjectsPass.cs</li></ul><h1 id="边缘检测描边"><a href="#边缘检测描边" class="headerlink" title="边缘检测描边"></a>边缘检测描边</h1><h2 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h2><p>参考Unity Shader入门精要，12.3，13.4章节</p><ul><li>基础边缘检测</li></ul><ol><li><p>卷积：通常为2<em>2,3</em>3的方形区域，每个格子对应一个权重值，<br>采样一个像素点时，对其周围方形空间采样按权重值叠加后再除以个数得到当前像素值</p></li><li><p>常见的边缘检测算子：Roberts，Prewitt，Sobel等<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90.png" alt="常见的边缘检测算子" title="常见的边缘检测算子"></p></li><li><p>得到两个方向的梯度值，Gx，Gy<br>G = sqrt(Gx<em>Gx,Gy</em>Gy); 通常优化开方： G = abs(Gx) + abs(Gy)<br>G 值表示梯度值，梯度值越大表示越在边缘</p></li><li><p>检测结果分析<br>这种方式检测，会产生很多我们不希望的边缘线，如光照影响的，法线影响的，阴影影响的等<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E5%9F%BA%E7%A1%80%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.png" alt="基础边缘检测" title="基础边缘检测"></p></li></ol><ul><li>通过深度和深度法线上进行边缘检测</li></ul><ol><li><p>需要获取深度图，以及深度法线图，通过_CameraDepthTexture可以获得深度图，但是URP不支持深度法线图<br>因此需要获得深度法线图：自定义RenderFeather，在不透明物体渲染之前使用”Hidden/Internal-DepthNormalsTexture”渲染一次，将图片存为”_CameraDepthNormalsTexture”</p></li><li><p>_CameraDepthNormalsTexture.xyz存法线信息，_CameraDepthNormalsTexture.w存深度信息，<br>UnityCG.cginc中定义： DecodeFloatRG 解码深度：线性深度 = z + w/255<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%9B%B8%E6%9C%BA%E6%B7%B1%E5%BA%A6%E6%B3%95%E7%BA%BF01.png" alt="DecodeFloatRG" title="DecodeFloatRG"></p></li><li><p>_CameraDepthNormalsTexutre.xyz法线信息并非真实法线，需要对其进行解码操作获得观察空间法线<br>UnityCG.cginc中定义：DecodeViewNormalStereo<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%9B%B8%E6%9C%BA%E6%B7%B1%E5%BA%A6%E6%B3%95%E7%BA%BF02.png" alt="DecodeViewNormalStereo" title="DecodeViewNormalStereo"></p></li><li><p>镜像对比方式：如像素(x,y+1)与(x,y-1),(x+1,y)与(x-1,y)<br>比较法线以及深度是否相同，相同返回1，不同返回0，代码里对应CheckSame函数，小于一定范围则视为相同</p></li><li><p>检测结果分析<br>可以明显看到这种方式比第一种方式减少了很多不必要的边缘线<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E6%B7%B1%E5%BA%A6%E6%B3%95%E7%BA%BF%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.png" alt="深度法线边缘检测" title="深度法线边缘检测"></p></li></ol><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><ul><li><p>基础边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;OutlinePPS&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeColor (&quot;EdgeColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _EdgeOnly (&quot;EdgeOnly&quot;,Range(0,1)) &#x3D; 1</span><br><span class="line">        _BackgroundColor (&quot;BackgroundColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _MainTex_TexelSize;</span><br><span class="line"></span><br><span class="line">        float4 _EdgeColor;</span><br><span class="line">        float4 _BackgroundColor;</span><br><span class="line">        float _EdgeOnly;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv[9]         : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 3*3区域uv</span><br><span class="line">            o.uv[0] &#x3D; i.uv + _MainTex_TexelSize.xy * (-1, -1);</span><br><span class="line">            o.uv[1] &#x3D; i.uv + _MainTex_TexelSize.xy * (0, -1);</span><br><span class="line">            o.uv[2] &#x3D; i.uv + _MainTex_TexelSize.xy * (1, -1);</span><br><span class="line">            o.uv[3] &#x3D; i.uv + _MainTex_TexelSize.xy * (-1, 0);</span><br><span class="line">            o.uv[4] &#x3D; i.uv + _MainTex_TexelSize.xy * (0, 0);</span><br><span class="line">            o.uv[5] &#x3D; i.uv + _MainTex_TexelSize.xy * (1, 0);</span><br><span class="line">            o.uv[6] &#x3D; i.uv + _MainTex_TexelSize.xy * (-1, 1);</span><br><span class="line">            o.uv[7] &#x3D; i.uv + _MainTex_TexelSize.xy * (0, 1);</span><br><span class="line">            o.uv[8] &#x3D; i.uv + _MainTex_TexelSize.xy * (1, 1);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float luminance(float3 color)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0.2125*color.r + 0.7154*color.g + 0.0721*color.b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 主要用于描边检测</span><br><span class="line">        float sobel(Varyings i)&#x2F;&#x2F;定义索伯检测函数</span><br><span class="line">        &#123;</span><br><span class="line">            const float Gx[9] &#x3D; &#123; -1,-2,-1,0,0,0,1,2,1 &#125;;</span><br><span class="line">            const float Gy[9] &#x3D; &#123; -1,0,1,-2,0,2,-1,0,1 &#125;;</span><br><span class="line"></span><br><span class="line">            float texColor &#x3D; 0;</span><br><span class="line">            float edgeX &#x3D; 0;</span><br><span class="line">            float edgeY &#x3D; 0;</span><br><span class="line">            for (int it &#x3D; 0; it &lt; 9; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                texColor &#x3D; luminance(SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv[it]));</span><br><span class="line">                edgeX +&#x3D; texColor * Gx[it];</span><br><span class="line">                edgeY +&#x3D; texColor * Gy[it];</span><br><span class="line">            &#125;</span><br><span class="line">            return 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line"></span><br><span class="line">            float edge &#x3D; sobel(i);</span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv[4]);</span><br><span class="line"></span><br><span class="line">            float4 color1 &#x3D; lerp(_EdgeColor, color, edge);</span><br><span class="line">            float4 color2 &#x3D; lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            return lerp(color1, color2, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过深度和深度法线边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;OutlinePPSDepth&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeColor (&quot;EdgeColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _EdgeOnly (&quot;EdgeOnly&quot;,Range(0,1)) &#x3D; 1</span><br><span class="line">        _BackgroundColor (&quot;BackgroundColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _SampleDistance(&quot;SampleDistance&quot;,Range(0,1)) &#x3D; 1</span><br><span class="line">        _SensitivityDepth (&quot;SensitivityDepth&quot;,Range(0,3)) &#x3D; 1</span><br><span class="line">        _SensitivityNormals (&quot;SensitivityNormals&quot;,Range(0,3)) &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_CameraDepthNormalsTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthNormalsTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _MainTex_TexelSize;</span><br><span class="line"></span><br><span class="line">        float4 _EdgeColor;</span><br><span class="line">        float4 _BackgroundColor;</span><br><span class="line">        float _EdgeOnly;</span><br><span class="line">        float _SampleDistance;</span><br><span class="line">        float _SensitivityDepth;</span><br><span class="line">        float _SensitivityNormals;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv         : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; i.uv;</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float CheckSame(float2 centerNormal, float centerDepth, float2 sampleNormal, float sampleDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            float2 diffNormal &#x3D; abs(centerNormal - sampleNormal) * _SensitivityNormals;</span><br><span class="line">            float diffDepth &#x3D; abs(centerDepth - sampleDepth) * _SensitivityDepth;</span><br><span class="line"></span><br><span class="line">            int isSameNormal &#x3D; (diffNormal.x + diffNormal.y) &lt; 0.1f;</span><br><span class="line">            int isSameDepth &#x3D; diffDepth &lt; 0.1 * centerNormal;</span><br><span class="line">            return isSameNormal * isSameDepth ? 1.0 : 0.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float DecodeFloatRG(float2 enc)</span><br><span class="line">        &#123;</span><br><span class="line">            float2 kDecodeDot &#x3D; float2(1.0, 1 &#x2F; 255.0);</span><br><span class="line">            return dot(enc, kDecodeDot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float3 DecodeViewNormalStereo(float4 enc4)</span><br><span class="line">        &#123;</span><br><span class="line">            float kScale &#x3D; 1.7777;</span><br><span class="line">            float3 nn &#x3D; enc4.xyz * float3(2 * kScale, 2 * kScale, 0) + float3(-kScale, -kScale, 1);</span><br><span class="line">            float g &#x3D; 2.0 &#x2F; dot(nn.xyz, nn.xyz);</span><br><span class="line">            float3 n;</span><br><span class="line">            n.xy &#x3D; g * nn.xy;</span><br><span class="line">            n.z &#x3D; g - 1;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float sobel(Varyings i)</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv[9];</span><br><span class="line">            float2 normal[9];</span><br><span class="line">            float depth[9];</span><br><span class="line"></span><br><span class="line">            uv[0] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (-1, -1);</span><br><span class="line">            uv[1] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (0, -1);</span><br><span class="line">            uv[2] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (1, -1);</span><br><span class="line">            uv[3] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (-1, 0);</span><br><span class="line">            uv[4] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (0, 0);</span><br><span class="line">            uv[5] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (1, 0);</span><br><span class="line">            uv[6] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (-1, 1);</span><br><span class="line">            uv[7] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (0, 1);</span><br><span class="line">            uv[8] &#x3D; i.uv + _SampleDistance * _MainTex_TexelSize.xy * (1, 1);</span><br><span class="line"></span><br><span class="line">            for (int it &#x3D; 0; it &lt; 9; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                real4 depthnormalTex &#x3D; SAMPLE_TEXTURE2D(_CameraDepthNormalsTexture, sampler_CameraDepthNormalsTexture, uv[it]);</span><br><span class="line">                normal[it] &#x3D; depthnormalTex.xy; &#x2F;&#x2F;临时法线  没使用DecodeViewNormalStereo，使用后有问题...</span><br><span class="line">                depth[it] &#x3D; DecodeFloatRG(depthnormalTex.zw); &#x2F;&#x2F; depthnormalTex.z * 1.0 + depthnormalTex.w &#x2F; 255.0; &#x2F;&#x2F;得到线性深度</span><br><span class="line">            &#125;</span><br><span class="line">            float edge &#x3D; 1;</span><br><span class="line">           </span><br><span class="line">            edge *&#x3D; CheckSame(normal[0], depth[0], normal[8], depth[8]);</span><br><span class="line">            edge *&#x3D; CheckSame(normal[1], depth[1], normal[7], depth[7]);</span><br><span class="line">            edge *&#x3D; CheckSame(normal[2], depth[2], normal[6], depth[6]);</span><br><span class="line">            edge *&#x3D; CheckSame(normal[3], depth[3], normal[5], depth[5]);</span><br><span class="line"></span><br><span class="line">            return edge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line"></span><br><span class="line">            float edge &#x3D; sobel(i);</span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">            float4 mainColor &#x3D; lerp(_EdgeColor, color, edge);</span><br><span class="line">            float4 noMainColor &#x3D; lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            return lerp(mainColor, noMainColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>深度法线RenderFeather</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取深度法线</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class DepthNormalsRenderFeather : ScriptableRendererFeature</span><br><span class="line">&#123;</span><br><span class="line">    class DepthNormalsRenderPass : ScriptableRenderPass</span><br><span class="line">    &#123;</span><br><span class="line">        private RenderTargetHandle destination &#123; get; set; &#125;</span><br><span class="line">        private Material depthNormalsMaterial &#x3D; null;</span><br><span class="line">        private FilteringSettings m_FilteringSettings;</span><br><span class="line">        ShaderTagId m_ShaderTagId &#x3D; new ShaderTagId(&quot;DepthOnly&quot;);</span><br><span class="line"></span><br><span class="line">        public DepthNormalsRenderPass(RenderQueueRange renderQueueRange, LayerMask layerMask, Material material)</span><br><span class="line">        &#123;</span><br><span class="line">            m_FilteringSettings &#x3D; new FilteringSettings(renderQueueRange, layerMask);</span><br><span class="line">            this.depthNormalsMaterial &#x3D; material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Setup(RenderTargetHandle destination)</span><br><span class="line">        &#123;</span><br><span class="line">            this.destination &#x3D; destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)</span><br><span class="line">        &#123;</span><br><span class="line">            RenderTextureDescriptor descriptor &#x3D; cameraTextureDescriptor;</span><br><span class="line">            descriptor.depthBufferBits &#x3D; 32;</span><br><span class="line">            descriptor.colorFormat &#x3D; RenderTextureFormat.ARGB32;</span><br><span class="line"></span><br><span class="line">            cmd.GetTemporaryRT(destination.id, descriptor, FilterMode.Point);</span><br><span class="line">            ConfigureTarget(destination.Identifier());</span><br><span class="line">            ConfigureClear(ClearFlag.All, Color.black);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Here you can implement the rendering logic.</span><br><span class="line">        &#x2F;&#x2F; Use &lt;c&gt;ScriptableRenderContext&lt;&#x2F;c&gt; to issue drawing commands or execute command buffers</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;docs.unity3d.com&#x2F;ScriptReference&#x2F;Rendering.ScriptableRenderContext.html</span><br><span class="line">        &#x2F;&#x2F; You don&#39;t have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.</span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">            CommandBuffer cmd &#x3D; CommandBufferPool.Get(&quot;深度法线获取pass&quot;);</span><br><span class="line">            using (new ProfilingSample(cmd, &quot;DepthNormals Prepass&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                context.ExecuteCommandBuffer(cmd);</span><br><span class="line">                cmd.Clear();</span><br><span class="line">                var sortFlags &#x3D; renderingData.cameraData.defaultOpaqueSortFlags;</span><br><span class="line">                var drawSettings &#x3D; CreateDrawingSettings(m_ShaderTagId, ref renderingData, sortFlags);</span><br><span class="line">                drawSettings.perObjectData &#x3D; PerObjectData.None;</span><br><span class="line"></span><br><span class="line">                ref CameraData cameraData &#x3D; ref renderingData.cameraData;</span><br><span class="line">                Camera camera &#x3D; cameraData.camera;</span><br><span class="line">                if (cameraData.isStereoEnabled)</span><br><span class="line">                    context.StartMultiEye(camera);</span><br><span class="line"></span><br><span class="line">                drawSettings.overrideMaterial &#x3D; depthNormalsMaterial;</span><br><span class="line"></span><br><span class="line">                context.DrawRenderers(renderingData.cullResults, ref drawSettings,</span><br><span class="line">                  ref m_FilteringSettings);</span><br><span class="line"></span><br><span class="line">                cmd.SetGlobalTexture(&quot;_CameraDepthNormalsTexture&quot;, destination.id);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            context.ExecuteCommandBuffer(cmd);</span><br><span class="line">            CommandBufferPool.Release(cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cleanup any allocated resources that were created during the execution of this render pass.</span><br><span class="line">        public override void OnCameraCleanup(CommandBuffer cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            if (destination !&#x3D; RenderTargetHandle.CameraTarget)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.ReleaseTemporaryRT(destination.id);</span><br><span class="line">                destination &#x3D; RenderTargetHandle.CameraTarget;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DepthNormalsRenderPass m_ScriptablePass;</span><br><span class="line">    RenderTargetHandle depthNormalsTexture;</span><br><span class="line">    Material depthNormalsMaterial;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;inheritdoc&#x2F;&gt;</span><br><span class="line">    public override void Create()</span><br><span class="line">    &#123;</span><br><span class="line">        depthNormalsMaterial &#x3D; CoreUtils.CreateEngineMaterial(&quot;Hidden&#x2F;Internal-DepthNormalsTexture&quot;);</span><br><span class="line">        m_ScriptablePass &#x3D; new DepthNormalsRenderPass(RenderQueueRange.opaque, -1, depthNormalsMaterial);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Configures where the render pass should be injected.</span><br><span class="line">        m_ScriptablePass.renderPassEvent &#x3D; RenderPassEvent.AfterRenderingPrePasses;</span><br><span class="line">        depthNormalsTexture.Init(&quot;_CameraDepthNormalsTexture&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Here you can inject one or multiple render passes in the renderer.</span><br><span class="line">    &#x2F;&#x2F; This method is called when setting up the renderer once per-camera.</span><br><span class="line">    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ScriptablePass.Setup(depthNormalsTexture);</span><br><span class="line">        renderer.EnqueuePass(m_ScriptablePass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><ul><li>URP并不支持深度法线图，通过RenderFeather自己生成一张并设置为全局变量</li><li>代码中并没有使用DecodeViewNormalStereo函数，在测试过程中使用DecodeViewNormalStereo解码，实际效果不知道为什么出现问题(待解决)<br>但是可以直接使用为解码的法线xy，因为计算过程xy与解码后成正比，不影响实际结果</li></ul><h1 id="科幻扫描效果"><a href="#科幻扫描效果" class="headerlink" title="科幻扫描效果"></a>科幻扫描效果</h1><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.bilibili.com/read/cv6658281?spm_id_from=333.999.0.0">urp管线的自学hlsl之路 第二十三篇 科幻扫描效果前篇</a><br><a href="https://www.bilibili.com/read/cv6672641?spm_id_from=333.999.0.0">urp管线的自学hlsl之路 第二十四篇 科幻扫描效果后篇</a></p><h2 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h2><ol><li><p>首先要知道这是一个后处理，我们要做的是在屏幕上画线，再附加扫描<br>再屏幕上画线条需要区分可画区域与不可画区域，通过深度图来区分，只有有深度的地方才需要画线<br>画线需要与世界坐标系的x，y，z轴对应，目前我们不知道屏幕图像上的一点在世界坐标系的位置，<br>因此第一步需要计算屏幕像素点在世界坐标的实际位置，即重建世界坐标系。</p></li><li><p>世界坐标通过深度值，相机世界坐标以及一个朝向确定： positionWS = _WorldSpaceCameraPos + depth * Direction;  求：Direction<br>这个过程相当于NDC反运算，通过near，far，fov计算 相机到近平面四个顶点的向量<br>计算过程：height = near * tan(fov / 2);<br>width = height * camera.aspect;     //aspect为屏幕高宽比<br>fwd = camera.fwd * near;<br>right = camera.right * width;<br>up = camera.up * height;<br>四个向量为：<br>BottomLeft = fwd - right - up;<br>BottomRight = fwd + right - up;<br>UpLeft = fwd - right + up;<br>UpRight = fwd + right + up;<br>将结果线性变换：<br>float size = BottomLeft.magnitude / near;<br>BottomLeft = BottomLeft.normalize * size;<br>BottomRight = BottomRight.normalize * size;<br>UpLeft = UpLeft.normalize * size;<br>UpRight = UpRight.normalize * size;<br>将结果通过RenderFeature传入材质中。</p></li><li><p>基于x,y,z轴画线：</p></li></ol><ul><li>uv从左下角(0,0)到右上角(1,1)，将屏幕划分为四个区域，分别取上面以及计算好的向量<br>这时候将渲染屏幕大小的片，其对应有四个顶点，按照uv划分设置朝向，<br>在片元着色器中，每个像素得到的朝向是经过四个顶点朝向插值完的结果，因此得到相机到像素世界坐标的朝向以及长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int t &#x3D; 0;</span><br><span class="line">if (i.uv.x &lt; 0.5 &amp;&amp; i.uv.y &lt; 0.5)   &#x2F;&#x2F; 左下</span><br><span class="line">    t &#x3D; 0;</span><br><span class="line">else if (i.uv.x &gt; 0.5 &amp;&amp; i.uv.y &lt; 0.5)  &#x2F;&#x2F; 右下</span><br><span class="line">    t &#x3D; 1;</span><br><span class="line">else if (i.uv.x &gt; 0.5 &amp;&amp; i.uv.y &gt; 0.5)  &#x2F;&#x2F; 左上</span><br><span class="line">    t &#x3D; 2; </span><br><span class="line">else    &#x2F;&#x2F; 右上</span><br><span class="line">    t &#x3D; 3;</span><br><span class="line">o.Direction &#x3D; _Matrix[t].xyz;</span><br></pre></td></tr></table></figure></li><li>通过上面的分析得到向量后，能直接得到positionWS = _WorldSpaceCameraPos + depth * Direction + float3(0.01,0.01,0.01); //增加一点偏移是画出线显示在实际物体上面<br>输出positionWS查看效果：重新构建的世界坐标系将屏幕划分成四块<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%A7%91%E6%8A%80%E6%89%AB%E6%8F%8F01.png" alt="positionWS效果" title="positionWS效果"><br>将positionWS取frac，0-1：变成条状了<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%A7%91%E6%8A%80%E6%89%AB%E6%8F%8F02.png" alt="frac效果" title="frac效果"><br>使用step裁剪掉大部分0.98：最后就变成了线，可以看到3种类型线，分别对应x，y，z轴<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%A7%91%E6%8A%80%E6%89%AB%E6%8F%8F03.png" alt="step + frac效果" title="step + frac效果"><br>赋予颜色：线条变得更加明显了，这些线就代表世界坐标重构之后的x，y，z轴，其对应间隔为1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 Line &#x3D; step(0.98, frac(positionWS));</span><br><span class="line">float3 LineColor &#x3D; Line.x * _ColorX + Line.y * _ColorY + Line.z * _ColorZ;</span><br></pre></td></tr></table></figure><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E7%A7%91%E6%8A%80%E6%89%AB%E6%8F%8F04.png" alt="赋予颜色" title="赋予颜色"></li></ul><ol start="4"><li><p>描边：通过上面学习的基于屏幕深度，深度法线做描边检测即可</p></li><li><p>扫描效果：类似上面做过的护盾扫描效果<br>float flow=saturate(pow(1-abs(frac(i.positionWS.y<em>0.3-_Time.y</em>0.2)-0.5),10)<em>0.3);<br>对其魔改一下，原来的效果为，0-1-0的渐变，扫描时我们通常使用1-0渐变，因此舍弃一部分渐变：<br>float mask=saturate(pow(abs(frac(positionWS.x + _Time.y</em>0.2)-0.75),10)*0.3);</p></li></ol><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><ul><li><p>RenderFeature</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 科幻扫描效果</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class ScanRenderFeather : ScriptableRendererFeature</span><br><span class="line">&#123;</span><br><span class="line">    class ScanRenderPass : ScriptableRenderPass</span><br><span class="line">    &#123;</span><br><span class="line">        private Setting setting;</span><br><span class="line">        private RenderTargetIdentifier source;</span><br><span class="line">        private Material mat;</span><br><span class="line"></span><br><span class="line">        public void Setup(Setting setting)</span><br><span class="line">        &#123;</span><br><span class="line">            this.setting &#x3D; setting;</span><br><span class="line"></span><br><span class="line">            mat &#x3D; new Material(setting.shader);</span><br><span class="line">            renderPassEvent &#x3D; setting.Event;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Set(RenderTargetIdentifier source)</span><br><span class="line">        &#123;</span><br><span class="line">            this.source &#x3D; source;</span><br><span class="line">            mat.SetColor(&quot;_ColorX&quot;, setting.ColorX);</span><br><span class="line">            mat.SetColor(&quot;_ColorY&quot;, setting.ColorY);</span><br><span class="line">            mat.SetColor(&quot;_ColorZ&quot;, setting.ColorZ);</span><br><span class="line">            mat.SetColor(&quot;_ColorEdge&quot;, setting.ColorEdge);</span><br><span class="line">            mat.SetColor(&quot;_OutlineColor&quot;, setting.ColorOutline);</span><br><span class="line">            mat.SetFloat(&quot;_Width&quot;, setting.Width);</span><br><span class="line">            mat.SetFloat(&quot;_Spacing&quot;, setting.Spacing);</span><br><span class="line">            mat.SetFloat(&quot;_Speed&quot;, setting.Speed);</span><br><span class="line">            mat.SetFloat(&quot;_EdgeSample&quot;, setting.EdgeSample);</span><br><span class="line">            mat.SetFloat(&quot;_NormalSensitivity&quot;, setting.NormalSensitivity);</span><br><span class="line">            mat.SetFloat(&quot;_DepthSensitivity&quot;, setting.DepthSensitivity);</span><br><span class="line"></span><br><span class="line">            if (setting.AXIS &#x3D;&#x3D; AxisType.X)</span><br><span class="line">            &#123;</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_Y&quot;);</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_Z&quot;);</span><br><span class="line">                mat.EnableKeyword(&quot;_AXIS_X&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (setting.AXIS &#x3D;&#x3D; AxisType.Y)</span><br><span class="line">            &#123;</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_Z&quot;);</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_X&quot;);</span><br><span class="line">                mat.EnableKeyword(&quot;_AXIS_Y&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_X&quot;);</span><br><span class="line">                mat.DisableKeyword(&quot;_AXIS_Y&quot;);</span><br><span class="line">                mat.EnableKeyword(&quot;_AXIS_Z&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This method is called before executing the render pass.</span><br><span class="line">        &#x2F;&#x2F; It can be used to configure render targets and their clear state. Also to create temporary render target textures.</span><br><span class="line">        &#x2F;&#x2F; When empty this render pass will render to the active camera render target.</span><br><span class="line">        &#x2F;&#x2F; You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;&#x2F;c&gt; and &lt;c&gt;ConfigureClear&lt;&#x2F;c&gt;.</span><br><span class="line">        &#x2F;&#x2F; The render pipeline will ensure target setup and clearing happens in a performant manner.</span><br><span class="line">        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Here you can implement the rendering logic.</span><br><span class="line">        &#x2F;&#x2F; Use &lt;c&gt;ScriptableRenderContext&lt;&#x2F;c&gt; to issue drawing commands or execute command buffers</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;docs.unity3d.com&#x2F;ScriptReference&#x2F;Rendering.ScriptableRenderContext.html</span><br><span class="line">        &#x2F;&#x2F; You don&#39;t have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.</span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp &#x3D; Shader.PropertyToID(&quot;temp&quot;);</span><br><span class="line">            CommandBuffer cmd &#x3D; CommandBufferPool.Get(&quot;扫描特效&quot;);</span><br><span class="line">            RenderTextureDescriptor desc &#x3D; renderingData.cameraData.cameraTargetDescriptor;</span><br><span class="line"></span><br><span class="line">            Camera cam &#x3D; renderingData.cameraData.camera;</span><br><span class="line">            float height &#x3D; cam.nearClipPlane * Mathf.Tan(Mathf.Deg2Rad * cam.fieldOfView * 0.5f);</span><br><span class="line">            Vector3 up &#x3D; cam.transform.up * height;</span><br><span class="line">            Vector3 right &#x3D; cam.transform.right * height * cam.aspect;</span><br><span class="line">            Vector3 forward &#x3D; cam.transform.forward * cam.nearClipPlane;</span><br><span class="line"></span><br><span class="line">            Vector3 ButtomLeft &#x3D; forward - right - up;</span><br><span class="line">            Vector3 ButtomRight &#x3D; forward + right - up;</span><br><span class="line">            Vector3 TopRight &#x3D; forward + right + up;</span><br><span class="line">            Vector3 TopLeft &#x3D; forward - right + up;</span><br><span class="line"></span><br><span class="line">            float scale &#x3D; ButtomLeft.magnitude &#x2F; cam.nearClipPlane;</span><br><span class="line">            ButtomLeft &#x3D; ButtomLeft.normalized * scale;</span><br><span class="line">            ButtomRight &#x3D; ButtomRight.normalized * scale;</span><br><span class="line">            TopRight &#x3D; TopRight.normalized * scale;</span><br><span class="line">            TopLeft &#x3D; TopLeft.normalized * scale;</span><br><span class="line"></span><br><span class="line">            Matrix4x4 MATRIX &#x3D; new Matrix4x4();</span><br><span class="line">            MATRIX.SetRow(0, ButtomLeft);</span><br><span class="line">            MATRIX.SetRow(1, ButtomRight);</span><br><span class="line">            MATRIX.SetRow(2, TopRight);</span><br><span class="line">            MATRIX.SetRow(3, TopLeft);</span><br><span class="line">            mat.SetMatrix(&quot;_Matrix&quot;, MATRIX);</span><br><span class="line"></span><br><span class="line">            cmd.GetTemporaryRT(temp, desc);</span><br><span class="line">            cmd.Blit(source, temp, mat);</span><br><span class="line">            cmd.Blit(temp, source);</span><br><span class="line">            context.ExecuteCommandBuffer(cmd);</span><br><span class="line">            cmd.ReleaseTemporaryRT(temp);</span><br><span class="line"></span><br><span class="line">            CommandBufferPool.Release(cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cleanup any allocated resources that were created during the execution of this render pass.</span><br><span class="line">        public override void OnCameraCleanup(CommandBuffer cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScanRenderPass m_ScriptablePass;</span><br><span class="line"></span><br><span class="line">    public enum AxisType</span><br><span class="line">    &#123;</span><br><span class="line">        X,</span><br><span class="line">        Y,</span><br><span class="line">        Z</span><br><span class="line">    &#125;</span><br><span class="line">    [System.Serializable]</span><br><span class="line">    public class Setting</span><br><span class="line">    &#123;</span><br><span class="line">        public Shader shader &#x3D; null;</span><br><span class="line">        public RenderPassEvent Event &#x3D; RenderPassEvent.AfterRenderingTransparents;</span><br><span class="line">        [ColorUsage(true, true)] public Color ColorX &#x3D; Color.white;</span><br><span class="line">        [ColorUsage(true, true)] public Color ColorY &#x3D; Color.white;</span><br><span class="line">        [ColorUsage(true, true)] public Color ColorZ &#x3D; Color.white;</span><br><span class="line">        [ColorUsage(true, true)] public Color ColorEdge &#x3D; Color.white;</span><br><span class="line">        [ColorUsage(true, true)] public Color ColorOutline &#x3D; Color.white;</span><br><span class="line">        [Range(0, 0.2f), Tooltip(&quot;线框宽度&quot;)] public float Width &#x3D; 0.1f;</span><br><span class="line">        [Range(0.1f, 10), Tooltip(&quot;线框间距&quot;)] public float Spacing &#x3D; 1;</span><br><span class="line">        [Range(0, 10), Tooltip(&quot;滚动速度&quot;)] public float Speed &#x3D; 1;</span><br><span class="line">        [Range(0, 3), Tooltip(&quot;边缘采样半径&quot;)] public float EdgeSample &#x3D; 1;</span><br><span class="line">        [Range(0, 3), Tooltip(&quot;法线灵敏度&quot;)] public float NormalSensitivity &#x3D; 1;</span><br><span class="line">        [Range(0, 3), Tooltip(&quot;深度灵敏度&quot;)] public float DepthSensitivity &#x3D; 1;</span><br><span class="line">        [Tooltip(&quot;特效方向&quot;)] public AxisType AXIS;</span><br><span class="line">    &#125;</span><br><span class="line">    [SerializeField]</span><br><span class="line">    public Setting setting;</span><br><span class="line"></span><br><span class="line">    public override void Create()</span><br><span class="line">    &#123;</span><br><span class="line">        m_ScriptablePass &#x3D; new ScanRenderPass();</span><br><span class="line">        m_ScriptablePass.Setup(setting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ScriptablePass.Set(renderer.cameraColorTarget);</span><br><span class="line">        renderer.EnqueuePass(m_ScriptablePass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Shader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Scan&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [HideInInspector] _MainTex(&quot;MainTex&quot;,2D) &#x3D; &quot;white&quot;&#123;&#125;</span><br><span class="line">        [HDR]_ColorX(&quot;ColorX&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        [HDR]_ColorY(&quot;ColorY&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        [HDR]_ColorZ(&quot;ColorZ&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        [HDR]_ColorEdge(&quot;ColorEdge&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Width(&quot;Width&quot;,float) &#x3D; 0.02</span><br><span class="line">        _Spacing(&quot;Spacing&quot;,float) &#x3D; 1</span><br><span class="line">        _Speed(&quot;Speed&quot;,float) &#x3D; 1</span><br><span class="line">        _EdgeSample(&quot;EdgeSample&quot;,Range(0,1)) &#x3D; 1</span><br><span class="line">        _NormalSensitivity(&quot;NormalSensitivity&quot;,float) &#x3D; 1</span><br><span class="line">        _DepthSensitivity(&quot;DepthSensitivity&quot;,float) &#x3D; 1</span><br><span class="line">        [HDR]_OutlineColor(&quot;OutlineColr&quot;,Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用_CameraDepthNormalsTexture取代深度图</span><br><span class="line">        &#x2F;&#x2F; _CameraDepthNormalsTexture.xy法线信息，zw存深度信息，线性深度&#x3D;z+w&#x2F;255</span><br><span class="line">        TEXTURE2D(_CameraDepthTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_CameraDepthNormalsTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthNormalsTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _MainTex_TexelSize;</span><br><span class="line">        real4 _ColorX;</span><br><span class="line">        real4 _ColorY;</span><br><span class="line">        real4 _ColorZ;</span><br><span class="line">        real4 _ColorEdge;</span><br><span class="line">        real4 _OutlineColor;</span><br><span class="line">        float _Width;</span><br><span class="line">        float _Spacing;</span><br><span class="line">        float _Speed;</span><br><span class="line">        float _EdgeSample;</span><br><span class="line">        float _NormalSensitivity;</span><br><span class="line">        float _DepthSensitivity;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        float4x4 _Matrix;</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float3 Direction:TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line">            o.uv &#x3D; i.uv;</span><br><span class="line">            int t &#x3D; 0;</span><br><span class="line">            if (i.uv.x &lt; 0.5 &amp;&amp; i.uv.y &lt; 0.5)</span><br><span class="line">                t &#x3D; 0;</span><br><span class="line">            else if (i.uv.x &gt; 0.5 &amp;&amp; i.uv.y &lt; 0.5)</span><br><span class="line">                t &#x3D; 1;</span><br><span class="line">            else if (i.uv.x &gt; 0.5 &amp;&amp; i.uv.y &gt; 0.5)</span><br><span class="line">                t &#x3D; 2;</span><br><span class="line">            else</span><br><span class="line">                t &#x3D; 3;</span><br><span class="line">            o.Direction &#x3D; _Matrix[t].xyz;</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 主要用于描边检测</span><br><span class="line">        int sobel(Varyings i)&#x2F;&#x2F;定义索伯检测函数</span><br><span class="line">        &#123;</span><br><span class="line">            real depth[4];</span><br><span class="line">            real2 normal[4];</span><br><span class="line">            float2 uv[4];&#x2F;&#x2F;计算采样需要的uv</span><br><span class="line"></span><br><span class="line">            uv[0] &#x3D; i.uv + float2(-1, -1) * _EdgeSample * _MainTex_TexelSize.xy;</span><br><span class="line">            uv[1] &#x3D; i.uv + float2(1, -1) * _EdgeSample * _MainTex_TexelSize.xy;</span><br><span class="line">            uv[2] &#x3D; i.uv + float2(-1, 1) * _EdgeSample * _MainTex_TexelSize.xy;</span><br><span class="line">            uv[3] &#x3D; i.uv + float2(1, 1) * _EdgeSample * _MainTex_TexelSize.xy;</span><br><span class="line">            for (int t &#x3D; 0; t &lt; 4; t++)</span><br><span class="line">            &#123;</span><br><span class="line">                real4 depthnormalTex &#x3D; SAMPLE_TEXTURE2D(_CameraDepthNormalsTexture, sampler_CameraDepthNormalsTexture, uv[t]);</span><br><span class="line">                normal[t] &#x3D; depthnormalTex.xy;&#x2F;&#x2F;得到临时法线</span><br><span class="line">                depth[t] &#x3D; depthnormalTex.z * 1.0 + depthnormalTex.w &#x2F; 255.0;&#x2F;&#x2F;得到线性深度</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;depth检测</span><br><span class="line">            int Dep &#x3D; abs(depth[0] - depth[3]) * abs(depth[1] - depth[2]) * _DepthSensitivity &gt; 0.01 ? 1 : 0;</span><br><span class="line">            &#x2F;&#x2F;normal检测</span><br><span class="line">            float2 nor &#x3D; abs(normal[0] - normal[3]) * abs(normal[1] - normal[2]) * _NormalSensitivity;</span><br><span class="line">            int Nor &#x3D; (nor.x + nor.y) &gt; 0.01 ? 1 : 0;</span><br><span class="line">            return saturate(Dep + Nor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            int outline &#x3D; sobel(i);</span><br><span class="line"></span><br><span class="line">            real4 tex &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            real4 depthnormal &#x3D; SAMPLE_TEXTURE2D(_CameraDepthNormalsTexture, sampler_CameraDepthNormalsTexture, i.uv);</span><br><span class="line">            float depth01 &#x3D; depthnormal.z * 1.0 + depthnormal.w &#x2F; 255.0;</span><br><span class="line">            depth01 *&#x3D; _ProjectionParams.z;</span><br><span class="line">            &#x2F;&#x2F;float depth01 &#x3D; LinearEyeDepth(SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv).x, _ZBufferParams).x;</span><br><span class="line">            float3 positionWS &#x3D; _WorldSpaceCameraPos + depth01 * i.Direction + float3(0.01, 0.01, 0.01);    &#x2F;&#x2F;增加一点偏移是画出线显示在实际物体上面</span><br><span class="line">            float3 positionWS01 &#x3D; positionWS * _ZBufferParams.w;</span><br><span class="line">            float3 Line &#x3D; step(1 - _Width, frac(positionWS &#x2F; _Spacing));</span><br><span class="line">            float4 LineColor &#x3D; Line.x * _ColorX + Line.y * _ColorY + Line.z * _ColorZ + outline * _OutlineColor;</span><br><span class="line"></span><br><span class="line">#ifdef _AXIS_X</span><br><span class="line">            float mask &#x3D; saturate(pow(abs(frac(positionWS01.x * 10 + _Time.y * 0.1 * _Speed) - 0.53), 10) * 200);</span><br><span class="line">            float mask2 &#x3D; saturate(pow(abs(frac(positionWS01.x * 10 - _Time.y * 0.1 * _Speed) - 0.47), 10) * 200);</span><br><span class="line">            float mask3 &#x3D; saturate(pow(abs(frac(positionWS01.z * 10 + _Time.y * 0.1 * _Speed) - 0.53), 10) * 200);</span><br><span class="line">            float mask4 &#x3D; saturate(pow(abs(frac(positionWS01.z * 10 - _Time.y * 0.1 * _Speed) - 0.47), 10) * 200);</span><br><span class="line">            mask +&#x3D; mask2 + mask3 + mask4;</span><br><span class="line">            mask +&#x3D; step(0.95, mask);</span><br><span class="line">#elif _AXIS_Y</span><br><span class="line">            float mask &#x3D; saturate(pow(abs(frac(positionWS01.y * 10 + _Time.y * 0.1 * _Speed) - 0.75), 10) * 10);</span><br><span class="line">            mask +&#x3D; step(0.95, mask);</span><br><span class="line">#elif _AXIS_Z</span><br><span class="line">            float mask &#x3D; saturate(pow(abs(frac(positionWS01.z * 10 + _Time.y * 0.1 * _Speed) - 0.75), 10) * 10);</span><br><span class="line">            mask +&#x3D; step(0.95, mask);</span><br><span class="line">#endif</span><br><span class="line">            return tex * saturate(1 - mask) + (LineColor + _ColorEdge) * mask;  &#x2F;&#x2F; 扫描加入一个覆盖颜色更真实</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            #pragma multi_compile_local _AXIS_X _AXIS_Y _AXIS_Z</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><ul><li>通过屏幕像素点获得对应的世界坐标，在后处理中特别实用，如全局雾效，SSAO等</li><li>扫描效果与之前护盾扫描类似，扫描公式大概都以这样的为准，在此基础上进行魔改</li></ul><h1 id="屏幕炫光，更好的广告牌算法"><a href="#屏幕炫光，更好的广告牌算法" class="headerlink" title="屏幕炫光，更好的广告牌算法"></a>屏幕炫光，更好的广告牌算法</h1><h2 id="基础-9"><a href="#基础-9" class="headerlink" title="基础"></a>基础</h2><ol><li>使用模型空间(0,0,0,1)点做MV变换后得相机空间坐标，加上原先顶点的模型偏移，乘P矩阵得最终顶点坐标<br>基础广告牌已经完成，变得简单多了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 pivotWS &#x3D; mul(UNITY_MATRIX_M, float4(0, 0, 0, 1));</span><br><span class="line">float4 pivotVS &#x3D; mul(UNITY_MATRIX_V, pivotWS);</span><br><span class="line">o.positionHS &#x3D; mul(UNITY_MATRIX_P, pivotVS + float4(i.positionOS.xy, 0, 1));</span><br></pre></td></tr></table></figure></li><li>加入旋转以及缩放控制，目前对顶点进行变换并不会允许缩放以及旋转的控制<br>思路：在模型空间对其x，y坐标做缩放，旋转后(广告牌不需要z值)，再放入顶点变换计算中</li></ol><ul><li>二维旋转矩阵：<br>{<br>  cos(a),-sin(a),<br>  sin(a),cos(a)<br>}</li><li>获得GameObject的世界坐标缩放<br>float ScaleX = length(float3(UNITY_MATRIX_M[0].x, UNITY_MATRIX_M[1].x, UNITY_MATRIX_M[2].x));<br>float ScaleY = length(float3(UNITY_MATRIX_M[0].y, UNITY_MATRIX_M[1].y, UNITY_MATRIX_M[2].y));<br>float ScaleZ = length(float3(UNITY_MATRIX_M[0].z, UNITY_MATRIX_M[1].z, UNITY_MATRIX_M[2].z));</li><li>需要与unity顺序一致：先缩放，后旋转</li></ul><ol start="3"><li>制作炫光，加入一个渐隐渐现效果</li></ol><ul><li>制作渐隐渐现只需要一个值来控制(alpha)，怎么求得alpha</li><li>物体中心点周围一个范围， 采样屏幕深度纹理，判断深度值，被遮挡不通过</li><li>透明值 = 没被遮挡数 / 采样总数    // alpha = passCount / totalSampleCount;</li><li>裁剪空间坐标，透除：pos.xy / pos.w</li></ul><h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;ADS Pro&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        [HDR]_BaseColor(&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _Rotate(&quot;Rotate&quot;,Range(0,3.14)) &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;Queue&quot; &#x3D; &quot;Overlay&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        Blend One One</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_CameraDepthTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        float _Rotate;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float4 color         : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">            float4 pivotWS &#x3D; mul(UNITY_MATRIX_M, float4(0, 0, 0, 1));</span><br><span class="line">            float4 pivotVS &#x3D; mul(UNITY_MATRIX_V, pivotWS);</span><br><span class="line">            float ScaleX &#x3D; length(float3(UNITY_MATRIX_M[0].x, UNITY_MATRIX_M[1].x, UNITY_MATRIX_M[2].x));</span><br><span class="line">            float ScaleY &#x3D; length(float3(UNITY_MATRIX_M[0].y, UNITY_MATRIX_M[1].y, UNITY_MATRIX_M[2].y));</span><br><span class="line">            &#x2F;&#x2F;float ScaleZ &#x3D; length(float3(UNITY_MATRIX_M[0].z, UNITY_MATRIX_M[1].z, UNITY_MATRIX_M[2].z));</span><br><span class="line"></span><br><span class="line">            float2x2 rotateMatrix &#x3D; &#123;cos(_Rotate),-sin(_Rotate),sin(_Rotate),cos(_Rotate)&#125;;</span><br><span class="line">            float2 pos &#x3D; i.positionOS.xy * float2(ScaleX, ScaleY);</span><br><span class="line">            pos &#x3D; mul(rotateMatrix, pos);</span><br><span class="line">            float4 positionVS &#x3D; pivotVS + float4(pos, 0, 1);</span><br><span class="line">            o.positionHS &#x3D; mul(UNITY_MATRIX_P, positionVS);</span><br><span class="line"></span><br><span class="line">            int sampleCount &#x3D; 3;</span><br><span class="line">            int axisCount &#x3D; sampleCount * 2 + 1;</span><br><span class="line">            float totalCount &#x3D; axisCount * axisCount;</span><br><span class="line">            float sampleRate &#x3D; 0.2;&#x2F;&#x2F;中心区域大小比例</span><br><span class="line">            float pivotDepth &#x3D; -pivotVS.z;&#x2F;&#x2F;取相机空间轴心的线性深度</span><br><span class="line">            float4 pivotCS &#x3D; mul(UNITY_MATRIX_P, pivotVS);</span><br><span class="line">            int passCount &#x3D; 0;</span><br><span class="line">            for (int x &#x3D; -sampleCount; x &lt;&#x3D; sampleCount; ++x)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int y &#x3D; -sampleCount; y &lt;&#x3D; sampleCount; ++y)</span><br><span class="line">                &#123;</span><br><span class="line">                    float2 samplePos &#x3D; pivotCS.xy + o.positionHS.xy * sampleRate * float2(x, y) &#x2F; axisCount; &#x2F;&#x2F;裁剪空间采样坐标</span><br><span class="line">                    float2 SSuv &#x3D; samplePos &#x2F; o.positionHS.w * 0.5 + 0.5;&#x2F;&#x2F;把裁剪空间手动透除，变换到NDC空间下，并根据当前平台判断是否翻转y轴</span><br><span class="line">                    #ifdef UNITY_UV_STARTS_AT_TOP</span><br><span class="line">                    SSuv.y &#x3D; 1 - SSuv.y;</span><br><span class="line">                    #endif</span><br><span class="line"></span><br><span class="line">                    if (SSuv.x &lt; 0 || SSuv.x&gt;1 || SSuv.y &lt; 0 || SSuv.y&gt;1)</span><br><span class="line">                        continue;&#x2F;&#x2F;如果满足跳出本次循环进入下次循环</span><br><span class="line"></span><br><span class="line">                    float depth &#x3D; SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, SSuv, 0).x;</span><br><span class="line">                    depth &#x3D; LinearEyeDepth(depth, _ZBufferParams);</span><br><span class="line"></span><br><span class="line">                    passCount +&#x3D; step(pivotDepth, depth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o.color &#x3D; _BaseColor * _BaseColor.a * passCount &#x2F; totalCount;</span><br><span class="line">            o.color *&#x3D; smoothstep(0.1, 2, pivotDepth);</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            float4 color &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">            return i.color * color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &quot;RenderType&quot; &#x3D; &quot;Overlay&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><ul><li>取线性深度可以通过相机空间的-z值获取</li><li>判断平台差异，倒转y，UNITY_UV_STARTS_AT_TOP</li></ul><h1 id="屏幕空间贴花"><a href="#屏幕空间贴花" class="headerlink" title="屏幕空间贴花"></a>屏幕空间贴花</h1><h2 id="基础-10"><a href="#基础-10" class="headerlink" title="基础"></a>基础</h2><ol><li>Unity官方从2021.2版本开始才提供了 <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/renderer-feature-decal.html">Unity URP官方文档2021.2版本</a></li></ol><ul><li>贴花组件 Decal Projector Component</li><li>Shader使用：Shader Graphs/Decal</li><li>使用时打开RenderFeather： Decal</li></ul><ol start="2"><li><p>VisualEffectGraph粒子系统里提供了内置的ForwardDecal</p></li><li><p>自己实现一个屏幕空间贴画</p></li></ol><h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;Decal&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BaseColor (&quot;BaseColor&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">        _EdgeStretchPrevent (&quot;EdgeStretchPrevent&quot;, Range(-1,1)) &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;Queue&quot; &#x3D; &quot;Transparent-499&quot; &quot;RenderType&quot; &#x3D; &quot;Overlay&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot; &quot;DisableBatch&quot; &#x3D; &quot;True&quot;&#125;</span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_CameraDepthTexture);</span><br><span class="line">        SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        float _EdgeStretchPrevent;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float4 screenPos : TEXCOORD0;</span><br><span class="line">            float3 cameraPosOS:TEXCOORD1;</span><br><span class="line">            float4 cameraVertexDirOS:TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes i)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings o;</span><br><span class="line">            o.positionHS &#x3D; TransformObjectToHClip(i.positionOS.xyz);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 与ComputeScreenPos()函数效果相同</span><br><span class="line">            &#x2F;*o.screenPos &#x3D; o.positionHS * 0.5f;</span><br><span class="line">            o.screenPos.xy &#x3D;  float2(o.screenPos.x, o.screenPos.y * _ProjectionParams.x) + o.screenPos.w;</span><br><span class="line">            o.screenPos.zw &#x3D; o.positionHS.zw;*&#x2F;</span><br><span class="line"></span><br><span class="line">            o.screenPos &#x3D; ComputeScreenPos(o.positionHS);</span><br><span class="line"></span><br><span class="line">            float4 posVS &#x3D; mul(UNITY_MATRIX_V, mul(UNITY_MATRIX_M, i.positionOS));</span><br><span class="line">            o.cameraVertexDirOS.w &#x3D; -posVS.z;     &#x2F;&#x2F;w存线性深度</span><br><span class="line">            o.cameraVertexDirOS.xyz &#x3D; mul(UNITY_MATRIX_I_M, mul(UNITY_MATRIX_I_V, float4(posVS.xyz, 0))).xyz;  &#x2F;&#x2F;变换回模型空间坐标，但忽略了平移矩阵</span><br><span class="line"></span><br><span class="line">            o.cameraPosOS &#x3D; mul(UNITY_MATRIX_I_M, mul(UNITY_MATRIX_I_V, float4(0, 0, 0, 1))).xyz;&#x2F;&#x2F;计算模型空间下的相机坐标</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">            float2 uv &#x3D; i.screenPos.xy &#x2F; i.screenPos.w;</span><br><span class="line">            float depth &#x3D; LinearEyeDepth(SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, uv).x, _ZBufferParams);</span><br><span class="line"></span><br><span class="line">            i.cameraVertexDirOS.xyz &#x2F;&#x3D; i.cameraVertexDirOS.w;</span><br><span class="line">            float3 decalPos &#x3D; i.cameraPosOS + i.cameraVertexDirOS.xyz * depth;&#x2F;&#x2F;模型空间下的计算：相机坐标+相机朝着顶点的射线（已透除）*相机空间的线性深度</span><br><span class="line"></span><br><span class="line">            float mask &#x3D; (abs(decalPos.x) &lt; 0.5 ? 1 : 0) * (abs(decalPos.y) &lt; 0.5 ? 1 : 0) * (abs(decalPos.z) &lt; 0.5 ? 1 : 0);</span><br><span class="line"></span><br><span class="line">            float3 decalNormal &#x3D; normalize(cross(ddy(decalPos), ddx(decalPos)));</span><br><span class="line"></span><br><span class="line">            mask *&#x3D; decalNormal.y &gt; 0.2 * _EdgeStretchPrevent ? 1 : 0;&#x2F;&#x2F;边缘拉伸的防止阈值</span><br><span class="line"></span><br><span class="line">            float2 YdecalUV &#x3D; decalPos.xz + 0.5; &#x2F;&#x2F; 模型空间下坐标偏移 -0.5 到 0.5， 因此+0.5使其 0 - 1范围</span><br><span class="line"></span><br><span class="line">            float4 tex &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, YdecalUV) * mask;</span><br><span class="line"></span><br><span class="line">            return tex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            #pragma target 3.0</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><ul><li>ddx，ddy函数解释：对屏幕坐标x和y方向的偏导数<br>ddx(v) = 该像素点右边的v值 - 该像素点的v值<br>ddy(v) = 该像素点下面的v值 - 该像素点的v值<br>ddx(float3(1,2,3)) = float3(0,0,0) //因为使用该shader的所有像素 输出的记录值都是 float3(1,2,3)那么差值就为float3(0,0,0)<br>即理解为：ddx(v)，在屏幕上水平方向横跨一个像素的v值变化量，ddy，则在垂直方向上b的变化量</li></ul><p>解释：代码中使用 float3 decalNormal = normalize(cross(ddy(decalPos), ddx(decalPos)));<br>拿到模型空间decalPos后，ddy(decalPos)求得其往下的向量，ddx(decalPos)求得往右的向量，相当于得到decalPos在其相对坐标上的的x，y向量，叉乘得到z向量(垂直与两个向量)<br>可以近似理解为：ddx(decalPos) = (u+1,v)求出来的decalPos - (u,v)求出来的decalPos，在使用中相当于pos2-pos1，得到pos1到pos2的向量</p><ul><li>防止以后绕晕了再记录一下，以下M，V代表变换矩阵，I_M，I_V代表转置<br>positionVS =  mul(v * mul(M, positionOS))； positionOS = mul(I_M, mul(I_V, positionVS);<br>将变换过程理解为： positionOS -&gt; M -&gt; V = positionVS； 那么回去需要原路返回：positionVS -&gt; I_V -&gt; I_M = positionOS;</li></ul><h1 id="SSAO屏幕空间环境光遮蔽"><a href="#SSAO屏幕空间环境光遮蔽" class="headerlink" title="SSAO屏幕空间环境光遮蔽"></a>SSAO屏幕空间环境光遮蔽</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><p>参考 <a href="mailto:&#x63;&#111;&#x6d;&#46;&#x75;&#110;&#x69;&#x74;&#x79;&#x2e;&#114;&#101;&#110;&#100;&#x65;&#x72;&#x2d;&#x70;&#x69;&#x70;&#x65;&#x6c;&#x69;&#x6e;&#x65;&#115;&#x2e;&#117;&#110;&#105;&#x76;&#101;&#114;&#x73;&#97;&#108;&#x40;&#49;&#x32;&#46;&#49;&#46;&#49;">&#x63;&#111;&#x6d;&#46;&#x75;&#110;&#x69;&#x74;&#x79;&#x2e;&#114;&#101;&#110;&#100;&#x65;&#x72;&#x2d;&#x70;&#x69;&#x70;&#x65;&#x6c;&#x69;&#x6e;&#x65;&#115;&#x2e;&#117;&#110;&#105;&#x76;&#101;&#114;&#x73;&#97;&#108;&#x40;&#49;&#x32;&#46;&#49;&#46;&#49;</a>\ShaderLibrary\SSAO.hlsl<br><a href="https://zhuanlan.zhihu.com/p/46633896">环境遮罩之SSAO原理</a><br><a href="https://github.com/wlgys8/URPLearn/tree/master/Assets/URPLearn/SSAO">URP屏幕空间环境光遮蔽后处理(SSAO)</a><br><a href="https://blog.csdn.net/qq_35312463/article/details/117150378">【光线追踪系列十六】基于着色点的正向半球随机方向生成</a></p><ul><li>首先需要明确一点将所有坐标都转换至相机空间操作。</li></ul><ol><li><p>通过屏幕uv获取像素深度值，在裁剪空间中深度值就为其z轴的值，根据uv以及depth重建像素在相机空间的坐标<br>屏幕uv从0到1，裁剪空间uv从-1到1，将uv*2-1，范围变换至-1到1就为裁剪空间xy坐标。<br>通过renderingData.cameraData.GetGPUProjectionMatrix()获得当前相机P矩阵，以及P逆矩阵<br>通过逆矩阵求得VS坐标，进行齐次除法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据UV和depth，重建像素在viewspace中的坐标</span><br><span class="line">float3 ReconstructPositionVS(float2 uv, float depth) &#123;</span><br><span class="line">    float4 positionInHS &#x3D; float4(uv * 2 - 1, depth, 1);</span><br><span class="line">    float4 positionVS &#x3D; mul(CustomInvProjMatrix, positionInHS);</span><br><span class="line">    positionVS &#x2F;&#x3D; positionVS.w;</span><br><span class="line">    return positionVS.xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到当前像素的VS坐标后，需要在沿其法线方向的半球中随机采样点，然后计算对当前像素的ao影响<br>规定半球半径_SampleRadius，采样点数量_SampleCount，随机半球可以参照<a href="https://blog.csdn.net/qq_35312463/article/details/117150378">【光线追踪系列十六】基于着色点的正向半球随机方向生成</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">float Random(float2 st) &#123;</span><br><span class="line">    return frac(sin(dot(st, float2(12.9898, 78.233))) * 43758.5453123);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float Random(float x) &#123;</span><br><span class="line">    return frac(sin(x) * 43758.5453123);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 随机球</span><br><span class="line">float3 RandomSphere(float3 positionVS, float index)</span><br><span class="line">&#123;</span><br><span class="line">    float r1 &#x3D; Random(positionVS.xy);</span><br><span class="line">    float r2 &#x3D; Random(index);</span><br><span class="line">    float z &#x3D; sqrt(1 - r2);</span><br><span class="line">    float th &#x3D; 2 * PI * r1;</span><br><span class="line">    float x &#x3D; cos(th) * sqrt(r2);</span><br><span class="line">    float y &#x3D; sin(th) * sqrt(r2);</span><br><span class="line">    return float3(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先随机一个半球的单位向量，再将其转换至视觉空间，将偏移加载像素VS坐标上，通过偏移后的VS再获得当前屏幕uv，采样该uv随机点的深度值，再重新构建VS坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float2 ReProjectToUV(float3 positionVS) &#123;</span><br><span class="line">    float4 positionHS &#x3D; mul(CustomProjMatrix, float4(positionVS, 1));</span><br><span class="line">    return (positionHS.xy &#x2F; positionHS.w + 1) * 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 offset &#x3D; RandomSphere(positionVS, it);</span><br><span class="line">offset &#x3D; normalize(mul(TBN, offset));</span><br><span class="line">float3 samplePositionVS &#x3D; positionVS + offset * _SampleRadius;</span><br><span class="line">float2 sampleUV &#x3D; ReProjectToUV(samplePositionVS); </span><br><span class="line">float sampleDepth &#x3D; SampleDepth(sampleUV);</span><br><span class="line">float3 hitPositionVS &#x3D; ReconstructPositionVS(sampleUV, sampleDepth);</span><br></pre></td></tr></table></figure></li><li><p>获取到随机采样点后，计算该点对当前像素的ao影响值</p></li></ol><h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;SSAO&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line"></span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #pragma shader_feature __AO_DEBUG__</span><br><span class="line">        #pragma shader_feature _Blur</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Common.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Filtering.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Input.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS   : POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes input)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Varyings output;</span><br><span class="line">            UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line">            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);</span><br><span class="line">            output.positionHS &#x3D; TransformObjectToHClip(input.positionOS);</span><br><span class="line">            output.uv &#x3D; input.uv;</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X_FLOAT(_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X(_MainTex);</span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            float4 _MainTex_TexelSize;</span><br><span class="line">            float4x4 CustomProjMatrix;</span><br><span class="line">            float4x4 CustomInvProjMatrix;</span><br><span class="line">            float _Atten;</span><br><span class="line">            float _Contrast;</span><br><span class="line">            float _SampleRadius;</span><br><span class="line">            int _SampleCount;</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            float Random(float2 st) &#123;</span><br><span class="line">                return frac(sin(dot(st, float2(12.9898, 78.233))) * 43758.5453123);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float Random(float x) &#123;</span><br><span class="line">                return frac(sin(x) * 43758.5453123);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float3 RandomSampleOffset(float2 uv, float index) &#123;</span><br><span class="line">                float2 alphaBeta &#x3D; float2(Random(uv) * PI * 2, Random(index) * PI);</span><br><span class="line">                float2 sin2;</span><br><span class="line">                float2 cos2;</span><br><span class="line">                sincos(alphaBeta, sin2, cos2);</span><br><span class="line">                return float3(cos2.y * cos2.x, sin2.y, cos2.y * sin2.x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;根据UV和depth，重建像素在viewspace中的坐标</span><br><span class="line">            float3 ReconstructPositionVS(float2 uv, float depth) &#123;</span><br><span class="line">                float4 positionInHS &#x3D; float4(uv * 2 - 1, depth, 1);</span><br><span class="line">                float4 positionVS &#x3D; mul(CustomInvProjMatrix, positionInHS);</span><br><span class="line">                positionVS &#x2F;&#x3D; positionVS.w;</span><br><span class="line">                return positionVS.xyz;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float2 ReProjectToUV(float3 positionVS) &#123;</span><br><span class="line">                float4 positionHS &#x3D; mul(CustomProjMatrix, float4(positionVS, 1));</span><br><span class="line">                return (positionHS.xy &#x2F; positionHS.w + 1) * 0.5;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float SampleDepth(float2 uv) &#123;</span><br><span class="line">                return LOAD_TEXTURE2D_X(_CameraDepthTexture, _MainTex_TexelSize.zw * uv).x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line">                float4 color &#x3D; SAMPLE_TEXTURE2D_X(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                float depth &#x3D; SampleDepth(i.uv);</span><br><span class="line"></span><br><span class="line">                float3 positionVS &#x3D; ReconstructPositionVS(i.uv, depth);</span><br><span class="line"></span><br><span class="line">                float3 tangentVS &#x3D; normalize(ddx(positionVS));</span><br><span class="line">                &#x2F;&#x2F;重建法线</span><br><span class="line">                float3 normalVS &#x3D; normalize(cross(ddy(positionVS), ddx(positionVS)));   &#x2F;&#x2F; 面法线</span><br><span class="line"></span><br><span class="line">                float3 binormalVS &#x3D; cross(normalVS, tangentVS);</span><br><span class="line">                float3x3 TBN &#x3D; &#123;tangentVS, binormalVS, normalVS&#125;;</span><br><span class="line"></span><br><span class="line">                float ao &#x3D; 0;</span><br><span class="line">                float rcpSampleCount &#x3D; rcp(_SampleCount);</span><br><span class="line">                for (int it &#x3D; 0; it &lt; (int)_SampleCount; ++it)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 随机偏移值</span><br><span class="line">                    float3 offset &#x3D; RandomSampleOffset(i.uv, it);</span><br><span class="line">                    offset &#x3D; mul(TBN, offset);</span><br><span class="line">                    float3 samplePositionVS &#x3D; positionVS + offset * _SampleRadius * (1 + it) * rcpSampleCount;</span><br><span class="line">                    &#x2F;&#x2F;float4 samplePositionHS &#x3D; mul(CustomProjMatrix, float4(samplePositionVS, 1));</span><br><span class="line">                    &#x2F;&#x2F;float4 sampleScreenPos &#x3D; ComputeScreenPos(samplePositionHS);  &#x2F;&#x2F;ComputeScreenPos需要在顶点着色器使用，在片元计算结果不对劲</span><br><span class="line">                    &#x2F;&#x2F;float2 sampleUV &#x3D; sampleScreenPos.xy &#x2F; sampleScreenPos.w;</span><br><span class="line">                    float2 sampleUV &#x3D; ReProjectToUV(samplePositionVS); </span><br><span class="line"></span><br><span class="line">                    float sampleDepth &#x3D; SampleDepth(sampleUV);</span><br><span class="line">                    float3 hitPositionVS &#x3D; ReconstructPositionVS(sampleUV, sampleDepth);</span><br><span class="line"></span><br><span class="line">                    float3 hitOffset &#x3D; hitPositionVS - positionVS;</span><br><span class="line">                    float a &#x3D; max(0, dot(hitOffset, normalVS) - 0.001); &#x2F;&#x2F;0~radius</span><br><span class="line">                    float b &#x3D; dot(hitOffset, hitOffset) + 0.001; &#x2F;&#x2F;0~ radius^2</span><br><span class="line">                    ao +&#x3D; a * rcp(b); &#x2F;&#x2F; 0 ~ 1&#x2F;radius</span><br><span class="line">                &#125;</span><br><span class="line">                ao *&#x3D; _SampleRadius * rcpSampleCount;</span><br><span class="line">                ao &#x3D; PositivePow(ao * _Atten, _Contrast);</span><br><span class="line">                ao &#x3D; 1 - saturate(ao);</span><br><span class="line">                return ao;</span><br><span class="line">    #if __AO_DEBUG__ || _Blur</span><br><span class="line">                return float4(ao, ao, ao, 1);</span><br><span class="line">    #else</span><br><span class="line">                return ao * color;</span><br><span class="line">    #endif</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragBlurH</span><br><span class="line"></span><br><span class="line">            #include &quot;..&#x2F;Blur&#x2F;Blur.hlsl&quot;</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X(_MainTex);</span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            float4 _MainTex_TexelSize;</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            float4 FragBlurH(Varyings i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return BoxBlur(_MainTex,i.uv * _MainTex_TexelSize.zw,2,float2(1,0));</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragBlurV</span><br><span class="line"></span><br><span class="line">            #include &quot;..&#x2F;Blur&#x2F;Blur.hlsl&quot;</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X(_MainTex);</span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            float4 _MainTex_TexelSize;</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            float4 FragBlurV(Varyings i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                return BoxBlur(_MainTex,i.uv * _MainTex_TexelSize.zw,2,float2(0,1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragComb</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X(_MainTex);</span><br><span class="line">            SAMPLER(sampler_MainTex);</span><br><span class="line"></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            float4 _MainTex_TexelSize;</span><br><span class="line"></span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            TEXTURE2D_X(_AOTex);</span><br><span class="line">            SAMPLER(sampler_AOTex);</span><br><span class="line"></span><br><span class="line">            float4 FragComb(Varyings i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float4 color &#x3D; SAMPLE_TEXTURE2D_X(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                float ao &#x3D; SAMPLE_TEXTURE2D_X(_AOTex, sampler_AOTex, i.uv);</span><br><span class="line">                #if __AO_DEBUG__</span><br><span class="line">                return ao;</span><br><span class="line">                #else</span><br><span class="line">                return ao * color;</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h2><p>屏幕空间操作指南：</p><ol><li><p>通过uv，depth，重构世界坐标，需要InvVP，vp逆矩阵，(相机空间坐标同理) 都先得到裁剪空间坐标再进行对应的变换：positionCS = P * V * M * positionOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float3 ReconstructPositionWS(float2 uv, float depth) &#123;</span><br><span class="line">    float3 positionCS &#x3D; float3(uv * 2 - 1, depth);</span><br><span class="line">    float4 positionWS &#x3D; mul(_MatrixInvVP, float4(positionCS, 1));</span><br><span class="line">    positionWS &#x2F;&#x3D; positionWS.w;</span><br><span class="line">    return positionWS.xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样可以从世界坐标转换至裁剪坐标CS，裁剪坐标的xy范围(0-1)的uv值，z值为深度值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float3 Reproject(float3 positionWS) &#123;</span><br><span class="line">    float4 positionCS &#x3D; mul(_MatrixVP, float4(positionWS, 1));</span><br><span class="line">    positionCS &#x2F;&#x3D; positionCS.w;</span><br><span class="line">    positionCS.xy &#x3D; (positionCS.xy + 1) * 0.5;</span><br><span class="line">    return positionCS.xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>裁剪空间得到屏幕uv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float2 pixelCoord &#x3D; positionCS.xy * _MainTex_TexelSize.zw;</span><br></pre></td></tr></table></figure></li></ol><h1 id="SSPR屏幕空间平面反射"><a href="#SSPR屏幕空间平面反射" class="headerlink" title="SSPR屏幕空间平面反射"></a>SSPR屏幕空间平面反射</h1><h2 id="基础-11"><a href="#基础-11" class="headerlink" title="基础"></a>基础</h2><ol><li>记录需要平面反射的平面，世界坐标以及法线，针对所有平面都有以下操作(一个坐标一个法线确定一个平面)</li><li>通过屏幕uv以及depth，重构世界坐标系</li><li>在ComputeShader中做反转变换：将世界坐标沿平面反转，得到新的反转点后再转换至屏幕空间得到uv2</li><li>uv2的颜色就是反射uv1的颜色</li><li>将ComputShader反转后的图像，用于平面的渲染，渲染是需要判断当前深度》屏幕深度，则渲染图像上的颜色</li></ol><h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><ul><li><p>shader：需要反射的平面，对其反射处理使用的shader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;URPLearn&#x2F;PlanarReflection&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line"></span><br><span class="line">        Blend One One</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Common.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Filtering.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Input.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS   : POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float4 screenPos     : TEXCOORD1;</span><br><span class="line">            UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes input)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings output;</span><br><span class="line">            UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line">            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);</span><br><span class="line">            output.positionHS &#x3D; TransformObjectToHClip(input.positionOS);</span><br><span class="line">            output.uv &#x3D; input.uv;</span><br><span class="line">            output.screenPos &#x3D; ComputeScreenPos(output.positionHS);</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_ReflectionTex);</span><br><span class="line">        TEXTURE2D(_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        SAMPLER(sampler_ReflectionTex);</span><br><span class="line">        SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        float4 Frag(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float2 screenUV &#x3D; i.screenPos.xy &#x2F; i.screenPos.w;</span><br><span class="line">            float depth &#x3D; SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, screenUV);</span><br><span class="line"></span><br><span class="line">            if (i.positionHS.z &gt;&#x3D; depth) &#123;</span><br><span class="line">                float4 color &#x3D; SAMPLE_TEXTURE2D_X(_ReflectionTex, sampler_ReflectionTex, screenUV);</span><br><span class="line">                return color;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               discard;</span><br><span class="line">               return float4(0,0,0,0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RenderFeather：对标记的平面做反射以及再次渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">namespace URPLearn</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public class SSPRRenderFeather : ScriptableRendererFeature</span><br><span class="line">    &#123;</span><br><span class="line">        class SSPRPlanarRenderPass : ScriptableRenderPass</span><br><span class="line">        &#123;</span><br><span class="line">            private Material _material;</span><br><span class="line">            private SSPRTexGenerator _ssprTexGenerator &#x3D; new SSPRTexGenerator();</span><br><span class="line"></span><br><span class="line">            private PlanarRendererGroups _planarRendererGroups &#x3D; new PlanarRendererGroups();</span><br><span class="line"></span><br><span class="line">            public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">            &#123;</span><br><span class="line">                CommandBuffer cmd &#x3D; CommandBufferPool.Get(&quot;SSPR-ReflectionTex&quot;);</span><br><span class="line"></span><br><span class="line">                ReflectPlane.GetVisiblePlanarGroups(_planarRendererGroups);</span><br><span class="line">                foreach (var group in _planarRendererGroups.PlanarRenderers)</span><br><span class="line">                &#123;</span><br><span class="line">                    cmd.Clear();</span><br><span class="line">                    var planarDescriptor &#x3D; group.descriptor;</span><br><span class="line">                    var renderers &#x3D; group.renderers;</span><br><span class="line">                    _ssprTexGenerator.Render(cmd, this.colorAttachment, ref renderingData, ref group.descriptor);</span><br><span class="line">                    cmd.SetRenderTarget(this.colorAttachment, this.depthAttachment);</span><br><span class="line">                    foreach (var rd in renderers)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cmd.DrawRenderer(rd, _material);</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ssprTexGenerator.ReleaseTemporary(cmd);</span><br><span class="line">                    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cmd.Release();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void Setup(Material material, ComputeShader computeShader, bool blur, bool excludeBackground)</span><br><span class="line">            &#123;</span><br><span class="line">                _material &#x3D; material;</span><br><span class="line">                _ssprTexGenerator.BindCS(computeShader);</span><br><span class="line">                _ssprTexGenerator.enableBlur &#x3D; blur;</span><br><span class="line">                _ssprTexGenerator.excludeBackground &#x3D; excludeBackground;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        private Material _material;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        private ComputeShader _computeShader;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool _blur;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool _excludeBackground;</span><br><span class="line"></span><br><span class="line">        SSPRPlanarRenderPass m_ScriptablePass;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;inheritdoc&#x2F;&gt;</span><br><span class="line">        public override void Create()</span><br><span class="line">        &#123;</span><br><span class="line">            m_ScriptablePass &#x3D; new SSPRPlanarRenderPass();</span><br><span class="line"></span><br><span class="line">            m_ScriptablePass.renderPassEvent &#x3D; RenderPassEvent.BeforeRenderingPostProcessing;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Here you can inject one or multiple render passes in the renderer.</span><br><span class="line">        &#x2F;&#x2F; This method is called when setting up the renderer once per-camera.</span><br><span class="line">        public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">            if (renderingData.cameraData.renderType !&#x3D; CameraRenderType.Base)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (_material &#x3D;&#x3D; null || _computeShader &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            m_ScriptablePass.Setup(_material, _computeShader, _blur, _excludeBackground);</span><br><span class="line">            m_ScriptablePass.ConfigureTarget(renderer.cameraColorTarget, renderer.cameraDepthTarget);</span><br><span class="line">            renderer.EnqueuePass(m_ScriptablePass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class SSPRTexGenerator</span><br><span class="line">    &#123;</span><br><span class="line">        private static class ShaderProperties</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            public static readonly int Result &#x3D; Shader.PropertyToID(&quot;_Result&quot;);</span><br><span class="line">            public static readonly int CameraColorTexture &#x3D; Shader.PropertyToID(&quot;_CameraColorTexture&quot;);</span><br><span class="line">            public static readonly int PlanarPosition &#x3D; Shader.PropertyToID(&quot;_PlanarPosition&quot;);</span><br><span class="line">            public static readonly int PlanarNormal &#x3D; Shader.PropertyToID(&quot;_PlanarNormal&quot;);</span><br><span class="line">            public static readonly int MatrixVP &#x3D; Shader.PropertyToID(&quot;_MatrixVP&quot;);</span><br><span class="line">            public static readonly int MatrixInvVP &#x3D; Shader.PropertyToID(&quot;_MatrixInvVP&quot;);</span><br><span class="line">            public static readonly int MainTexelSize &#x3D; Shader.PropertyToID(&quot;_MainTex_TexelSize&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private ComputeShader _computeShader;</span><br><span class="line">        private int _reflectionTexID;</span><br><span class="line"></span><br><span class="line">        private int _kernelClear;</span><br><span class="line">        private int _kernalPass1;</span><br><span class="line">        private int _kernalPass2;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 在生成反射贴图的时候，是否剔除掉无穷远的像素(例如天空盒)</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private bool _excludeBackground;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 模糊</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private bool _enableBlur;</span><br><span class="line"></span><br><span class="line">        private BlurBlitter _blurBlitter &#x3D; new BlurBlitter();</span><br><span class="line"></span><br><span class="line">        public SSPRTexGenerator(string reflectTexName &#x3D; &quot;_ReflectionTex&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            _reflectionTexID &#x3D; Shader.PropertyToID(reflectTexName);</span><br><span class="line">        &#125;</span><br><span class="line">        public void BindCS(ComputeShader cp)</span><br><span class="line">        &#123;</span><br><span class="line">            _computeShader &#x3D; cp;</span><br><span class="line">            this.UpdateKernelIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        private void UpdateKernelIndex()</span><br><span class="line">        &#123;</span><br><span class="line">            _kernelClear &#x3D; _computeShader.FindKernel(&quot;Clear&quot;);</span><br><span class="line">            _kernalPass1 &#x3D; _computeShader.FindKernel(&quot;DrawReflectionTex1&quot;);</span><br><span class="line">            _kernalPass2 &#x3D; _computeShader.FindKernel(&quot;DrawReflectionTex2&quot;);</span><br><span class="line">            if (_excludeBackground)</span><br><span class="line">            &#123;</span><br><span class="line">                _kernalPass1 +&#x3D; 2;</span><br><span class="line">                _kernalPass2 +&#x3D; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public bool excludeBackground</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return _excludeBackground;</span><br><span class="line">            &#125;</span><br><span class="line">            set</span><br><span class="line">            &#123;</span><br><span class="line">                _excludeBackground &#x3D; value;</span><br><span class="line">                if (_computeShader)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.UpdateKernelIndex();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public bool enableBlur</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return _enableBlur;</span><br><span class="line">            &#125;</span><br><span class="line">            set</span><br><span class="line">            &#123;</span><br><span class="line">                _enableBlur &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Render(CommandBuffer cmd, RenderTargetIdentifier id, ref RenderingData renderingData, ref PlanarDescriptor planarDescriptor)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (_computeShader &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;请设置CS&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var reflectionTexDes &#x3D; renderingData.cameraData.cameraTargetDescriptor;</span><br><span class="line">            reflectionTexDes.enableRandomWrite &#x3D; true;</span><br><span class="line">            reflectionTexDes.msaaSamples &#x3D; 1;</span><br><span class="line">            cmd.GetTemporaryRT(_reflectionTexID, reflectionTexDes);</span><br><span class="line"></span><br><span class="line">            var rtWidth &#x3D; reflectionTexDes.width;</span><br><span class="line">            var rtHeight &#x3D; reflectionTexDes.height;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; V矩阵</span><br><span class="line">            Matrix4x4 v &#x3D; renderingData.cameraData.camera.worldToCameraMatrix;</span><br><span class="line">            &#x2F;&#x2F; 还不清楚：为什么不直接使用renderingData.cameraData.GetProjectionMatrix()</span><br><span class="line">            Matrix4x4 p &#x3D; GL.GetGPUProjectionMatrix(renderingData.cameraData.GetProjectionMatrix(), false);</span><br><span class="line">            &#x2F;&#x2F; MVP矩阵变换过程都是 右乘向量，所以VP &#x3D; p * v;</span><br><span class="line">            var matrixVP &#x3D; p * v;</span><br><span class="line">            var invMatrixVP &#x3D; matrixVP.inverse;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; computeShader 中thread组设置为(8,8,1)</span><br><span class="line">            int threadGroupX &#x3D; reflectionTexDes.width &#x2F; 8;</span><br><span class="line">            int threadGroupY &#x3D; reflectionTexDes.height &#x2F; 8;</span><br><span class="line"></span><br><span class="line">            RenderTargetIdentifier cameraColorTex &#x3D; id;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; computeshader参数设置</span><br><span class="line">            cmd.SetComputeVectorParam(_computeShader, ShaderProperties.MainTexelSize, new Vector4(1.0f &#x2F; rtWidth, 1.0f &#x2F; rtHeight, rtWidth, rtHeight));</span><br><span class="line">            cmd.SetComputeVectorParam(_computeShader, ShaderProperties.PlanarPosition, planarDescriptor.position);</span><br><span class="line">            cmd.SetComputeVectorParam(_computeShader, ShaderProperties.PlanarNormal, planarDescriptor.normal);</span><br><span class="line">            cmd.SetComputeMatrixParam(_computeShader, ShaderProperties.MatrixVP, matrixVP);</span><br><span class="line">            cmd.SetComputeMatrixParam(_computeShader, ShaderProperties.MatrixInvVP, invMatrixVP);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Texture相关参数都只能对应kernel设置</span><br><span class="line">            cmd.SetComputeTextureParam(_computeShader, _kernelClear, ShaderProperties.Result, _reflectionTexID);</span><br><span class="line">            cmd.DispatchCompute(_computeShader, _kernelClear, threadGroupX, threadGroupY, 1);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Pass1 对像素做反转</span><br><span class="line">            cmd.SetComputeTextureParam(_computeShader, _kernalPass1, ShaderProperties.CameraColorTexture, cameraColorTex);</span><br><span class="line">            cmd.SetComputeTextureParam(_computeShader, _kernalPass1, ShaderProperties.Result, _reflectionTexID);</span><br><span class="line">            cmd.DispatchCompute(_computeShader, _kernalPass1, threadGroupX, threadGroupY, 1);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Pass2 修理反转后像素的遮挡问题</span><br><span class="line">            cmd.SetComputeTextureParam(_computeShader, _kernalPass2, ShaderProperties.CameraColorTexture, cameraColorTex);</span><br><span class="line">            cmd.SetComputeTextureParam(_computeShader, _kernalPass2, ShaderProperties.Result, _reflectionTexID);</span><br><span class="line">            cmd.DispatchCompute(_computeShader, _kernalPass2, threadGroupX, threadGroupY, 1);</span><br><span class="line"></span><br><span class="line">            if (_enableBlur)</span><br><span class="line">            &#123;</span><br><span class="line">                _blurBlitter.SetSource(_reflectionTexID, reflectionTexDes);</span><br><span class="line">                _blurBlitter.blurType &#x3D; BlurType.BoxBilinear;</span><br><span class="line">                _blurBlitter.iteratorCount &#x3D; 1;</span><br><span class="line">                _blurBlitter.downSample &#x3D; 1;</span><br><span class="line">                _blurBlitter.Render(cmd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将结果图片设置为全局(在当前cmd内都能直接获取)</span><br><span class="line">            cmd.SetGlobalTexture(_reflectionTexID, _reflectionTexID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void ReleaseTemporary(CommandBuffer cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            cmd.ReleaseTemporaryRT(_reflectionTexID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReflectPlane：标记哪些平面需要反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace URPLearn</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 一个平面，平面由一个点和法线来确定</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public struct PlanarDescriptor</span><br><span class="line">    &#123;</span><br><span class="line">        public Vector3 position;</span><br><span class="line">        public Vector3 normal;</span><br><span class="line"></span><br><span class="line">        public static bool operator &#x3D;&#x3D;(PlanarDescriptor p1, PlanarDescriptor p2)</span><br><span class="line">        &#123;</span><br><span class="line">            return IsNormalEqual(p1.normal, p2.normal) &amp;&amp; IsPositionInPlanar(p1.position, p2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static bool operator !&#x3D;(PlanarDescriptor p1, PlanarDescriptor p2)</span><br><span class="line">        &#123;</span><br><span class="line">            return !IsNormalEqual(p1.normal, p2.normal) || !IsPositionInPlanar(p1.position, p2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override bool Equals(object obj)</span><br><span class="line">        &#123;</span><br><span class="line">            if (obj &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (obj is PlanarDescriptor p)</span><br><span class="line">            &#123;</span><br><span class="line">                return IsNormalEqual(normal, p.normal) &amp;&amp; IsPositionInPlanar(p.position, this);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override int GetHashCode()</span><br><span class="line">        &#123;</span><br><span class="line">            int hash &#x3D; 17;</span><br><span class="line">            hash &#x3D; hash * 23 + position.GetHashCode();</span><br><span class="line">            hash &#x3D; hash * 23 + normal.GetHashCode();</span><br><span class="line">            return hash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override string ToString()</span><br><span class="line">        &#123;</span><br><span class="line">            return base.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        private static bool IsNormalEqual(Vector3 n1, Vector3 n2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1 - Vector3.Dot(n1, n2) &lt; 0.001f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static bool IsPositionInPlanar(Vector3 checkPos, PlanarDescriptor planar)</span><br><span class="line">        &#123;</span><br><span class="line">            return Vector3.Dot(planar.position - checkPos, planar.normal) &lt; 0.01f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class PlanarRendererGroup</span><br><span class="line">    &#123;</span><br><span class="line">        public PlanarDescriptor descriptor;</span><br><span class="line">        public HashSet&lt;Renderer&gt; renderers &#x3D; new HashSet&lt;Renderer&gt;();</span><br><span class="line"></span><br><span class="line">        public void Clear()</span><br><span class="line">        &#123;</span><br><span class="line">            renderers.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class PlanarRendererGroups</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 池子</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private Stack&lt;PlanarRendererGroup&gt; _freePool &#x3D; new Stack&lt;PlanarRendererGroup&gt;();</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 平面反射</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private List&lt;PlanarRendererGroup&gt; _planarRenderers &#x3D; new List&lt;PlanarRendererGroup&gt;();</span><br><span class="line"></span><br><span class="line">        public List&lt;PlanarRendererGroup&gt; PlanarRenderers &#x3D;&gt; _planarRenderers;</span><br><span class="line"></span><br><span class="line">        public void AddRender(Renderer renderer)</span><br><span class="line">        &#123;</span><br><span class="line">            var position &#x3D; renderer.transform.position;</span><br><span class="line">            var normal &#x3D; renderer.transform.up;</span><br><span class="line">            var planarDescriptor &#x3D; new PlanarDescriptor()</span><br><span class="line">            &#123;</span><br><span class="line">                position &#x3D; position,</span><br><span class="line">                normal &#x3D; normal</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; 如果有同一平面的则放在一起渲染</span><br><span class="line">            foreach (var renderers in _planarRenderers)</span><br><span class="line">            &#123;</span><br><span class="line">                if (renderers.descriptor &#x3D;&#x3D; planarDescriptor)</span><br><span class="line">                &#123;</span><br><span class="line">                    renderers.renderers.Add(renderer);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 没有则添加一个平面渲染组</span><br><span class="line">            &#123;</span><br><span class="line">                var group &#x3D; AllocateGroup();</span><br><span class="line">                group.descriptor &#x3D; planarDescriptor;</span><br><span class="line">                group.renderers.Add(renderer);</span><br><span class="line">                _planarRenderers.Add(group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private PlanarRendererGroup AllocateGroup()</span><br><span class="line">        &#123;</span><br><span class="line">            if (_freePool.Count &gt; 0)</span><br><span class="line">                return _freePool.Pop();</span><br><span class="line">            else</span><br><span class="line">                return new PlanarRendererGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Clear()</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var group in _planarRenderers)</span><br><span class="line">            &#123;</span><br><span class="line">                group.Clear();</span><br><span class="line">                _freePool.Push(group);</span><br><span class="line">            &#125;</span><br><span class="line">            _planarRenderers.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [ExecuteInEditMode]</span><br><span class="line">    public class ReflectPlane : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        private static List&lt;ReflectPlane&gt; _reflectPlanes &#x3D; new List&lt;ReflectPlane&gt;();</span><br><span class="line">        public static List&lt;ReflectPlane&gt; ReflectPlanes &#x3D;&gt; _reflectPlanes;</span><br><span class="line"></span><br><span class="line">        public static void GetVisiblePlanarGroups(PlanarRendererGroups groups)</span><br><span class="line">        &#123;</span><br><span class="line">            groups.Clear();</span><br><span class="line">            foreach (var p in ReflectPlanes)</span><br><span class="line">            &#123;</span><br><span class="line">                var renderer &#x3D; p.GetComponent&lt;Renderer&gt;();</span><br><span class="line">                if (renderer.isVisible)</span><br><span class="line">                &#123;</span><br><span class="line">                    groups.AddRender(renderer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void OnEnable()</span><br><span class="line">        &#123;</span><br><span class="line">            _reflectPlanes.Add(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void OnDisable()</span><br><span class="line">        &#123;</span><br><span class="line">            _reflectPlanes.Remove(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ComputeShader：对图像进行反转操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#pragma kernel Clear</span><br><span class="line">#pragma kernel DrawReflectionTex1</span><br><span class="line">#pragma kernel DrawReflectionTex2</span><br><span class="line">#pragma kernel DrawReflectionTex1 EXCLUDE_BACKGROUND</span><br><span class="line">#pragma kernel DrawReflectionTex2 EXCLUDE_BACKGROUND</span><br><span class="line"></span><br><span class="line">#include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; _Result;</span><br><span class="line"></span><br><span class="line">Texture2D&lt;float4&gt; _CameraColorTexture;</span><br><span class="line">Texture2D&lt;float&gt; _CameraDepthTexture;</span><br><span class="line">float4 _MainTex_TexelSize;</span><br><span class="line"></span><br><span class="line">float4x4 _MatrixInvVP;</span><br><span class="line">float4x4 _MatrixVP;</span><br><span class="line"></span><br><span class="line">float3 _PlanarPosition;</span><br><span class="line">float3 _PlanarNormal;</span><br><span class="line"></span><br><span class="line">SamplerState PointClampSampler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float3 TransformPositionCSToWS(float3 positionCS) &#123;</span><br><span class="line">    float4 positionWS &#x3D; mul(_MatrixInvVP, float4(positionCS, 1));</span><br><span class="line">    positionWS &#x2F;&#x3D; positionWS.w;</span><br><span class="line">    return positionWS.xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 ReconstructPositionWS(float2 uv, float depth) &#123;</span><br><span class="line">    float3 positionCS &#x3D; float3(uv * 2 - 1, depth);</span><br><span class="line">    float3 positionWS &#x3D; TransformPositionCSToWS(positionCS);</span><br><span class="line">    return positionWS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 Reproject(float3 positionWS) &#123;</span><br><span class="line">    float4 positionCS &#x3D; mul(_MatrixVP, float4(positionWS, 1));</span><br><span class="line">    positionCS &#x2F;&#x3D; positionCS.w;</span><br><span class="line">    positionCS.xy &#x3D; (positionCS.xy + 1) * 0.5;</span><br><span class="line">    return positionCS.xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 GetMirrorPositionWS(float3 positionWS) &#123;</span><br><span class="line">    float normalProj &#x3D; dot(positionWS - _PlanarPosition, _PlanarNormal);</span><br><span class="line">    return float4(positionWS - normalProj * _PlanarNormal * 2, normalProj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void Clear(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    _Result[id.xy] &#x3D; float4(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float4 GetMirrorPositionWSFromID(uint3 id) &#123;</span><br><span class="line">    float2 pixelCoord &#x3D; id.xy;</span><br><span class="line">    float2 uv &#x3D; id.xy * _MainTex_TexelSize.xy;</span><br><span class="line">    float depth &#x3D; _CameraDepthTexture.SampleLevel(PointClampSampler, uv, 0);</span><br><span class="line">#ifdef EXCLUDE_BACKGROUND</span><br><span class="line">#if UNITY_REVERSED_Z</span><br><span class="line">    if (depth &#x3D;&#x3D; 0)</span><br><span class="line">#else</span><br><span class="line">    if (depth &#x3D;&#x3D; 1)</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">        return float4(0, 0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    float3 positionWS &#x3D; ReconstructPositionWS(uv, depth);</span><br><span class="line">    float4 mirrorPositionWS &#x3D; GetMirrorPositionWS(positionWS);</span><br><span class="line">    return mirrorPositionWS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 GetMirrorUVDepthFromID(uint3 id) &#123;</span><br><span class="line">    float4 mirrorPositionWS &#x3D; GetMirrorPositionWSFromID(id);</span><br><span class="line">    if (mirrorPositionWS.w &gt; 0.01) &#123;</span><br><span class="line">        float3 uvAndDepth &#x3D; Reproject(mirrorPositionWS.xyz);</span><br><span class="line">        return uvAndDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return float3(0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void DrawReflectionTex1(uint3 id : SV_DispatchThreadID) &#123;</span><br><span class="line">    float2 uv &#x3D; id.xy;</span><br><span class="line">    float3 mirrorUVAndDepth &#x3D; GetMirrorUVDepthFromID(id);</span><br><span class="line">    float2 mirrorPixelCoord &#x3D; mirrorUVAndDepth.xy * _MainTex_TexelSize.zw;</span><br><span class="line">    _Result[mirrorPixelCoord] &#x3D; float4(_CameraColorTexture[uv].rgb, mirrorUVAndDepth.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void DrawReflectionTex2(uint3 id : SV_DispatchThreadID) &#123;</span><br><span class="line">    float2 uv &#x3D; id.xy;</span><br><span class="line">    float3 mirrorUVAndDepth &#x3D; GetMirrorUVDepthFromID(id);</span><br><span class="line">    float2 toPixelCoord &#x3D; mirrorUVAndDepth.xy * _MainTex_TexelSize.zw;</span><br><span class="line">    float4 originalColor &#x3D; _Result[toPixelCoord];</span><br><span class="line"></span><br><span class="line">#if UNITY_REVERSED_Z</span><br><span class="line">    bool overwrite &#x3D; mirrorUVAndDepth.z &gt; originalColor.a;</span><br><span class="line">#else</span><br><span class="line">    bool overwrite &#x3D; mirrorUVAndDepth.z &lt; originalColor.a;</span><br><span class="line">#endif</span><br><span class="line">    if (overwrite) &#123;</span><br><span class="line">        _Result[toPixelCoord] &#x3D; float4(_CameraColorTexture[uv].rgb, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        _Result[toPixelCoord] &#x3D; float4(originalColor.rgb, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h2><ul><li>ComputeScreenPos在顶点着色器计算好屏幕空间坐标，再在片元着色器做齐次除法就可以得到屏幕uv</li><li>屏幕空间操作指南：参考上面SSAO总结，一般就是涉及世界坐标重建这个事情</li></ul><h1 id="URP实现PBR"><a href="#URP实现PBR" class="headerlink" title="URP实现PBR"></a>URP实现PBR</h1><h2 id="基础-12"><a href="#基础-12" class="headerlink" title="基础"></a>基础</h2><ul><li>满足以下几点的光照模型，符合PBR模型：</li></ul><ol><li>微表面：不同材质的平面，有很多不同朝向不一的微小平面</li><li>能量守恒：出射光的总量不超过入射光的总量</li><li>反射方程：使用基于物理的BRDF(双向反射分布函数)</li></ol><ul><li><p>PBR反射方程：L(o) = f(fr(p,wi,wo) * Li(p,wi) * dot(n,wi) * dwi)</p></li><li><p>BRDF-Cooktorrance方程：</p></li></ul><ol><li>fr(p,wi,wo) = k(d)*f(lambert) + K(s)*f(cook-torrance)</li><li>f(lamber) = c / Π</li><li>∫(cook-torrance) = D<em>F</em>G / (4*dot(wo,n)*dot(wi,n))</li><li>D：法线分布函数（NDF），估算微平面的整体取向，公式：a^2 / (Π * (NdotH^2) * (a^2-1) + 1)^2  （注：a表示粗糙度）</li><li>F: 菲尼尔方程，用于描述表面反射光所占比例， 公式： F0 + (1 - F0) * pos(1 - cosTheta, 5) （注：F0表示不同材质的垂直方向的反射率，直接光照中cosTheta：HdotV或HdotL，间接光照中cosTheta：NdotV）</li><li>G：几何函数，用于计算微表面，自阴影， 公式：cosTheta / (cosTheta(1.0 - k) + k)  （注：k由粗糙度a计算，直接光照：k=(a+1)^2 / 8， 间接光照：k=a^2 / 2 ， cosTheta需要分别计算NoV,NoL的和）</li><li>K(d)：(1-F)*(1-metallic)</li><li>K(s)：菲尼尔值里包括了表面反射系数，因此K(s)不需要</li></ol><ul><li>IBL间接光照</li></ul><ol><li>CubeMap IrradianceMap 或者ShadeSH9() ,URP用SampleSH9() 球谐函数计算间接光照的diffuse</li><li>预高光积分图，或者高光积分算法计算间接光照的specular<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/%E9%A2%84%E9%AB%98%E5%85%89%E7%A7%AF%E5%88%86%E5%9B%BE.png" alt="预高光积分图" title="预高光积分图"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float2 IntegrateSpecularBRDF(float NoV, float roughness)</span><br><span class="line">&#123;</span><br><span class="line">    const float4 c0 &#x3D; float4(-1, -0.0275, -0.572, 0.022);</span><br><span class="line">    const float4 c1 &#x3D; float4(1, 0.0425, 1.04, -0.04);</span><br><span class="line">    float4 r &#x3D; roughness * c0 + c1;</span><br><span class="line">    float a004 &#x3D; min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;</span><br><span class="line">    return float2(-c1.z, c1.z) * a004 + r.zw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>准备资源<br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/PBR%E5%9F%BA%E7%A1%80%E9%A2%9C%E8%89%B2.png" alt="PBR基础颜色" title="PBR基础颜色"><br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/PBR%E6%B3%95%E7%BA%BF.png" alt="PBR法线" title="PBR法线"><br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/PBR%E9%87%91%E5%B1%9E%E5%BA%A6.png" alt="PBR金属度" title="PBR金属度"><br><img src="/blog/2021/11/30/Graphics/URP/URP%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/PBR%E7%B2%97%E7%B3%99%E5%BA%A6.png" alt="PBR粗糙度" title="PBR粗糙度"></li></ul><h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;PBR&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _BaseColor(&quot;_BaseColor&quot;, Color) &#x3D; (1, 1, 1, 1)</span><br><span class="line">        _MainTex(&quot;_MainTex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _BumpScale(&quot;_BumpScale&quot;, Range(-1, 1)) &#x3D; 1</span><br><span class="line">        [NoScaleOffset] _BumpMap(&quot;_BumpMap&quot;, 2D) &#x3D; &quot;bump&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        [NoScaleOffset] _MetalnessMap(&quot;_MetalnessMap&quot;, 2D) &#x3D; &quot;black&quot; &#123;&#125;</span><br><span class="line">        [NoScaleOffset] _RoughnessMap(&quot;_RoughnessMap&quot;, 2D) &#x3D; &quot;gray&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _IndirectIntensity(&quot;_IndirectIntensity&quot;, Range(0, 1)) &#x3D; 1</span><br><span class="line">        &#x2F;&#x2F;[NoScaleOffset] _IrradianceCube (&quot;_IrradianceCube&quot;, Cube) &#x3D; &quot;black&quot; &#123;&#125;</span><br><span class="line">        &#x2F;&#x2F;[NoScaleOffset] _RadianceCube (&quot;_RadianceCube&quot;, Cube) &#x3D; &quot;black&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        [Toggle(USE_BRDF_INTEGRATION_MAP)] _UseBRDFIntegrationMap(&quot;_UseBRDFIntegrationMap&quot;, Float) &#x3D; 0</span><br><span class="line">        [NoScaleOffset] _BRDFIntegrationMap(&quot;_BRDFIntegrationMap&quot;, 2D) &#x3D; &quot;black&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line">        #define EPSILSON 0.000001</span><br><span class="line">        #define BRDF_PI 3.14159265359</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line">        TEXTURE2D(_BumpMap);</span><br><span class="line">        SAMPLER(sampler_BumpMap);</span><br><span class="line"></span><br><span class="line">        TEXTURE2D(_MetalnessMap);</span><br><span class="line">        SAMPLER(sampler_MetalnessMap);</span><br><span class="line">        TEXTURE2D(_RoughnessMap);</span><br><span class="line">        SAMPLER(sampler_RoughnessMap);</span><br><span class="line">        TEXTURE2D(_BRDFIntegrationMap);</span><br><span class="line">        SAMPLER(sampler_BRDFIntegrationMap);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_ST;</span><br><span class="line">        float4 _BaseColor;</span><br><span class="line">        float _BumpScale;</span><br><span class="line">        float _IndirectIntensity;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS:POSITION;</span><br><span class="line">            float4 normalOS:NORMAL;</span><br><span class="line">            float4 tangentOS:TANGENT;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            float4 tangentWS:TEXCOORD1;</span><br><span class="line">            float4 BtangentWS:TEXCOORD2;</span><br><span class="line">            float4 normalWS:TEXCOORD3;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;菲涅尔函数</span><br><span class="line">        float3 FresnelSchlick(float NoV, float3 F0)</span><br><span class="line">        &#123;</span><br><span class="line">            return F0 + (1.0 - F0) * pow(1.0 - NoV, 5);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;几何函数</span><br><span class="line">        float GeometrySchlickGGX(float NoV, float k)</span><br><span class="line">        &#123;</span><br><span class="line">            return NoV &#x2F; max(NoV * (1.0 - k) + k, EPSILSON);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;几何函数</span><br><span class="line">        float GeometrySmith(float NoV, float NoL, float k)</span><br><span class="line">        &#123;</span><br><span class="line">            return GeometrySchlickGGX(NoV, k) * GeometrySchlickGGX(NoL, k);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;分布函数 alpha&#x3D;roughness*roughness</span><br><span class="line">        float DistributionGGX(float NoH, float alpha)</span><br><span class="line">        &#123;</span><br><span class="line">            float a2 &#x3D; alpha * alpha;</span><br><span class="line">            float denom &#x3D; pow(NoH * NoH * (a2 - 1.0) + 1.0, 2);</span><br><span class="line">            return a2 &#x2F; max(denom * BRDF_PI, EPSILSON);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;计算直接光照</span><br><span class="line">        float3 CalcDirectLight(float metalness, float roughness, float3 albedo, float3 F0, float3 normal, float3 viewDir, float NoV, float3 worldPos)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;准备参数</span><br><span class="line">            Light mylight &#x3D; GetMainLight();</span><br><span class="line">            float3 lightDir &#x3D; normalize(mylight.direction); &#x2F;&#x2F;获取光线方向</span><br><span class="line">            float3 floatDir &#x3D; normalize(viewDir + lightDir); &#x2F;&#x2F;计算半角方向</span><br><span class="line">            float NoL &#x3D; saturate(dot(normal, lightDir)); &#x2F;&#x2F;计算法线光线点积</span><br><span class="line">            float NoH &#x3D; saturate(dot(normal, floatDir)); &#x2F;&#x2F;计算法线半角点积</span><br><span class="line">            float HoL &#x3D; saturate(dot(floatDir, lightDir)); &#x2F;&#x2F;计算半角光线点积，同半角视线点积</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;计算方程参数</span><br><span class="line">            float3 F &#x3D; FresnelSchlick(HoL, F0); &#x2F;&#x2F;计算菲涅尔</span><br><span class="line">            float G &#x3D; GeometrySmith(NoV, NoL, pow(roughness + 1.0, 2) &#x2F; 8.0); &#x2F;&#x2F;计算遮挡</span><br><span class="line">            float D &#x3D; DistributionGGX(NoH, roughness * roughness); &#x2F;&#x2F;计算分布</span><br><span class="line">            float3 kD &#x3D; (1.0 - F) * (1.0 - metalness); &#x2F;&#x2F;计算漫反射系数</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;计算直接光照结果</span><br><span class="line">            float3 directDiffuse &#x3D; kD * albedo &#x2F; BRDF_PI; &#x2F;&#x2F;计算漫反射</span><br><span class="line">            float3 directSpecular &#x3D; F * (D * G) &#x2F; (4.0 * max(NoV * NoL, EPSILSON)); &#x2F;&#x2F;计算高光</span><br><span class="line">            float3 directLightIn &#x3D; mylight.color * BRDF_PI; &#x2F;&#x2F;获取直接光照颜色</span><br><span class="line">            return (directDiffuse + directSpecular) * NoL * directLightIn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float2 IntegrateSpecularBRDF(float NoV, float roughness)</span><br><span class="line">        &#123;</span><br><span class="line">            const float4 c0 &#x3D; float4(-1, -0.0275, -0.572, 0.022);</span><br><span class="line">            const float4 c1 &#x3D; float4(1, 0.0425, 1.04, -0.04);</span><br><span class="line">            float4 r &#x3D; roughness * c0 + c1;</span><br><span class="line">            float a004 &#x3D; min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;</span><br><span class="line">            return float2(-c1.z, c1.z) * a004 + r.zw;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        real3 SampleSH(real3 normalWS)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; LPPV is not supported in Ligthweight Pipeline</span><br><span class="line">            real4 SHCoefficients[7];</span><br><span class="line">            SHCoefficients[0] &#x3D; unity_SHAr;</span><br><span class="line">            SHCoefficients[1] &#x3D; unity_SHAg;</span><br><span class="line">            SHCoefficients[2] &#x3D; unity_SHAb;</span><br><span class="line">            SHCoefficients[3] &#x3D; unity_SHBr;</span><br><span class="line">            SHCoefficients[4] &#x3D; unity_SHBg;</span><br><span class="line">            SHCoefficients[5] &#x3D; unity_SHBb;</span><br><span class="line">            SHCoefficients[6] &#x3D; unity_SHC;</span><br><span class="line"></span><br><span class="line">            return max(real3(0, 0, 0), SampleSH9(SHCoefficients, normalWS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;计算间接光照</span><br><span class="line">        float3 CalcIndirectLight(float metalness, float roughness, float3 albedo, float3 F0, float3 normal, float3 viewDir, float NoV)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;准备参数</span><br><span class="line">            float3 F &#x3D; FresnelSchlick(NoV, F0); &#x2F;&#x2F;计算菲涅尔</span><br><span class="line">            float3 kD &#x3D; (1.0 - F) * (1.0 - metalness); &#x2F;&#x2F;计算漫反射系数</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;计算间接漫反射</span><br><span class="line">            &#x2F;&#x2F;float3 indirectDiffuse &#x3D; SAMPLE_TEXTURE2D(_IrradianceCube, normal).rgb;</span><br><span class="line">            float3 indirectDiffuse &#x3D; SampleSH(normal);</span><br><span class="line">            indirectDiffuse *&#x3D; kD * albedo;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;计算间接高光</span><br><span class="line">            float mip &#x3D; PerceptualRoughnessToMipmapLevel(roughness); &#x2F;&#x2F;计算粗糙度对应MIP</span><br><span class="line">            float3 reflDir &#x3D; reflect(-viewDir, normal); &#x2F;&#x2F;计算视线反射方向</span><br><span class="line">            &#x2F;&#x2F;float3 indirectSpecular &#x3D; SAMPLE_TEXTURECUBE_LOD(_RadianceCube, float4(reflDir, mip)).rgb;</span><br><span class="line">            float4 encodedIrradiance &#x3D; SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflDir, mip);</span><br><span class="line">            float3 indirectSpecular &#x3D; DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;高光积分</span><br><span class="line">#if USE_BRDF_INTEGRATION_MAP</span><br><span class="line">            float2 envBRDF &#x3D; SAMPLE_TEXTURE2D(_BRDFIntegrationMap, sampler_BRDFIntegrationMap, float2(NoV, roughness)).rg;</span><br><span class="line">#else</span><br><span class="line">            float2 envBRDF &#x3D; IntegrateSpecularBRDF(NoV, roughness);</span><br><span class="line">#endif</span><br><span class="line">            indirectSpecular *&#x3D; F * envBRDF.x + envBRDF.y;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;计算间接光照结果</span><br><span class="line">            return (indirectDiffuse + indirectSpecular) * _IndirectIntensity;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123; &quot;LightMode&quot; &#x3D; &quot;UniversalForward&quot; &#125;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Frag</span><br><span class="line">            #pragma shader_feature USE_BRDF_INTEGRATION_MAP</span><br><span class="line"></span><br><span class="line">            Varyings Vert(Attributes i)</span><br><span class="line">            &#123;</span><br><span class="line">                Varyings o;</span><br><span class="line">                VertexPositionInputs input &#x3D; GetVertexPositionInputs(i.positionOS.xyz);</span><br><span class="line">                o.positionHS &#x3D; input.positionCS;</span><br><span class="line"></span><br><span class="line">                VertexNormalInputs normalInput &#x3D; GetVertexNormalInputs(i.normalOS, i.tangentOS);</span><br><span class="line">                o.tangentWS.xyz &#x3D; normalInput.tangentWS;</span><br><span class="line">                o.BtangentWS.xyz &#x3D; normalInput.bitangentWS;</span><br><span class="line">                o.normalWS.xyz &#x3D; normalInput.normalWS;</span><br><span class="line">                &#x2F;&#x2F; 存一下世界空间坐标</span><br><span class="line">                o.tangentWS.w &#x3D; input.positionWS.x;</span><br><span class="line">                o.BtangentWS.w &#x3D; input.positionWS.y;</span><br><span class="line">                o.normalWS.w &#x3D; input.positionWS.z;</span><br><span class="line"></span><br><span class="line">                o.uv &#x3D; TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 Frag(Varyings i) :SV_Target&#123;</span><br><span class="line"></span><br><span class="line">                float3 positionWS &#x3D; float3(i.tangentWS.w,i.BtangentWS.w,i.normalWS.w);</span><br><span class="line"></span><br><span class="line">                float metalness &#x3D; SAMPLE_TEXTURE2D(_MetalnessMap, sampler_MetalnessMap, i.uv).r;</span><br><span class="line">                float roughness &#x3D; SAMPLE_TEXTURE2D(_RoughnessMap, sampler_RoughnessMap, i.uv).r;</span><br><span class="line">                float4 mainColor &#x3D; SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</span><br><span class="line">                float3 albedo &#x3D; _BaseColor.rgb * mainColor.rgb;</span><br><span class="line"></span><br><span class="line">                float3x3 T2W &#x3D; &#123; i.tangentWS.xyz, i.BtangentWS.xyz, i.normalWS.xyz &#125;;</span><br><span class="line"></span><br><span class="line">                float4 norTex &#x3D; SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, i.uv);</span><br><span class="line">                float3 normalTS &#x3D; UnpackNormalScale(norTex, _BumpScale);</span><br><span class="line">                normalTS.z &#x3D; pow(1 - pow(normalTS.x, 2) - pow(normalTS.y, 2), 0.5f);    &#x2F;&#x2F;规范化</span><br><span class="line">                float3 normalWS &#x3D; normalize(mul(normalTS, T2W));</span><br><span class="line">                float3 viewDirWS &#x3D; normalize(_WorldSpaceCameraPos.xyz - positionWS);</span><br><span class="line"></span><br><span class="line">                float3 F0 &#x3D; lerp(0.04f, albedo, metalness);</span><br><span class="line">                float NoV &#x3D; dot(normalWS, viewDirWS);</span><br><span class="line"></span><br><span class="line">                float3 directColor &#x3D; CalcDirectLight(metalness, roughness, albedo, F0, normalWS, viewDirWS, NoV, positionWS);</span><br><span class="line">                float3 indirectColor &#x3D; CalcIndirectLight(metalness, roughness, albedo, F0, normalWS, viewDirWS, NoV);</span><br><span class="line"></span><br><span class="line">                return float4(directColor + indirectColor, mainColor.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h2><h1 id="草绘制"><a href="#草绘制" class="headerlink" title="草绘制"></a>草绘制</h1><h2 id="基础-13"><a href="#基础-13" class="headerlink" title="基础"></a>基础</h2><h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h2 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h2><h1 id="浅水"><a href="#浅水" class="headerlink" title="浅水"></a>浅水</h1><h2 id="基础-14"><a href="#基础-14" class="headerlink" title="基础"></a>基础</h2><h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><h2 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h2><h2 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h2><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h1><p><a href="https://blog.csdn.net/marsz1990/article/details/106110120/">Unity3D游戏开发中100+效果的实现和源码大全 - 收藏起来肯定用得着</a><br><a href="https://space.bilibili.com/5863867/article">URP HLSL入门学习</a><br><a href="https://blog.csdn.net/poem_qianmo/article/details/105350519">高品质后处理：十种图像模糊算法的总结与实现</a></p>]]></content>
    
    
    <summary type="html">URP效果实现</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="URP" scheme="https://skierhou.github.io/tags/URP/"/>
    
  </entry>
  
  <entry>
    <title>URP学习汇总</title>
    <link href="https://skierhou.github.io/2021/11/21/Graphics/URP/URP%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>https://skierhou.github.io/2021/11/21/Graphics/URP/URP%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/</id>
    <published>2021-11-21T06:30:01.000Z</published>
    <updated>2021-12-09T09:07:26.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新建URP项目，Unity默认测试场景查看变化"><a href="#新建URP项目，Unity默认测试场景查看变化" class="headerlink" title="新建URP项目，Unity默认测试场景查看变化"></a>新建URP项目，Unity默认测试场景查看变化</h1><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><h3 id="Camera-基础设置解释"><a href="#Camera-基础设置解释" class="headerlink" title="Camera 基础设置解释"></a>Camera 基础设置解释</h3><ol><li>相机堆叠：RenderType<h3 id="Camera-特殊功能列举"><a href="#Camera-特殊功能列举" class="headerlink" title="Camera 特殊功能列举"></a>Camera 特殊功能列举</h3></li><li>分屏相机两个Camera，RenderType都设置成Base，设置ViewportRect即可<br><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.7/manual/rendering-to-the-same-render-target.html">相机分屏</a> </li></ol><h2 id="Post-process-Volume后处理盒子"><a href="#Post-process-Volume后处理盒子" class="headerlink" title="Post-process Volume后处理盒子"></a>Post-process Volume后处理盒子</h2><ul><li>添加Volume<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace UnityEngine.Rendering.Universal</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField, VolumeComponentMenu(&quot;Mypost&#x2F;ScreenSpacePlaneReflect&quot;)]</span><br><span class="line"></span><br><span class="line">    public class ScreenSpacePlaneReflection : VolumeComponent</span><br><span class="line">    &#123;</span><br><span class="line">        public BoolParameter on &#x3D; new BoolParameter(false);</span><br><span class="line">        public ClampedIntParameter RTsize &#x3D; new ClampedIntParameter(512, 128, 720, false);</span><br><span class="line">        public FloatParameter ReflectHeight &#x3D; new FloatParameter(0.2f, false);</span><br><span class="line">        public ClampedFloatParameter fadeOutRange &#x3D; new ClampedFloatParameter(0.3f, 0.0f, 1.0f, false);</span><br><span class="line"></span><br><span class="line">        public bool IsActive() &#x3D;&gt; on.value;</span><br><span class="line">        public bool IsTileCompatible() &#x3D;&gt; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获得组件： VolumeManager.instance.stack.GetComponent<XXX>();  //获取自定义的volume组件</XXX></li><li>目前这种方式还是扩展后处理还是比较困难，由于流程最终走的uber shader，<br>加新效果都需要再里面加一个处理，相当于改源码，因此使用RenderFeather添加后处理比较方便</li></ul><h2 id="Forward-Renderer-Data设置说明"><a href="#Forward-Renderer-Data设置说明" class="headerlink" title="Forward Renderer Data设置说明"></a>Forward Renderer Data设置说明</h2><h3 id="Renderer-Features"><a href="#Renderer-Features" class="headerlink" title="Renderer Features"></a>Renderer Features</h3><h4 id="基础Features：Render-Objects"><a href="#基础Features：Render-Objects" class="headerlink" title="基础Features：Render Objects"></a>基础Features：Render Objects</h4><ol><li>初次理解，在渲染管线的某个时刻，过滤到需要的Object，并覆盖一些特殊设置，如遮挡显示等等<br><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@13.1/manual/renderer-features/how-to-custom-effect-render-objects.html">URP手册</a> <h4 id="基础Features：SSAO"><a href="#基础Features：SSAO" class="headerlink" title="基础Features：SSAO"></a>基础Features：SSAO</h4><a href="https://blog.csdn.net/liquanyi007/article/details/110382179">环境遮挡Ambient Occlusion</a><h4 id="自定义Renderer-Features"><a href="#自定义Renderer-Features" class="headerlink" title="自定义Renderer Features"></a>自定义Renderer Features</h4></li></ol><ul><li>如何创建：</li></ul><ol><li>Create / Rendering / URP / RenderFeature</li><li>创建脚本继承自：ScriptableRendererFeature， ScriptableRenderPass<figure class="highlight plain"><figcaption><span>/ Create / Rendering / URP / RenderFeature创建</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">public class CustomRenderPassFeature : ScriptableRendererFeature</span><br><span class="line">&#123;</span><br><span class="line">    class CustomRenderPass : ScriptableRenderPass</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; This method is called before executing the render pass.</span><br><span class="line">        &#x2F;&#x2F; It can be used to configure render targets and their clear state. Also to create temporary render target textures.</span><br><span class="line">        &#x2F;&#x2F; When empty this render pass will render to the active camera render target.</span><br><span class="line">        &#x2F;&#x2F; You should never call CommandBuffer.SetRenderTarget. Instead call &lt;c&gt;ConfigureTarget&lt;&#x2F;c&gt; and &lt;c&gt;ConfigureClear&lt;&#x2F;c&gt;.</span><br><span class="line">        &#x2F;&#x2F; The render pipeline will ensure target setup and clearing happens in a performant manner.</span><br><span class="line">        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Here you can implement the rendering logic.</span><br><span class="line">        &#x2F;&#x2F; Use &lt;c&gt;ScriptableRenderContext&lt;&#x2F;c&gt; to issue drawing commands or execute command buffers</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;docs.unity3d.com&#x2F;ScriptReference&#x2F;Rendering.ScriptableRenderContext.html</span><br><span class="line">        &#x2F;&#x2F; You don&#39;t have to call ScriptableRenderContext.submit, the render pipeline will call it at specific points in the pipeline.</span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cleanup any allocated resources that were created during the execution of this render pass.</span><br><span class="line">        public override void OnCameraCleanup(CommandBuffer cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CustomRenderPass m_ScriptablePass;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;inheritdoc&#x2F;&gt;</span><br><span class="line">    public override void Create()</span><br><span class="line">    &#123;</span><br><span class="line">        m_ScriptablePass &#x3D; new CustomRenderPass();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Configures where the render pass should be injected.</span><br><span class="line">        m_ScriptablePass.renderPassEvent &#x3D; RenderPassEvent.AfterRenderingOpaques;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Here you can inject one or multiple render passes in the renderer.</span><br><span class="line">    &#x2F;&#x2F; This method is called when setting up the renderer once per-camera.</span><br><span class="line">    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)</span><br><span class="line">    &#123;</span><br><span class="line">        renderer.EnqueuePass(m_ScriptablePass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>用途：</li></ul><ol><li>实现URP没有提供的后处理效果</li><li>很多效果都可以放在RenderFeather中实现</li></ol><p>//贴花 URP Decal Projector</p><h1 id="ShaderGraph使用"><a href="#ShaderGraph使用" class="headerlink" title="ShaderGraph使用"></a>ShaderGraph使用</h1><h2 id="解析URP默认ShaderGraph"><a href="#解析URP默认ShaderGraph" class="headerlink" title="解析URP默认ShaderGraph"></a>解析URP默认ShaderGraph</h2><h1 id="一些URP特殊用法"><a href="#一些URP特殊用法" class="headerlink" title="一些URP特殊用法"></a>一些URP特殊用法</h1><h3 id="SAMPLER"><a href="#SAMPLER" class="headerlink" title="SAMPLER"></a>SAMPLER</h3><ul><li>官网关于SAMPLER的使用说明<br>“Point”, “Linear” or “Trilinear” (required) set up texture filtering mode.</li></ul><p>“Clamp”, “Repeat”, “Mirror” or “MirrorOnce” (required) set up texture wrap mode.Wrap modes can be specified per-axis (UVW), e.g. “ClampU_RepeatV”.</p><p>“Compare” (optional) set up sampler for depth comparison; use with HLSL SamplerComparisonState type and SampleCmp / SampleCmpLevelZero functions.</p><ul><li>使用方式<br>sampler_&lt;过滤&gt;&lt;UV处理&gt;  形成一个变量名,用这个变量作为参数形成采样<br>例如：sampler_LinearClamp 这个表示采样过滤是linear,超过(0,1)用clamp方式采样<br>SAMPLER(sampler_LinearClamp);在shader里这样声明变量</li></ul><p>采样是这样使用:<br>float4 cloud = SAMPLE_TEXTURE2D_X(_CloudTex, sampler_LinearClamp, cloud_uv);<br>也可以这样<br>_CloudTex.Sample(sampler_LinearClamp, cloud_uv);</p><ul><li>定义纹理和纹理采样器<br>TEXTURE2D(textureName);<br>SAMPLER(sampler_textureName);</li></ul><h3 id="TEXTURE2D"><a href="#TEXTURE2D" class="headerlink" title="TEXTURE2D"></a>TEXTURE2D</h3><ul><li>TEXTURE2D_X(_MainTex);</li><li>TEXTURE2D_X_FLOAT(_CameraDepthTexture);</li></ul><h3 id="CBuffer"><a href="#CBuffer" class="headerlink" title="CBuffer"></a>CBuffer</h3><p>Constant Buffer 是GPU中的一处常量缓冲区。 Unity Shader中使用CBUFFER_START和CBUFFER_END来定义缓冲区变量。<br>当前Unity内部使用的缓冲区有</p><p>UnityPerCamera<br>UnityLighting<br>UnityShadows<br>UnityPerDraw<br>UnityPerFrame<br>UnityPerMaterial<br>UnityPerObject<br>这些缓冲区是根据各自数据的刷新频率来定义的。 例如UnityPerCamera中的数据，仅在渲染的Camera发生变化时刷新。里面存的即是与Camera相关的数据。UnityPerMaterial则在材质球发生变化的时候刷新。</p><p><a href="https://github.com/wlgys8/URPLearn/wiki/CBuffer">CBuffer</a></p><h3 id="pragma-multi-compile"><a href="#pragma-multi-compile" class="headerlink" title="pragma multi_compile"></a>pragma multi_compile</h3><p>URP 支持变体 ，你可能需要某些功能 #pragma multi_compile 添加以下关键字</p><p>_MAIN_LIGHT_SHADOWS</p><p>_MAIN_LIGHT_SHADOWS_CASCADE</p><p>_ADDITIONAL_LIGHTS_VERTEX</p><p>_ADDITIONAL_LIGHTS</p><p>_ADDITIONAL_LIGHT_SHADOWS</p><p>_SHADOWS_SOFT</p><p>_MIXED_LIGHTING_SUBTRACTIVE</p><p><a href="https://www.bilibili.com/read/cv7359952/">https://www.bilibili.com/read/cv7359952/</a></p>]]></content>
    
    
    <summary type="html">URP一些特殊功能使用说明</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="URP" scheme="https://skierhou.github.io/categories/Unity/URP/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="URP" scheme="https://skierhou.github.io/tags/URP/"/>
    
  </entry>
  
  <entry>
    <title>ComputeShader学习</title>
    <link href="https://skierhou.github.io/2021/11/20/Graphics/URP/ComputeShader/"/>
    <id>https://skierhou.github.io/2021/11/20/Graphics/URP/ComputeShader/</id>
    <published>2021-11-20T06:30:01.000Z</published>
    <updated>2021-12-06T11:55:30.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li>Compute Shaders是在GPU运行却又在普通渲染管线之外的程序。用于运行GPGPU program。</li><li>平行算法被拆分成很多线程组，而线程组包含很多线程。例如一个线程处理一个像素点，而一定要注意这种处理是无序的随机的，并不一定是固定的处理顺序，例如不一定是从左到右挨个处理像素点。</li></ul><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>A Thread Group 运行在一个GPU单元 （A single multiprocesser）,如果GPU有16个<br>multiprocesser，那么程序至少要分成16个 Thread Group使得每个multiprocesser都参与计算。<br>组之间不分享内存。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个线程组包含n个线程，每32个thread称为一个warp（nvidia：warp=32 ,ati:wavefront=64,因此未来此数字可能会更高）。<br>从效率考虑，一个线程组包含的线程数最好的warp的倍数，256是一个比较合适的数字。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p>numthreads中定义单个线程组，这个线程组为三维线程矩阵8<em>8</em>1个线程</p></li><li><p>在外面调用computeShader.Dispath(2,2,1)，表示定义2<em>2</em>1个线程组</p></li><li><p>SV_DispatchThreadID表示当前线程Id，取值范围为(0,0,0)~(threadx<em>thread_groupx-1,thready</em>thread_groupy-1,threadz*thread_groupz-1)</p></li><li><p>因此在使用是根据实际处理图片等分辨率，来写thread以及thread_group满足SV_DispatchThreadID的xy值可以覆盖图片分辨率，这样可以做到处理每个像素<br>打个比方：图片像素为512*512，那么thread写成(8,8,1), thread_group写成(512/8,512/8,1)<br>ComputeShader如下，相当于对图片每个像素写入红色，因为Id.xy的范围在(0<del>511,0</del>511)</p></li><li><p>一维调度：<br>DispatchIndex=DispatchThreadID.x+DispatchThreadID.y<em>numthreads.x</em>Dispatch.x+DispatchThreadID.z<em>numthreads.x</em>Dispatch.x<em>numthreads.y</em>Dispatch.y</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma kernel FillWithRed</span><br><span class="line">RWTexture2D&lt; float4 &gt; res;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; numthreads中定义单个线程组，这个线程组为三维线程矩阵8*8*1个线程</span><br><span class="line">&#x2F;&#x2F; 在外面调用computeShader.Dispath(2,2,1)，表示定义2*2*1个线程组</span><br><span class="line">&#x2F;&#x2F; SV_DispatchThreadID表示当前线程Id，取值范围为(0,0,0)~(threadx*thread_groupx-1,thready*thread_groupy-1,threadz*thread_groupz-1)</span><br><span class="line">[numthreads(8,8,1)]     </span><br><span class="line">void FillWithRed (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">  res[id.xy] &#x3D; float4(1,0,0,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><ul><li><p>Shader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit&#x2F;ComputTest&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) &#x3D; (1,1,1,1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line"></span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Lighting.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _Color;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct data</span><br><span class="line">        &#123;</span><br><span class="line">            float3 position;</span><br><span class="line">            float4 color;</span><br><span class="line">        &#125;;</span><br><span class="line">        StructuredBuffer&lt;data&gt; Result;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float4 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (uint id : SV_VertexID)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex &#x3D; TransformObjectToHClip(float4(Result[id].position, 1.0));</span><br><span class="line">                o.color &#x3D; Result[id].color;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return i.color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C#</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public struct ParticleData</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 position;</span><br><span class="line">    Color color;</span><br><span class="line">&#125;</span><br><span class="line">public class ComputeTest : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public ComputeShader computeShader;</span><br><span class="line"></span><br><span class="line">    ParticleData[] particleDatas;</span><br><span class="line"></span><br><span class="line">    public int count &#x3D; 64;</span><br><span class="line">    public Color color;</span><br><span class="line">    public int size &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    public Material material;</span><br><span class="line"></span><br><span class="line">    private ComputeBuffer ComputeBuffer;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        int vec3Stride &#x3D; sizeof(float) * 3;</span><br><span class="line">        int colorStride &#x3D; sizeof(float) * 4;</span><br><span class="line">        ComputeBuffer &#x3D; new ComputeBuffer(count, vec3Stride + colorStride);</span><br><span class="line">        id &#x3D; computeShader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        particleDatas &#x3D; new ParticleData[count];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            particleDatas[i] &#x3D; new ParticleData();</span><br><span class="line">        &#125;</span><br><span class="line">        ComputeBuffer.SetData(particleDatas);</span><br><span class="line">        computeShader.SetBuffer(id, &quot;Result&quot;, ComputeBuffer);</span><br><span class="line">        material.SetBuffer(&quot;Result&quot;, ComputeBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Update is called once per frame</span><br><span class="line">    void OnRenderObject()</span><br><span class="line">    &#123;</span><br><span class="line">        computeShader.SetFloat(&quot;time&quot;, Time.time);</span><br><span class="line">        computeShader.SetFloat(&quot;size&quot;, size);</span><br><span class="line">        computeShader.SetVector(&quot;color&quot;, color);</span><br><span class="line">        computeShader.SetVector(&quot;_threadGroup&quot;, new Vector3(10, 10, 100));</span><br><span class="line">        computeShader.Dispatch(id, 10, 10, 100);</span><br><span class="line">        material.SetPass(0);</span><br><span class="line">        Graphics.DrawProceduralNow(MeshTopology.Points, ComputeBuffer.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        ComputeBuffer.Release();</span><br><span class="line">        ComputeBuffer.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Each #kernel tells which function to compile; you can have many kernels</span><br><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float time;</span><br><span class="line">float4 color;</span><br><span class="line">float size;</span><br><span class="line">struct ParticleData</span><br><span class="line">&#123;</span><br><span class="line">    float3 position;</span><br><span class="line">    float4 color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RWStructuredBuffer&lt;ParticleData&gt; Result;</span><br><span class="line"></span><br><span class="line">float3 _threadGroup;</span><br><span class="line"></span><br><span class="line">[numthreads(10,10,10)]</span><br><span class="line">void CSMain (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int DispatchIndex &#x3D; id.x + (id.y * 10 * _threadGroup.x) + (id.z * 10 * 10 * _threadGroup.x * _threadGroup.y); &#x2F;&#x2F; x*x, x*y*x*y</span><br><span class="line"></span><br><span class="line">    ParticleData data &#x3D; Result[DispatchIndex];</span><br><span class="line">    data.color &#x3D; color;</span><br><span class="line">    data.position &#x3D; float3(size * sin(DispatchIndex + time), DispatchIndex * 0.002,size * cos(DispatchIndex + time));</span><br><span class="line">    data.position.xy *&#x3D; abs(sin(data.position.y + time * 0.3));</span><br><span class="line">    Result[DispatchIndex] &#x3D; data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>只要有涉及大量数据的处理都可以放在ComputeShader中计算</p><ul><li>Unity新版VFX</li><li>布料/头发模拟</li><li>光追</li><li>后处理</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/170615063">Compute Shader介绍（一）</a><br><a href="https://zhuanlan.zhihu.com/p/177018035">Compute Shader介绍（二）</a><br><a href="https://blog.csdn.net/qq_34980278/article/details/86541671">初识ComputeShader</a><br><a href="http://blog.sina.com.cn/s/blog_471132920102w97k.html">Shader第二十八讲 Compute Shaders</a></p>]]></content>
    
    
    <summary type="html">ComputeShader学习</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="ComputeShader" scheme="https://skierhou.github.io/tags/ComputeShader/"/>
    
  </entry>
  
  <entry>
    <title>URP 后处理效果实现</title>
    <link href="https://skierhou.github.io/2021/11/20/Graphics/URP/%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C%E6%B1%87%E6%80%BB/"/>
    <id>https://skierhou.github.io/2021/11/20/Graphics/URP/%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C%E6%B1%87%E6%80%BB/</id>
    <published>2021-11-20T06:30:01.000Z</published>
    <updated>2021-12-09T09:09:27.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blur-模糊"><a href="#Blur-模糊" class="headerlink" title="Blur 模糊"></a>Blur 模糊</h1><p><a href="https://github.com/wlgys8/URPLearn/tree/master/Assets/URPLearn/Blur">URPLearn/Blur</a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>图形处理中有一个基础概念: 卷积核(kernel).<br>kernel是矩阵形式的存在，一个3x3的kernel，3称作KernelSize，将其作用与(x,y)位置的像素，等效于采集(x,y)周围3x3范围的像素值，分别与a ~ i进行加权平均运算。<br>不同的模糊算法，实质上就是取不同的卷积核。</p><h2 id="Box-Blur-均值模糊"><a href="#Box-Blur-均值模糊" class="headerlink" title="Box Blur 均值模糊"></a>Box Blur 均值模糊</h2><p>均值模糊。 即取指定大小(size * size)范围内的像素，相加后取平均值。</p><figure class="highlight plain"><figcaption><span>性能：n * n</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">half4 BoxBlur(Texture2D tex, float2 pixelCoord, float halfKernelSize)&#123;</span><br><span class="line">    half4 color &#x3D; half4(0,0,0,1);</span><br><span class="line">    int kernelSize &#x3D; 2 * halfKernelSize + 1;</span><br><span class="line">    float weight &#x3D; rcp(kernelSize * kernelSize);</span><br><span class="line">    for(int i &#x3D;  -halfKernelSize ; i &lt;&#x3D; halfKernelSize ; i ++)&#123;</span><br><span class="line">        for(int j &#x3D;  -halfKernelSize ; j &lt;&#x3D; halfKernelSize ; j ++)&#123;</span><br><span class="line">            color +&#x3D; LOAD_TEXTURE2D_X(tex,pixelCoord + float2(i,j)) * weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return color ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>性能：2 * n</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">half4 BoxBlur(Texture2D tex, float2 pixelCoord, float halfKernelSize, float2 offset) &#123;</span><br><span class="line">    half4 color &#x3D; half4(0, 0, 0, 1);</span><br><span class="line">    float weight &#x3D; rcp(2 * halfKernelSize + 1);</span><br><span class="line">    for (int i &#x3D; -halfKernelSize; i &lt;&#x3D; halfKernelSize; i++) &#123;</span><br><span class="line">        color +&#x3D; LOAD_TEXTURE2D_X(tex, pixelCoord + offset * i) * weight;</span><br><span class="line">    &#125;</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 水平采样</span><br><span class="line">half4 BoxBlurH(Texture2D tex, float2 pixelCoord, int halfKernelSize, float radiusScale) &#123;</span><br><span class="line">    return BoxBlur(tex, pixelCoord, halfKernelSize, float2(radiusScale, 0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 垂直采样</span><br><span class="line">half4 BoxBlurV(Texture2D tex, float2 pixelCoord, int halfKernelSize, float radiusScale) &#123;</span><br><span class="line">    return BoxBlur(tex, pixelCoord, halfKernelSize, float2(0, radiusScale));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>性能：n + 1  ， 思想：中心点往左右两边采样，一次循环采样2次</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">half4 BoxBlurBilinear(Texture2D tex, sampler linearSampler, float2 uv, int halfKernelSize, float2 offset) &#123;</span><br><span class="line">    half4 color &#x3D; half4(0, 0, 0, 1);</span><br><span class="line">    float weight &#x3D; rcp(halfKernelSize * 2 + 1);</span><br><span class="line">    if (halfKernelSize % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;even</span><br><span class="line">        color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv) * weight;</span><br><span class="line">        int quartKernelSize &#x3D; floor(halfKernelSize &#x2F; 2);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; quartKernelSize; i++) &#123;</span><br><span class="line">            float uvOffset &#x3D; (i * 2 - 0.5);</span><br><span class="line">            color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv + offset * uvOffset) * 2 * weight;</span><br><span class="line">            color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv - offset * uvOffset) * 2 * weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; &#x2F;&#x2F;odd</span><br><span class="line">        color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv + 0.75 * offset) * 1.5 * weight;</span><br><span class="line">        color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv - 0.75 * offset) * 1.5 * weight;</span><br><span class="line">        int quartKernelSize &#x3D; floor((halfKernelSize - 1) &#x2F; 2);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; quartKernelSize; i++) &#123;</span><br><span class="line">            float uvOffset &#x3D; (i * 2 + 0.5);</span><br><span class="line">            color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv + offset * uvOffset) * 2 * weight;</span><br><span class="line">            color +&#x3D; SAMPLE_TEXTURE2D_X(tex, linearSampler, uv - offset * uvOffset) * 2 * weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define BOX_BLUR_BILINEAR(tex,uv,halfKernelSize,offset) BoxBlurBilinear(tex,sampler_LinearClamp,uv,halfKernelSize,offset)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 水平采样 在水平模糊Pass时，令offset &#x3D; (1 &#x2F; textureWidth, 0);</span><br><span class="line">float4 FragH(Varyings i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    #if _BilinearMode</span><br><span class="line">    return BOX_BLUR_BILINEAR(_MainTex,i.uv,_KernelSize,float2(_BlurScale,0) * _MainTex_TexelSize.xy);</span><br><span class="line">    #else</span><br><span class="line">    return BoxBlur(_MainTex,i.uv * _MainTex_TexelSize.zw,_KernelSize,float2(_BlurScale,0));</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 垂直采样 在垂直模糊Pass时，令offset &#x3D; (0, 1 &#x2F; textureHeight);</span><br><span class="line">float4 FragV(Varyings i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    #if _BilinearMode</span><br><span class="line">    return BOX_BLUR_BILINEAR(_MainTex,i.uv,_KernelSize,float2(0,_BlurScale) * _MainTex_TexelSize.xy);</span><br><span class="line">    #else</span><br><span class="line">    return BoxBlur(_MainTex,i.uv * _MainTex_TexelSize.zw,_KernelSize,float2(0,_BlurScale));</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gaussian-Blur-高斯模糊"><a href="#Gaussian-Blur-高斯模糊" class="headerlink" title="Gaussian Blur 高斯模糊"></a>Gaussian Blur 高斯模糊</h2><p>不同于均值模糊，高斯模糊使用正态分布来为周围的像素分配权重。<br>这里有一个网站，可以计算高斯模糊采用的卷积核: <a href="https://dev.theomader.com/gaussian-kernel-calculator/">gaussian-kernel-calculator</a><br>要确定一个高斯卷积核，需要提供两个参数: sigma 和 kernelSize<br>kernelSize我们前面已经说了，sigma则是正态分布公式中的标准差。sigma的值越小，正态分布曲线越尖锐，反之则越平坦。<br>因此，对于固定kernelSize的高斯模糊算子，取的sigma越大，则结果越模糊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;kernel size &#x3D; 7,sigma &#x3D; 1</span><br><span class="line">half4 GaussianBlur7Tap(Texture2D tex, float2 pixelCoord, float2 offset) &#123;</span><br><span class="line">    half4 color &#x3D; half4(0, 0, 0, 0);</span><br><span class="line">    color +&#x3D; 0.383103 * LOAD_TEXTURE2D_X(tex, pixelCoord);</span><br><span class="line">    color +&#x3D; 0.241843 * LOAD_TEXTURE2D_X(tex, pixelCoord + offset);</span><br><span class="line">    color +&#x3D; 0.241843 * LOAD_TEXTURE2D_X(tex, pixelCoord - offset);</span><br><span class="line">    color +&#x3D; 0.060626 * LOAD_TEXTURE2D_X(tex, pixelCoord + offset * 2);</span><br><span class="line">    color +&#x3D; 0.060626 * LOAD_TEXTURE2D_X(tex, pixelCoord - offset * 2);</span><br><span class="line">    color +&#x3D; 0.00598 * LOAD_TEXTURE2D_X(tex, pixelCoord + offset * 3);</span><br><span class="line">    color +&#x3D; 0.00598 * LOAD_TEXTURE2D_X(tex, pixelCoord - offset * 3);</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>没看懂</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;kernel size &#x3D; 7,sigma &#x3D; 1</span><br><span class="line">half4 GaussianBlur7TapBilinear(Texture2D tex, sampler texSampler, float2 uv, float2 offset) &#123;</span><br><span class="line">    half4 color &#x3D; half4(0, 0, 0, 0);</span><br><span class="line">    color +&#x3D; 0.4333945 * SAMPLE_TEXTURE2D_X(tex, texSampler, uv + offset * 0.558020);</span><br><span class="line">    color +&#x3D; 0.4333945 * SAMPLE_TEXTURE2D_X(tex, texSampler, uv - offset * 0.558020);</span><br><span class="line">    color +&#x3D; 0.066606 * SAMPLE_TEXTURE2D_X(tex, texSampler, uv + offset * 2.089782);</span><br><span class="line">    color +&#x3D; 0.066606 * SAMPLE_TEXTURE2D_X(tex, texSampler, uv - offset * 2.089782);</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line">#define GAUSSIAN_BLUR_7TAP_BILINEAR(tex,uv,offset) GaussianBlur7TapBilinear(tex,sampler_LinearClamp,uv,offset)</span><br></pre></td></tr></table></figure><h1 id="Bloom-全屏泛光"><a href="#Bloom-全屏泛光" class="headerlink" title="Bloom 全屏泛光"></a>Bloom 全屏泛光</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><p>让超过一定亮度的像素点变的更亮，并向四周扩散。<br>实现原理：</p><ol><li>拿到源RT，进行过滤，过滤规则可以颜色值大于一定阈值就写入，小于则不写入，得到BloomRT</li><li>BloomRT进行模糊操作(向四周扩散)</li><li>将BloomRT叠加到源RT上(合并)</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">namespace URPLearn</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 全屏泛光</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1.降采样</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 2.高斯模糊</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 3.颜色叠加</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 参数：threshold(阈值)，Intensity(强度)，Scatter(散射)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    [CreateAssetMenu(menuName &#x3D; &quot;URPLearn&#x2F;Bloom&quot;)]</span><br><span class="line">    public class Bloom : PostProcessingEffect</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Shader</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public Shader shader;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 阈值</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        [Range(0, 1)]</span><br><span class="line">        public float threshold;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 降采样</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        [Range(1, 4)]</span><br><span class="line">        public int downSample &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 模糊次数</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        [Range(1, 10)]</span><br><span class="line">        public int blurIterations &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 强度</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public float intensity;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 散射</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;121</span><br><span class="line">        public float scatter;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 颜色</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public Color tint;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 材质</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private Material _material;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 模糊处理</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private BlurBlitter _blurBlitter &#x3D; new BlurBlitter();</span><br><span class="line"></span><br><span class="line">        public override void Render(CommandBuffer cmd, ref RenderingData renderingData, PostProcessingRenderContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!shader)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (_material &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                _material &#x3D; new Material(shader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _material.SetFloat(&quot;_Threshold&quot;, threshold);</span><br><span class="line">            _material.SetColor(&quot;_Tint&quot;, tint);</span><br><span class="line">            _material.SetFloat(&quot;_Intensity&quot;, intensity);</span><br><span class="line"></span><br><span class="line">            var descriptor &#x3D; context.sourceRenderTextureDescriptor;</span><br><span class="line"></span><br><span class="line">            var temp1 &#x3D; context.GetTemporaryRT(cmd, descriptor, FilterMode.Bilinear);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;first pass，提取光亮部分</span><br><span class="line">            cmd.Blit(context.activeRenderTarget, temp1, _material, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;模糊处理</span><br><span class="line">            _blurBlitter.SetSource(temp1, descriptor);</span><br><span class="line"></span><br><span class="line">            _blurBlitter.downSample &#x3D; downSample;</span><br><span class="line">            _blurBlitter.iteratorCount &#x3D; blurIterations;</span><br><span class="line">            _blurBlitter.blurType &#x3D; BlurType.Box;</span><br><span class="line"></span><br><span class="line">            _blurBlitter.Render(cmd);</span><br><span class="line"></span><br><span class="line">            cmd.SetGlobalTexture(&quot;_BloomTex&quot;, temp1);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;combine</span><br><span class="line">            context.BlitAndSwap(cmd, _material, 3);</span><br><span class="line"></span><br><span class="line">            context.ReleaseTemporaryRT(cmd, temp1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;URPLearn&#x2F;PostProcessing&#x2F;Bloom&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line">        &#x2F;&#x2F; 宏定义 Material.EnableKeyword</span><br><span class="line">        #pragma shader_feature _BloomDebug</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Common.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Filtering.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Input.hlsl&quot;</span><br><span class="line">        #include &quot;..&#x2F;Blur&#x2F;Blur.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 源RT</span><br><span class="line">        TEXTURE2D_X(_MainTex);</span><br><span class="line">        SAMPLER(sampler_MainTex);</span><br><span class="line">        &#x2F;&#x2F; BloomRT</span><br><span class="line">        TEXTURE2D_X(_BloomTex);</span><br><span class="line">        SAMPLER(sampler_BloomTex);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_TexelSize;</span><br><span class="line">        float4 _Tint;</span><br><span class="line">        float _Threshold;</span><br><span class="line">        float _Intensity;</span><br><span class="line">        float _KernelSize;</span><br><span class="line">        float _BlurScale;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS   : POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        float4 SampleColor(float2 uv) &#123;</span><br><span class="line">            return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes input)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings output;</span><br><span class="line">            UNITY_SETUP_INSTANCE_ID(input);                 &#x2F;&#x2F;为支持GPUInstance？</span><br><span class="line">            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);  &#x2F;&#x2F;將output变量初始化</span><br><span class="line">            output.positionHS &#x3D; TransformObjectToHClip(input.positionOS);   &#x2F;&#x2F;模型空间变化到齐次裁剪空间</span><br><span class="line">            output.uv &#x3D; input.uv;</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; 通过阈值获取高亮区域</span><br><span class="line">        float4 FragGetLight(Varyings i) :SV_Target&#123;</span><br><span class="line">            float4 color &#x3D; SampleColor(i.uv);</span><br><span class="line">            float luminance &#x3D; dot(float3(0.299,0.587,0.114),color.rgb);</span><br><span class="line">            return color * clamp(luminance - _Threshold, 0, 1) * _Intensity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F;水平blur</span><br><span class="line">        float4 FragBlurH(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            return GaussianBlur7Tap(_MainTex,i.uv * _MainTex_TexelSize.zw, float2(_BlurScale,0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;垂直blur</span><br><span class="line">        float4 FragBlurV(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            return GaussianBlur7Tap(_MainTex,i.uv * _MainTex_TexelSize.zw, float2(0,_BlurScale));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;颜色叠加</span><br><span class="line">        float4 Bloom(Varyings i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            return SampleColor(i.uv) + SAMPLE_TEXTURE2D_X(_BloomTex, sampler_BloomTex, i.uv) * _Tint;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDHLSL</span><br><span class="line">            </span><br><span class="line">        Pass&#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragGetLight</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragBlurH</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragBlurV</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment Bloom</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>float luminance = dot(float3(0.299,0.587,0.114),color.rgb); // 计算像素的亮度值，中间的参数可以按自己的来，总和等于1即可</li></ol><h1 id="Depth-Of-Field-景深"><a href="#Depth-Of-Field-景深" class="headerlink" title="Depth Of Field 景深"></a>Depth Of Field 景深</h1><p><a href="https://github.com/wlgys8/URPLearn/tree/master/Assets/URPLearn/DepthOfField">Depth Of Field</a></p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>景深效果产生的本质原因，是相机的对焦和散焦机制。而其背后的光学原理，则是透镜成像。<br>根据凸透镜高斯成像公式:<br>1/f = 1/u + 1/v<br>f: 焦距 - 由凸透镜本身决定<br>v: 物距 - 物体到凸透镜的距离<br>u: 像距 - 物体经过凸透镜后，成像位置与镜片的距离.</p><p>当物体通过凸透镜形成的象距正好在胶片位置时，那么我们就能得到一个清晰的成像。反之，象距和胶片差距越大，成像越模糊。</p><h2 id="整理下运算公式"><a href="#整理下运算公式" class="headerlink" title="整理下运算公式"></a>整理下运算公式</h2><p>对应URP Mode = Bokeh<br>准备一下，输入参数有:</p><p>focalLength 胶片到镜片的距离 (胶距)<br>focusDistance 对焦距离 (物距)<br>aperture 光圈参数 (定义为 镜片焦距/镜片直径)<br>运算符号:</p><p>rcp 为倒数运算<br>那么有:</p><p>焦距公式</p><p>f = rcp(rcp(focalLength) + rcp(focusDistance))<br>镜片直径:</p><p>lensDiam = f * rcp(aperture)<br>根据物距计算像距:</p><p>输入参数:<br>    objDis<br>输出:<br>    imageDis = rcp(rcp(f) - rcp(objDis));<br>根据物距，计算弥散圆直径(CoC):</p><p>输入参数:<br>    objDis</p><p>输出:<br>    imageDis = CalculateImageDistance(objDis);<br>    CoC = abs(imageDis - focalLength) * lensDiam  / focalLength ;</p><p>输入参数：<br>    depth<br>    focalLength<br>输出：<br>    objDis = depth - focalLength</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering;</span><br><span class="line">using UnityEngine.Rendering.Universal;</span><br><span class="line"></span><br><span class="line">namespace URPLearn</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 景深</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 对应URP PPS中DOF的Bokeh模式</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    [CreateAssetMenu(menuName &#x3D; &quot;URPLearn&#x2F;DepthOfField&quot;)]</span><br><span class="line">    public class DepthOfField : PostProcessingEffect</span><br><span class="line">    &#123;</span><br><span class="line">        [Tooltip(&quot;相机对焦的物距，单位m，在公式中记为u&quot;)]</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float _focusDistance &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        [Tooltip(&quot;相机的焦距(这里其实应该是成像胶片到镜头的距离),单位毫米，在公式中记为v&quot;)]</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float _focalLength;</span><br><span class="line"></span><br><span class="line">        [Tooltip(&quot;相机的光圈值F &#x3D; f &#x2F; 镜片直径&quot;)]</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float _aperture &#x3D; 6.3f;</span><br><span class="line"></span><br><span class="line">        [Tooltip(&quot;Blur迭代次数，对性能有影响&quot;)]</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private int _blurIteratorCount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        [SerializeField]</span><br><span class="line">        private Shader _shader;</span><br><span class="line"></span><br><span class="line">        private Material _material;</span><br><span class="line"></span><br><span class="line">        private void OnValidate()</span><br><span class="line">        &#123;</span><br><span class="line">            _aperture &#x3D; Mathf.Clamp(_aperture, 1, 32);</span><br><span class="line">            _focalLength &#x3D; Mathf.Clamp(_focalLength, 1, 300);</span><br><span class="line">            _focusDistance &#x3D; Mathf.Max(_focusDistance, 0.1f);</span><br><span class="line">            _blurIteratorCount &#x3D; Mathf.Clamp(_blurIteratorCount, 1, 5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 焦距倒数</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private float rcpf</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return (0.001f &#x2F; _focusDistance + 1 &#x2F; _focalLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 计算成像距离</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private float CalculateImageDistance(float objDis)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1 &#x2F; (rcpf - 0.001f &#x2F; objDis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 计算弥散圆直径</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private float CalculateConfusionCircleDiam(float objDis)</span><br><span class="line">        &#123;</span><br><span class="line">            var imageDis &#x3D; CalculateImageDistance(objDis);</span><br><span class="line">            return Mathf.Abs(imageDis - _focalLength) &#x2F; (_focalLength * rcpf * _aperture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 光圈直径</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        private float apertureDiam</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return (1 &#x2F; (rcpf * _aperture));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Render(CommandBuffer cmd, ref RenderingData renderingData, PostProcessingRenderContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_shader &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (_material &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                _material &#x3D; new Material(_shader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var DOFParams &#x3D; new Vector4(</span><br><span class="line">                rcpf,</span><br><span class="line">                _focalLength,</span><br><span class="line">                1 &#x2F; (_focalLength * rcpf * _aperture),</span><br><span class="line">                0</span><br><span class="line">            );</span><br><span class="line">            _material.SetVector(&quot;_DOFParams&quot;, DOFParams);</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; _blurIteratorCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                context.BlitAndSwap(cmd, _material, 0);</span><br><span class="line">                context.BlitAndSwap(cmd, _material, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;URPLearn&#x2F;PostProcessing&#x2F;DepthOfField&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        ZTest Always ZWrite Off Cull Off</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; &#x3D; &quot;Opaque&quot; &quot;RenderPipeline&quot; &#x3D; &quot;UniversalPipeline&quot;&#125;</span><br><span class="line">        HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Common.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.core&#x2F;ShaderLibrary&#x2F;Filtering.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Core.hlsl&quot;</span><br><span class="line">        #include &quot;Packages&#x2F;com.unity.render-pipelines.universal&#x2F;ShaderLibrary&#x2F;Input.hlsl&quot;</span><br><span class="line">        #include &quot;..&#x2F;Blur&#x2F;Blur.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D_X(_MainTex);</span><br><span class="line">        TEXTURE2D_X_FLOAT(_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">        CBUFFER_START(UnityPerMaterial)</span><br><span class="line">        float4 _MainTex_TexelSize;</span><br><span class="line">        float4 _DOFParams;</span><br><span class="line">        CBUFFER_END</span><br><span class="line"></span><br><span class="line">        #define rcpF _DOFParams.x</span><br><span class="line">        #define focalLength _DOFParams.y</span><br><span class="line">        #define rcpFFA _DOFParams.z &#x2F;&#x2F; rcp(_focalLength * rcpf * _aperture)</span><br><span class="line"></span><br><span class="line">        struct Attributes</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionOS   : POSITION;</span><br><span class="line">            float2 uv           : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct Varyings</span><br><span class="line">        &#123;</span><br><span class="line">            float4 positionHS    : SV_POSITION;</span><br><span class="line">            float2 uv            : TEXCOORD0;</span><br><span class="line">            UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Varyings Vert(Attributes input)</span><br><span class="line">        &#123;</span><br><span class="line">            Varyings output;</span><br><span class="line">            UNITY_SETUP_INSTANCE_ID(input);                 &#x2F;&#x2F;为支持GPUInstance？</span><br><span class="line">            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);  &#x2F;&#x2F;將output变量初始化</span><br><span class="line">            output.positionHS &#x3D; TransformObjectToHClip(input.positionOS);   &#x2F;&#x2F;模型空间变化到齐次裁剪空间</span><br><span class="line">            output.uv &#x3D; input.uv;</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 采样深度</span><br><span class="line">        float SampleDepth(float2 uv) &#123;</span><br><span class="line">            return LOAD_TEXTURE2D_X(_CameraDepthTexture, _MainTex_TexelSize.zw * uv).x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 线性深度</span><br><span class="line">        float SampleEyeLinearDepth(float2 uv) &#123;</span><br><span class="line">            return LinearEyeDepth(SampleDepth(uv), _ZBufferParams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;计算像距</span><br><span class="line">        float4 CalculateImageDistance(float objDis) &#123;</span><br><span class="line">            return rcp(rcpF - rcp(objDis));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;弥散圆直径</span><br><span class="line">        float CalculateConfusionCircleDiam(float objDis) &#123;</span><br><span class="line">            float imageDis &#x3D; CalculateImageDistance(objDis);</span><br><span class="line">            return abs(imageDis - focalLength) * rcpFFA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float CalculateBlurFactor(float2 uv)</span><br><span class="line">        &#123;</span><br><span class="line">            float depth &#x3D; SampleEyeLinearDepth(uv);     &#x2F;&#x2F; Depth大小为m</span><br><span class="line">            float objDis &#x3D; 1000 * depth - focalLength;  &#x2F;&#x2F; 传入的focalLength为mm</span><br><span class="line">            float diam &#x3D; CalculateConfusionCircleDiam(objDis);</span><br><span class="line">            return diam;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 FragH(Varyings i) :SV_Target&#123;</span><br><span class="line">            float factor &#x3D; CalculateBlurFactor(i.uv);</span><br><span class="line">            return BoxBlur(_MainTex, i.uv * _MainTex_TexelSize.zw, 2, float2(factor, 0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        float4 FragV(Varyings i) : SV_Target&#123;</span><br><span class="line">            float factor &#x3D; CalculateBlurFactor(i.uv);</span><br><span class="line">            return BoxBlur(_MainTex, i.uv * _MainTex_TexelSize.zw, 2, float2(0, factor));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDHLSL</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragH</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            #pragma vertex Vert</span><br><span class="line">            #pragma fragment FragV</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>学习各类效果前，需要先清楚其效果原理，大问题拆分成多个小问题，一个个问题对症下药的去解决<br>目前对于基础原理也不懂，只会直接套公式</p><h1 id="SSAO-屏幕空间环境光遮蔽"><a href="#SSAO-屏幕空间环境光遮蔽" class="headerlink" title="SSAO 屏幕空间环境光遮蔽"></a>SSAO 屏幕空间环境光遮蔽</h1><h2 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h2><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <summary type="html">URP 后处理效果实现汇总</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/categories/Unity/Shader/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>SRP学习汇总</title>
    <link href="https://skierhou.github.io/2021/08/25/Graphics/SRP%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>https://skierhou.github.io/2021/08/25/Graphics/SRP%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/</id>
    <published>2021-08-24T16:00:00.000Z</published>
    <updated>2021-10-28T02:26:10.648Z</updated>
    
    
    <summary type="html">SRP学习汇总</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/categories/Unity/Shader/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>BuildInShader学习汇总</title>
    <link href="https://skierhou.github.io/2021/08/25/Graphics/BuildInShader%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
    <id>https://skierhou.github.io/2021/08/25/Graphics/BuildInShader%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/</id>
    <published>2021-08-24T16:00:00.000Z</published>
    <updated>2021-11-02T06:09:09.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <summary type="html">BuildInShader学习汇总</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/categories/Unity/Shader/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="Shader" scheme="https://skierhou.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity大世界模块记录</title>
    <link href="https://skierhou.github.io/2021/08/23/Graphics/Unity%E5%A4%A7%E4%B8%96%E7%95%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95/"/>
    <id>https://skierhou.github.io/2021/08/23/Graphics/Unity%E5%A4%A7%E4%B8%96%E7%95%8C%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95/</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2021-08-23T07:58:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地形分割-场景分割-异步加载"><a href="#地形分割-场景分割-异步加载" class="headerlink" title="地形分割/场景分割/异步加载"></a>地形分割/场景分割/异步加载</h1><ol><li>Terrian分割，一个地形块 = 一个场景，</li><li>场景异步加载卸载</li><li>场景物体的加载卸载</li><li>多场景编辑操作</li></ol><p>目前工作流：大世界由一个大场景(所有场景物体)分割</p><h1 id="光照烘培"><a href="#光照烘培" class="headerlink" title="光照烘培"></a>光照烘培</h1><ol><li><p>Terrian光照信息烘培以及正确加载</p></li><li><p>场景物体光照信息烘培以及正确加载</p></li><li><p>烘培完大场景的Lightmap后，再将光照贴图打包，记录每张贴图</p></li><li><p>运行时动态设置当前lightmap以及刷新场景物体的Lightmap数据</p></li><li><p>静态物体合批操作</p></li><li><p>静态合批：会增加包体以及内存大小，不考虑使用，<br>动态合批：限制过多也不考虑使用，</p></li></ol><p>GPUInstacing：减少DC，使用CommandBuffer.DrawMeshInstanced更好<br>GPUinstacing光照贴图：<a href="https://www.xuanyusong.com/archives/4640">https://www.xuanyusong.com/archives/4640</a><br>优化GPUInstancing：<a href="https://www.xuanyusong.com/archives/4683">https://www.xuanyusong.com/archives/4683</a><br>BatchRendererGroup：<a href="https://zhuanlan.zhihu.com/p/105616808">https://zhuanlan.zhihu.com/p/105616808</a></p><p>SRPBatcher：不减少DC，加速CPU设置（减少SetPass Call），对于移动平台提升不是很明显，<br>SRPBatcher与GPUInstacing只能同时使用一种，GPUInstacing主要用于场景内重复的树等<br>，交互和碰撞等可以使用一个空碰撞体来实现，而SRPBatcher拥有实体，使用起来更方便<br>如果场景里Material多于5个 使用SRPBatcher会优于GPUInstacing</p><p>动态/静态合批/GPUInstancing/SRP Batcher：<a href="https://shimo.im/docs/6wk89JDtgQ6jcxjT/read">https://shimo.im/docs/6wk89JDtgQ6jcxjT/read</a></p><p>关于场景物体优化策略：</p><ol><li>GPUInstancing用于不可交互的草/树   BatchRendererGroup需要com.unity.rendering.hybrid包，官方用于DOTS渲染</li><li>SPRBatcher： SRP材质支持就行  使用它就不用管静态/动态合批了</li><li>静态合批：不使用SRP还是要用，不过目前来说用处不大，还会影响内存</li><li>动态合批：条件太多，使用不当还会造成性能下降，不用</li></ol><h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><ol><li> 光照烘培能够正常设置，其烘培的阴影也正确了</li></ol><h1 id="地形刷-不能使用内置的，很耗性能"><a href="#地形刷-不能使用内置的，很耗性能" class="headerlink" title="地形刷 不能使用内置的，很耗性能"></a>地形刷 不能使用内置的，很耗性能</h1><h1 id="地形拼接问题-接缝处插值过渡-高度-贴图等"><a href="#地形拼接问题-接缝处插值过渡-高度-贴图等" class="headerlink" title="地形拼接问题 接缝处插值过渡(高度+贴图等)"></a>地形拼接问题 接缝处插值过渡(高度+贴图等)</h1><h1 id="结合天气系统"><a href="#结合天气系统" class="headerlink" title="结合天气系统"></a>结合天气系统</h1><h1 id="项目链接"><a href="#项目链接" class="headerlink" title="项目链接"></a>项目链接</h1><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/28042244">Unity手游开发札记——2.5D大世界动态加载实战</a></li><li><a href="https://zhuanlan.zhihu.com/p/318715416">祖龙技术总监：我们是怎么做“开放世界”的？</a></li><li><a href="https://zhuanlan.zhihu.com/p/105616808">Unity大世界超多物体渲染—BatchRendererGroup</a></li><li><a href="https://zhuanlan.zhihu.com/p/300731406">Unity实现移动平台超大地形RVT</a></li><li><a href="https://zhuanlan.zhihu.com/p/306169047">Unity的RVT应用（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/332810970">Unity的RVT应用（二）地上物与地形衔接</a></li></ul>]]></content>
    
    
    <summary type="html">Unity大世界模块记录</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>渲染课程总结</title>
    <link href="https://skierhou.github.io/2021/06/07/Graphics/%E6%B8%B2%E6%9F%93%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://skierhou.github.io/2021/06/07/Graphics/%E6%B8%B2%E6%9F%93%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-07T06:30:01.000Z</published>
    <updated>2021-12-21T11:48:30.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染综述"><a href="#渲染综述" class="headerlink" title="渲染综述"></a>渲染综述</h1><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2><ul><li>线性空间：物理世界的色彩空间，如果光照强一倍，亮度也会增强一倍</li><li>伽马(Gamma)空间： 显示器用于颜色矫正，通常值为2.2，对颜色进行灰度，亮度矫正<br>打个比方，功率为50%的灰色，人眼实际感知亮度为：0.5的2.2开根 = 0.7297<br>而人眼认为的50%中灰色，实际功率为：0.5的2.2次幂 = 0.2176</li><li>sRGB色彩空间：sRGB对应的是Gamma0.45所在的空间，如储存的照片相当于对图片先进行了Gamma0.45的矫正，在显示器输出时又进行了Gamma2.2矫正<br>通常使用时，基础颜色等都勾选sRGB，如法线/粗糙度/金属度等贴图需要取消勾选sRGB</li></ul><h2 id="渲染技术术语"><a href="#渲染技术术语" class="headerlink" title="渲染技术术语"></a>渲染技术术语</h2><ul><li>坐标系：在渲染过程中需要将坐标点以及向量等在不同坐标空间转换（模型空间，齐次裁剪空间，屏幕空间，相机空间，世界空间，光源空间等）</li><li>顶点，片段，像素：模型上的顶点，片段是光栅化的产物，像素是屏幕空间像素</li><li>深度测试，蒙版测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">深度测试：</span><br><span class="line">ZTest 可取值为：Greater , GEqual , Less , LEqual , Equal , NotEqual , Always , Never , Off，默认是 LEqual，ZTest Off 等同于 ZTest Always。</span><br><span class="line">ZWrite 可取值为：On , Off，默认是 On。</span><br><span class="line">蒙版测试：</span><br><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">    Ref 1           &#x2F;&#x2F;Reference Value</span><br><span class="line">    ReadMask 255    &#x2F;&#x2F;读取的时候将该值 maskValue 与 referenceValue 和 stencilBufferValue 分别进行按位与（&amp;）操作</span><br><span class="line">    WriteMask 255   &#x2F;&#x2F;写入的时候将该值与 referenceValue 和 stencilBufferValue 分别进行按位与（&amp;）操作</span><br><span class="line">    Comp Always     &#x2F;&#x2F;拿当前参考值与像素缓存值比较</span><br><span class="line">    Pass Replace    &#x2F;&#x2F;两个测试都通过了 进行处理</span><br><span class="line">    Fail Keep       &#x2F;&#x2F;两个测试都没通过 进行处理</span><br><span class="line">    ZFail Replace   &#x2F;&#x2F;模板测试通过而深度测试没通过 进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Shader：</li></ul><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><ul><li>裁剪(Culling)：</li></ul><ol><li>对象级裁剪：类型裁剪，几何体裁剪，遮挡裁剪</li><li>顶点级裁剪：视口裁剪</li><li>像素级裁剪：EarlyZ</li></ol><ul><li>渲染物件：</li></ul><ol><li>渲染状态</li><li>材质，纹理，各种参数</li><li>渲染顺序</li></ol><ul><li>后处理(Post Processing)：对屏幕渲染结果进行加工</li></ul><h2 id="光照框架"><a href="#光照框架" class="headerlink" title="光照框架"></a>光照框架</h2><p>对于N个物体受M盏光的影响<br>框架|算法复杂度|优点|缺点<br>:–|:–|:–|:–<br>forward shading(前向渲染)|O(N*M)|实现简单，兼容性好|性能较低，光源个数限制严格<br>deffered shading(延迟渲染)|O(N+M)|支持多光源，性能较好|<br>forward+ shading(前向+渲染)|||</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>GPU：寄存器，Cache，显存 （GPU读取顺序：寄存器找不到-&gt;Cache-&gt;显存-&gt;CPU）</li><li>带宽</li></ul><h2 id="图形API"><a href="#图形API" class="headerlink" title="图形API"></a>图形API</h2><ul><li>DirectX，OpenGL，OpenGL ES，WebGL，Vulkan，Metal</li></ul><h2 id="渲染应用方式"><a href="#渲染应用方式" class="headerlink" title="渲染应用方式"></a>渲染应用方式</h2><ul><li>离线渲染：电影，动画，烘培LightMap</li><li>实时渲染：游戏，VR</li></ul><h1 id="基础光照模型"><a href="#基础光照模型" class="headerlink" title="基础光照模型"></a>基础光照模型</h1><ul><li>Lambert：     max(0,dot(L,N))</li><li>HalfLambert： max(0,dot(L,N)) * 0.5 + 0.5</li><li>Phong：       pow(max(0,dot(reflect(-L,N), V)), Gloss)</li><li>BlinnPhong：  pow(max(0,dot(normalize(L+V), N)), Gloss)</li></ul><h1 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h1><ul><li>满足以下几点的光照模型，符合PBR模型：</li></ul><ol><li>微表面：不同材质的平面，有很多不同朝向不一的微小平面</li><li>能量守恒：出射光的总量不超过入射光的总量</li><li>反射方程：使用基于物理的BRDF(双向反射分布函数)</li></ol><ul><li><p>PBR反射方程：L(o) = f(fr(p,wi,wo) * Li(p,wi) * dot(n,wi) * dwi)</p></li><li><p>brdf方程：</p></li></ul><ol><li>fr(p,wi,wo) = k(d)*f(lambert) + K(s)*f(cook-torrance)</li><li>f(lamber) = c / Π</li><li>∫(cook-torrance) = D<em>F</em>G / (4*dot(wo,n)*dot(wi,n))</li><li>D：法线分布函数（NDF），估算微平面的整体取向，公式：a^2 / (Π * (NdotH^2) * (a^2-1) + 1)^2  （注：a表示粗糙度）</li><li>F: 菲尼尔方程，用于描述表面反射光所占比例， 公式： F0 + (1 - F0) * pos(1 - cosTheta, 5) （注：F0表示不同材质的垂直方向的反射率，直接光照中cosTheta：HdotV或HdotL，间接光照中cosTheta：NdotV）</li><li>G：几何函数，用于计算微表面，自阴影， 公式：NdotV / (NdotV(1.0 - k) + k)  （注：k由粗糙度a计算，直接光照：k=(a+1)^2 / 8， 间接光照：k=a^2 / 2）</li><li>K(d)：(1-F)*(1-metallic)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算直接光照</span><br><span class="line">half3 CalcDirectLight(half metalness, half roughness, half3 albedo, half3 F0, half3 normal, half3 viewDir, half NoV, float3 worldPos)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;准备参数</span><br><span class="line">    half3 lightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz - worldPos * _WorldSpaceLightPos0.w); &#x2F;&#x2F;获取光线方向</span><br><span class="line">    half3 halfDir &#x3D; normalize(viewDir + lightDir); &#x2F;&#x2F;计算半角方向</span><br><span class="line">    half NoL &#x3D; saturate(dot(normal, lightDir)); &#x2F;&#x2F;计算法线光线点积</span><br><span class="line">    half NoH &#x3D; saturate(dot(normal, halfDir)); &#x2F;&#x2F;计算法线半角点积</span><br><span class="line">    half HoL &#x3D; saturate(dot(halfDir, lightDir)); &#x2F;&#x2F;计算半角光线点积，同半角视线点积</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算方程参数</span><br><span class="line">    half3 F &#x3D; FresnelSchlick(HoL, F0); &#x2F;&#x2F;计算菲涅尔</span><br><span class="line">    half G &#x3D; GeometrySmith(NoV, NoL, pow(roughness + 1.0, 2) &#x2F; 8.0); &#x2F;&#x2F;计算遮挡</span><br><span class="line">    half D &#x3D; DistributionGGX(NoH, roughness * roughness); &#x2F;&#x2F;计算分布</span><br><span class="line">    half3 kD &#x3D; (1.0 - F) * (1.0 - metalness); &#x2F;&#x2F;计算漫反射系数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算直接光照结果</span><br><span class="line">    half3 directDiffuse &#x3D; kD * albedo &#x2F; BRDF_PI; &#x2F;&#x2F;计算漫反射</span><br><span class="line">    half3 directSpecular &#x3D; F * (D * G) &#x2F; (4.0 * max(NoV * NoL, EPSILSON)); &#x2F;&#x2F;计算高光</span><br><span class="line">    half3 directLightIn &#x3D; _LightColor0.rgb * BRDF_PI; &#x2F;&#x2F;获取直接光照颜色</span><br><span class="line">    return (directDiffuse + directSpecular) * NoL * directLightIn;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;菲涅尔函数</span><br><span class="line">half3 FresnelSchlick(half NoV, half3 F0)</span><br><span class="line">&#123;</span><br><span class="line">    return F0 + (1.0 - F0) * pow(1.0 - NoV, 5);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;几何函数</span><br><span class="line">half GeometrySchlickGGX(half NoV, half k)</span><br><span class="line">&#123;</span><br><span class="line">return NoV &#x2F; max(NoV * (1.0 - k) + k, EPSILSON);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;几何函数</span><br><span class="line">half GeometrySmith(half NoV, half NoL, half k)</span><br><span class="line">&#123;</span><br><span class="line">return GeometrySchlickGGX(NoV, k) * GeometrySchlickGGX(NoL, k);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;分布函数 alpha&#x3D;roughness*roughness</span><br><span class="line">half DistributionGGX(half NoH, half alpha)</span><br><span class="line">&#123;</span><br><span class="line">    half a2 &#x3D; alpha * alpha;</span><br><span class="line">    half denom &#x3D; pow2(NoH * NoH * (a2 - 1.0) + 1.0);</span><br><span class="line">return a2 &#x2F; max(denom * BRDF_PI, EPSILSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>IBL间接光照</li></ul><ol><li>CubeMap IrradianceMap 或者ShadeSH9() 计算间接光照的diffuse</li><li>预高光积分图，或者高光积分算法计算间接光照的specular</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算间接光照</span><br><span class="line">half3 CalcIndirectLight(half metalness, half roughness, half3 albedo, half3 F0, half3 normal, half3 viewDir, half NoV)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;准备参数</span><br><span class="line">    half3 F &#x3D; FresnelSchlick(NoV, F0); &#x2F;&#x2F;计算菲涅尔</span><br><span class="line">    half3 kD &#x3D; (1.0 - F) * (1.0 - metalness); &#x2F;&#x2F;计算漫反射系数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算间接漫反射</span><br><span class="line">    &#x2F;&#x2F;half3 indirectDiffuse &#x3D; texCUBE(_IrradianceCube, normal).rgb;</span><br><span class="line">    half3 indirectDiffuse &#x3D; ShadeSH9(half4(normal, 1.0));</span><br><span class="line">    indirectDiffuse *&#x3D; kD * albedo;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算间接高光</span><br><span class="line">    half mip &#x3D; GetMipLevelFromRoughness(roughness); &#x2F;&#x2F;计算粗糙度对应MIP</span><br><span class="line">    half3 reflDir &#x3D; reflect(-viewDir, normal); &#x2F;&#x2F;计算视线反射方向</span><br><span class="line">    &#x2F;&#x2F;half3 indirectSpecular &#x3D; texCUBElod(_RadianceCube, half4(reflDir, mip)).rgb;</span><br><span class="line">    half4 rgbm &#x3D; UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, mip);</span><br><span class="line">    half3 indirectSpecular &#x3D; DecodeHDR(rgbm, unity_SpecCube0_HDR);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;高光积分</span><br><span class="line">#if USE_BRDF_INTEGRATION_MAP</span><br><span class="line">    half2 envBRDF &#x3D; tex2D(_BRDFIntegrationMap, half2(NoV, roughness)).rg;</span><br><span class="line">#else</span><br><span class="line">    half2 envBRDF &#x3D; IntegrateSpecularBRDF(NoV, roughness);</span><br><span class="line">#endif</span><br><span class="line">    indirectSpecular *&#x3D; F * envBRDF.x + envBRDF.y;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算间接光照结果</span><br><span class="line">    return (indirectDiffuse + indirectSpecular) * _IndirectIntensity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half2 IntegrateSpecularBRDF(half NoV, half roughness)</span><br><span class="line">&#123;</span><br><span class="line">const half4 c0 &#x3D; half4(-1, -0.0275, -0.572, 0.022);</span><br><span class="line">const half4 c1 &#x3D; half4(1, 0.0425, 1.04, -0.04);</span><br><span class="line">half4 r &#x3D; roughness * c0 + c1;</span><br><span class="line">half a004 &#x3D; min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;</span><br><span class="line">return half2(-c1.z, c1.z) * a004 + r.zw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PBR两种工作流</li></ul><ol><li>metaillic/roughness工作流（金属/粗糙度）</li><li>specular/glossness工作流（高光/光泽度）<br>区别：</li></ol><h1 id="渲染管线-1"><a href="#渲染管线-1" class="headerlink" title="渲染管线"></a>渲染管线</h1><h2 id="Bulid-in"><a href="#Bulid-in" class="headerlink" title="Bulid-in"></a>Bulid-in</h2><p>内置管线，不可自定义</p><h2 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h2><p>可编程的渲染管线</p><h2 id="URP"><a href="#URP" class="headerlink" title="URP"></a>URP</h2><p>通用渲染管线：Unity 2019.2.0版本后支持Universal Render Pipeline</p><h2 id="HDRP"><a href="#HDRP" class="headerlink" title="HDRP"></a>HDRP</h2><p>高清渲染管线</p><h2 id="LWRP"><a href="#LWRP" class="headerlink" title="LWRP"></a>LWRP</h2><p>URP的前身</p><h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><ul><li>LUT（ColorGrading） 颜色分级(调整暖色/饱和度这种)</li><li>Bloom 全屏泛光</li><li>GaussianBlur 高斯模糊</li><li>DepthOfField 景深模糊</li><li>RadialBlur 径向模糊</li></ul><h2 id="Post-ProcessStack"><a href="#Post-ProcessStack" class="headerlink" title="Post-ProcessStack"></a>Post-ProcessStack</h2><h1 id="角色渲染"><a href="#角色渲染" class="headerlink" title="角色渲染"></a>角色渲染</h1><h2 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h2><ul><li>各项异性光照</li><li>Kajiya-Kay光照模型：使用切线/副切线计算高光，高光计算两层，往法线方向偏移。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算高光值</span><br><span class="line">float StrandSpecular (float3 T, float3 V, float3 L, float p)</span><br><span class="line">&#123;</span><br><span class="line">    float3 H &#x3D; normalize(L + V);</span><br><span class="line">    float dotTH &#x3D; dot(T, H);</span><br><span class="line">    float sinTH &#x3D; sqrt(1.0 - dotTH*dotTH);</span><br><span class="line">    float dirAtten &#x3D; smoothstep(-1.0, 0.0, dotTH);</span><br><span class="line">    return dirAtten * pow(sinTH, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算偏移值 传入StrandSpecular中的T</span><br><span class="line">float3 ShiftTangent(float3 T,float3 N,float shift)</span><br><span class="line">&#123; </span><br><span class="line">    return normalize(T + shift * N); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="皮肤"><a href="#皮肤" class="headerlink" title="皮肤"></a>皮肤</h2><ul><li>次表面散射(SSS)</li></ul><h1 id="阴影渲染"><a href="#阴影渲染" class="headerlink" title="阴影渲染"></a>阴影渲染</h1><ul><li><p>标准阴影算法步骤：<br>(1) 以光源空间绘制：生成深度图<br>(2) 以相机空间绘制：将顶点坐标转换值光源空间的顶点z值得到d值<br>(3) 以顶点再光源空间的xy值为uv采样ShadowMap，获取阴影z值<br>(4) d &gt;= z 阴影内， d &lt; z阴影外</p></li><li><p>软阴影：通常使用PCF，PCSS</p></li><li><p>PCF：从目标点周围多个点做偏移采样，取平均阴影值</p></li><li><p>PCSS：</p></li><li><p>阴影失真：Shadow Acne，Peter Panning</p></li><li><p>级联阴影 Cascade Shadowmap：</p></li><li><p>ScreenSpaceShadow：</p></li><li><p>ShadowVolume：</p></li></ul><h1 id="GI"><a href="#GI" class="headerlink" title="GI"></a>GI</h1><ul><li>Ray Tracing</li><li>Path Tracing</li></ul><h1 id="Shader调试工具"><a href="#Shader调试工具" class="headerlink" title="Shader调试工具"></a>Shader调试工具</h1><h2 id="Frame-Debuger"><a href="#Frame-Debuger" class="headerlink" title="Frame Debuger"></a>Frame Debuger</h2><h2 id="Renderdoc"><a href="#Renderdoc" class="headerlink" title="Renderdoc"></a>Renderdoc</h2><h2 id="XCode"><a href="#XCode" class="headerlink" title="XCode"></a>XCode</h2><h1 id="环境效果"><a href="#环境效果" class="headerlink" title="环境效果"></a>环境效果</h1><h1 id="动画与特效"><a href="#动画与特效" class="headerlink" title="动画与特效"></a>动画与特效</h1><h1 id="NPR-Non-Photorealistic-Rendering-非真实渲染"><a href="#NPR-Non-Photorealistic-Rendering-非真实渲染" class="headerlink" title="NPR(Non Photorealistic Rendering) 非真实渲染"></a>NPR(Non Photorealistic Rendering) 非真实渲染</h1>]]></content>
    
    
    <summary type="html">渲染课程总结</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ使用</title>
    <link href="https://skierhou.github.io/2021/04/20/Service/ZeroMQ%E4%BD%BF%E7%94%A8/"/>
    <id>https://skierhou.github.io/2021/04/20/Service/ZeroMQ%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-20T06:30:01.000Z</published>
    <updated>2021-04-20T12:17:20.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZeroMQ简介"><a href="#ZeroMQ简介" class="headerlink" title="ZeroMQ简介"></a>ZeroMQ简介</h1><h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><p>ZeroMQ将消息通信分成4种模型，分别是一对一结对模型（Exclusive-Pair）、请求回应模型（Request-Reply）、发布订阅模型（Publish-Subscribe）、推拉模型（Push-Pull）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zeromq.org/languages/csharp/">官方C#</a><br><a href="https://netmq.readthedocs.io/en/latest/">官方</a><br><a href="https://github.com/NetMQ/Samples">github Samples</a><br><a href="https://www.cnblogs.com/leijiangtao/p/12016200.html">文章1</a><br><a href="https://blog.csdn.net/weixin_30618985/article/details/95884164">文章2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ZeroMQ简介&quot;&gt;&lt;a href=&quot;#ZeroMQ简介&quot; class=&quot;headerlink&quot; title=&quot;ZeroMQ简介&quot;&gt;&lt;/a&gt;ZeroMQ简介&lt;/h1&gt;&lt;h1 id=&quot;消息模型&quot;&gt;&lt;a href=&quot;#消息模型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Service" scheme="https://skierhou.github.io/categories/Service/"/>
    
    
    <category term="ZeroMQ" scheme="https://skierhou.github.io/tags/ZeroMQ/"/>
    
  </entry>
  
  <entry>
    <title>KCP使用</title>
    <link href="https://skierhou.github.io/2021/04/20/Service/KCP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/"/>
    <id>https://skierhou.github.io/2021/04/20/Service/KCP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-20T06:30:01.000Z</published>
    <updated>2021-04-25T06:27:04.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><table><thead><tr><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">ikcp_waitsnd</td><td align="left">检查等待发送的消息，如果超出最大等待大小，应该断开连接</td></tr><tr><td align="left">ikcp_recv</td><td align="left">kcp将接收到的kcp数据包还原成之前kcp发送的buffer数据</td></tr><tr><td align="left">ikcp_input</td><td align="left">kcp接收到下层协议UDP传进来的数据底层数据buffer转换成kcp的数据包格式</td></tr><tr><td align="left">ikcp_flush</td><td align="left">将发送队列中的数据通过下层协议UDP进行发送</td></tr><tr><td align="left">ikcp_send</td><td align="left">把要发送的buffer分片成KCP的数据包格式，插入待发送队列中</td></tr><tr><td align="left">ikcp_nodelay</td><td align="left"></td></tr></tbody></table><p>//nodelay:   0 不启用，1启用快速重传模式<br>//interval： 内部flush刷新时间<br>//resend:    0（默认）表示关闭。可以自己设置值，若设置为2（则2次ACK跨越将会直接重传）<br>//nc:        是否关闭拥塞控制，0（默认）代表不关闭，1代表关闭</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_36748278/article/details/80171575">文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;API介绍&quot;&gt;&lt;a href=&quot;#API介绍&quot; class=&quot;headerlink&quot; title=&quot;API介绍&quot;&gt;&lt;/a&gt;API介绍&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;表头&lt;/th&gt;
&lt;th align=&quot;left</summary>
      
    
    
    
    <category term="Service" scheme="https://skierhou.github.io/categories/Service/"/>
    
    
    <category term="KCP" scheme="https://skierhou.github.io/tags/KCP/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/OpenGL/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/OpenGL/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-03-31T05:44:17.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p><a href="https://blog.csdn.net/sigmarising/article/details/80470054">OpenGL安装教程</a><br><a href="https://www.bilibili.com/video/BV1X7411F744?from=search&seid=7915905348717479996">计算机图形学入门教程</a></p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1>]]></content>
    
    
    <summary type="html">OpenGL学习</summary>
    
    
    
    <category term="OpenGL" scheme="https://skierhou.github.io/categories/OpenGL/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="OpenGL" scheme="https://skierhou.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>UnityShader基础渲染知识点概况</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/UnityShader/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/UnityShader/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-04-25T08:56:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><h1 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h1><ol><li>“LightMode” = “ForwardBase”，</li></ol><h1 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h1><h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><h1 id="灯光设置"><a href="#灯光设置" class="headerlink" title="灯光设置"></a>灯光设置</h1><ol><li>灯光可以设置Auto/Important/UnImportant，Auto：当满足逐像素光照则为逐像素，不满足则为逐顶点，都不满足则SH处理，Important：逐像素光照，UnImportant：逐顶点光照或SH处理。</li><li>光源的Cookie：灯光照下的样子，点光源使用立方体贴图CubeMap，聚光灯使用2D贴图，使用时需要将贴图类型设置为Cookie</li><li>平行光(Directional Light)，全局平行光，</li><li>点光源(Point Light)，球形灯光，一般用SH球谐函数在ForwardBase中就算顶点光照</li><li>聚光灯(Spot Light)，锥形灯光,一般用SH球谐函数在ForwardBase中就算顶点光照</li></ol><h1 id="伽马-Gamma"><a href="#伽马-Gamma" class="headerlink" title="伽马(Gamma)"></a>伽马(Gamma)</h1><ol><li>显示器用于颜色矫正，通常值为2.2，对颜色进行灰度，亮度矫正<br>打个比方，功率为50%的灰色，人眼实际感知亮度为：0.5的2.2开根 = 0.7297<br>而人眼认为的50%中灰色，实际功率为：0.5的2.2次幂 = 0.2176</li><li>Unity中可选择的颜色空间线性空间，伽马空间。</li></ol><h1 id="常用API记录"><a href="#常用API记录" class="headerlink" title="常用API记录"></a>常用API记录</h1><table><thead><tr><th align="left">API</th><th align="left">定义</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">EnergyConservationBetweenDiffuseAndSpecular</td><td align="left">定义于UnityStandardUtils.cgine</td><td align="left">漫反射和镜面反射的能力守恒函数</td></tr><tr><td align="left">DiffuseAndSpecularFromMetallic</td><td align="left">定义于UnityStandardUtils.cgine</td><td align="left">金属性设置,其中金属性参数需要标记[Gamma]，受Gamma矫正后的参数</td></tr><tr><td align="left">UNITY_BDRP_PBS</td><td align="left">定义于UnityPBSLighting.cgine</td><td align="left">基于物理的着色，双向反射率分布函数</td></tr><tr><td align="left">UNITY_LIGHT_ATTENUATION</td><td align="left">定义于AutoLight.cginc</td><td align="left">光照衰减值</td></tr><tr><td align="left">#pragma multi_compile</td><td align="left">多重定义宏</td><td align="left">如#pragma multi_compile DIRECTIONAL POINT SPOT 可以define(..)判断哪些宏被定义了，然后执行特定的逻辑，C#处可以启用/关闭Shader宏：Shader.EnableKeyword(string);Shader.DisableKeyword(string);</td></tr><tr><td align="left">ShadeSH9</td><td align="left">UnityCG.cginc</td><td align="left">球谐函数，</td></tr><tr><td align="left">ComputeScreenPos</td><td align="left">计算屏幕坐标</td><td align="left">计算屏幕坐标：参数 顶点坐标</td></tr><tr><td align="left">COMPUTE_EYEDEPTH</td><td align="left">计算视野深度</td><td align="left">计算视野深度：参数 返回值(视野深度)</td></tr><tr><td align="left">UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture)</td><td align="left">获取相机深度图</td><td align="left">获取相机深度图</td></tr><tr><td align="left">SAMPLE_DEPTH_TEXTURE_PROJ</td><td align="left">采样深度图</td><td align="left">相当于：tex2Dproj(sampler, uv).r</td></tr><tr><td align="left">LinearEyeDepth</td><td align="left"></td><td align="left">线性视野深度0-1区间</td></tr><tr><td align="left">ddx,ddy</td><td align="left"></td><td align="left">求当前像素的值其临近像素上的变化率，分别对应x轴/y轴</td></tr></tbody></table><h1 id="常见效果实现记录"><a href="#常见效果实现记录" class="headerlink" title="常见效果实现记录"></a>常见效果实现记录</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/137429554">基础渲染系列教程20篇</a><br><a href>UnityShader入门精要</a><br><a href="https://sp4ghet.github.io/grad/">计算渐变颜色网站</a><br><a href="https://www.textures.com/library">免费材质贴图</a></p>]]></content>
    
    
    <summary type="html">UnityShader基础渲染学习与总结</summary>
    
    
    
    <category term="UnityShader" scheme="https://skierhou.github.io/categories/UnityShader/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="UnityShader" scheme="https://skierhou.github.io/tags/UnityShader/"/>
    
  </entry>
  
  <entry>
    <title>Games101作业</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/Games101%E4%BD%9C%E4%B8%9A/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/Games101%E4%BD%9C%E4%B8%9A/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-05-19T09:10:21.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Game101学习笔记"><a href="#Game101学习笔记" class="headerlink" title="Game101学习笔记"></a><a href="https://skierhou.github.io/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/">Game101学习笔记</a></h1><h1 id="作业01"><a href="#作业01" class="headerlink" title="作业01"></a>作业01</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作业01：</span><br><span class="line">本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个 点 v0(2.0,0.0,−2.0),v1(0.0,2.0,−2.0),v2(−2.0,0.0,−2.0), 你需要将这三个点的坐 标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形 (在代码框架中，我们已 经提供了 draw_triangle 函数，所以你只需要去构建变换矩阵即可)。简而言之， 我们需要进行模型、视图、投影、视口等变换来将三角形显示在屏幕上。在提供 的代码框架中，我们留下了模型变换和投影变换的部分给你去完成。 如果你对上述概念有任何不清楚或疑问，请复习课堂笔记或询问助教。 以下是你需要在 main.cpp 中修改的函数（请不要修改任何的函数名和其他 已经填写好的函数，并保证提交的代码是已经完成且能运行的）：</span><br><span class="line">• get_model_matrix(float rotation_angle): 逐个元素地构建模型变换矩 阵并返回该矩阵。在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵， 而不用处理平移与缩放。</span><br><span class="line">• get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar):使用给定的参数逐个元素地构建透视投影矩阵并返回 该矩阵。</span><br><span class="line">• [Optional] main(): 自行补充你所需的其他操作。</span><br><span class="line"></span><br><span class="line">当你在上述函数中正确地构建了模型与投影矩阵，光栅化器会创建一个窗口 显示出线框三角形。由于光栅化器是逐帧渲染与绘制的，所以你可以使用 A 和 D 键去将该三角形绕 z 轴旋转 (此处有一项提高作业，将三角形绕任意过原点的 轴旋转)。当你按下 Esc 键时，窗口会关闭且程序终止。 </span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果显示如下图：<br><img src="/blog/2021/03/31/Graphics/Games101%E4%BD%9C%E4%B8%9A/01.png" alt="作业01" title="作业01"></p><h1 id="作业02"><a href="#作业02" class="headerlink" title="作业02"></a>作业02</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作业02：</span><br><span class="line">在上次作业中，虽然我们在屏幕上画出一个线框三角形，但这看起来并不是 那么的有趣。所以这一次我们继续推进一步——在屏幕上画出一个实心三角形， 换言之，栅格化一个三角形。上一次作业中，在视口变化之后，我们调用了函数 rasterize_wireframe(const Triangle&amp; t)。但这一次，你需要自己填写并调用 函数 rasterize_triangle(const Triangle&amp; t)。</span><br><span class="line">该函数的内部工作流程如下： </span><br><span class="line">1. 创建三角形的 2 维 bounding box。 </span><br><span class="line">2. 遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中 心的屏幕空间坐标来检查中心点是否在三角形内。 </span><br><span class="line">3. 如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度 缓冲区 (depth buffer) 中的相应值进行比较。 </span><br><span class="line">4. 如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。</span><br><span class="line">你需要修改的函数如下： </span><br><span class="line">• rasterize_triangle(): 执行三角形栅格化算法 </span><br><span class="line">• static bool insideTriangle(): 测试点是否在三角形内。你可以修改此函 数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。</span><br><span class="line">因为我们只知道三角形三个顶点处的深度值，所以对于三角形内部的像素， 我们需要用插值的方法得到其深度值。我们已经为你处理好了这一部分，因为有 关这方面的内容尚未在课程中涉及。插值的深度值被储存在变量z_interpolated 中。</span><br><span class="line"></span><br><span class="line">请注意我们是如何初始化 depth buffer 和注意 z values 的符号。为了方便 同学们写代码，我们将 z 进行了反转，保证都是正数，并且越大表示离视点越远。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果显示如下图：<br><img src="/blog/2021/03/31/Graphics/Games101%E4%BD%9C%E4%B8%9A/02.png" alt="作业02" title="作业02"></p><h1 id="作业03"><a href="#作业03" class="headerlink" title="作业03"></a>作业03</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">作业03：</span><br><span class="line">在这次编程任务中，我们会进一步模拟现代图形技术。我们在代码中添加了 Object Loader(用于加载三维模型), Vertex Shader 与 Fragment Shader，并且支持 了纹理映射。 而在本次实验中，你需要完成的任务是: </span><br><span class="line">1. 修改函数 rasterize_triangle(const Triangle&amp; t) in rasterizer.cpp: 在此 处实现与作业02类似的插值算法，实现法向量、颜色、纹理颜色的插值。 </span><br><span class="line">2. 修改函数 get_projection_matrix() in main.cpp: 将你自己在之前的实验中 实现的投影矩阵填到此处，此时你可以运行.&#x2F;Rasterizer output.png normal 来观察法向量实现结果。 </span><br><span class="line">3. 修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong 模型计 算 Fragment Color. </span><br><span class="line">4. 修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的基础上，将纹理颜色视为公式中的 kd，实现 Texture Shading Fragment Shader. </span><br><span class="line">5. 修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的 基础上，仔细阅读该函数中的注释，实现 Bump mapping. </span><br><span class="line">6. 修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bump mapping 的基础上，实现 displacement mapping.</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/blog/2021/03/31/Graphics/Games101%E4%BD%9C%E4%B8%9A/03.png" alt="作业03" title="作业03"></p><h1 id="作业04"><a href="#作业04" class="headerlink" title="作业04"></a>作业04</h1><h1 id="作业05"><a href="#作业05" class="headerlink" title="作业05"></a>作业05</h1><h1 id="作业06"><a href="#作业06" class="headerlink" title="作业06"></a>作业06</h1><h1 id="作业07"><a href="#作业07" class="headerlink" title="作业07"></a>作业07</h1><h1 id="作业08"><a href="#作业08" class="headerlink" title="作业08"></a>作业08</h1><h1 id="作业09"><a href="#作业09" class="headerlink" title="作业09"></a>作业09</h1><h1 id="作业10"><a href="#作业10" class="headerlink" title="作业10"></a>作业10</h1><h1 id="作业11"><a href="#作业11" class="headerlink" title="作业11"></a>作业11</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744">GAMES101-现代计算机图形学入门-闫令琪</a></p>]]></content>
    
    
    <summary type="html">图形学基础入门 Games101作业</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Games101学习笔记</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-05-19T07:33:33.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><a href="https://skierhou.github.io/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/">矩阵向量等基础3D数学知识</a></li><li><a href="https://skierhou.github.io/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/">Games101作业</a></li></ul><h1 id="几何变换应用（几何变换的详细计算步骤）"><a href="#几何变换应用（几何变换的详细计算步骤）" class="headerlink" title="几何变换应用（几何变换的详细计算步骤）"></a>几何变换应用（几何变换的详细计算步骤）</h1><h2 id="Model-Tranform-模型变换"><a href="#Model-Tranform-模型变换" class="headerlink" title="Model Tranform(模型变换)"></a>Model Tranform(模型变换)</h2><p>在空间中摆放需要相机，模型等操作，放置模型。</p><h2 id="View-Tranform-视图变换"><a href="#View-Tranform-视图变换" class="headerlink" title="View Tranform(视图变换)"></a>View Tranform(视图变换)</h2><p>原理：将场景相机移动到坐标原点，并朝向-z方向，其他物体顶点于相机相对位置保持一致，即乘上相同的变换矩阵<br>移动相机到坐标原点需要平移+旋转矩阵，平移矩阵可以直接通过坐标得出<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.png" alt="平移矩阵" title="Tools"><br>旋转矩阵计算步骤：</p><ol><li><p>需要将原y轴旋转至(0,1,0)方向，将原z轴旋转至(0,0,-1)方向，将原x轴旋转至(1,0,0)方向</p></li><li><p>先设当前相机坐标轴表示为[X:g×t,Y:t,Z:g] (注：g×t，g叉乘t)，原点规范的坐标轴为X(1,0,0),Y(0,1,0),Z(0,0,1)。从当前旋转至规范坐标轴较为困难，但从规范坐标轴旋转至当前坐标轴非常简单，<br>求y轴旋转：M1*(0,1,0,1)=( X(t),Y(t),Z(t),1 )<br>求z轴旋转：M2*(0,0,-1,1)=( X(g),Y(g),Z(g),1 )   注：朝向-z轴<br>求x轴旋转：M3*(1,0,0,1)=( X(gxt),Y(gxt),Z(gxt),1 )<br>M1+M2+M3最终计算的旋转矩阵如下：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.png" alt="规范朝向 旋转至 相机朝向" title="Tools"></p></li><li><p>得到的旋转矩阵为：规范朝向-相机当前朝向的矩阵，我们需要求出：相机当前朝向-规范朝向的矩阵，这相当于求矩阵的逆<br>需要掌握前提条件：旋转矩阵满足一个原则，矩阵的转置=矩阵的逆。 通过转置这个矩阵得到最终旋转矩阵如下：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03.png" alt="相机朝向 旋转至 规范朝向" title="Tools"></p></li><li><p>旋转矩阵*平移矩阵即得到最终的MV矩阵</p></li></ol><h2 id="Projection-Tranform-投影变换"><a href="#Projection-Tranform-投影变换" class="headerlink" title="Projection Tranform(投影变换)"></a>Projection Tranform(投影变换)</h2><p>投影分为:正交投影(Orthographic Projection)，透视投影(Perspective Projection)。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04.png" alt="正交投影 透视投影" title="Tools"></p><h3 id="正交投影计算过程"><a href="#正交投影计算过程" class="headerlink" title="正交投影计算过程"></a>正交投影计算过程</h3><p>最终目的：将可视范围移动到x:[-1,1],y:[-1,1],z:[-1,1]的原点Cube中<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05.png" alt="正交投影过程" title="Tools"></p><ol><li>通过可视范围的中心点得到平移矩阵</li><li>由于正交投影：其可是范围为长方体，只需要通过缩放矩阵，将大小压缩到标准大小即可<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/06.png" alt="正交投影过程" title="Tools"></li></ol><h3 id="透视投影计算过程"><a href="#透视投影计算过程" class="headerlink" title="透视投影计算过程"></a>透视投影计算过程</h3><p>由于透视投影的可视范围是一个锥形，为了计算压缩成长方体，再进行正交投影，原理如下图所示，将Frustum压缩成Cuboid<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/07.png" alt="透视投影过程" title="Tools"><br>虽然只是压缩，但其中的计算过程比前面的都要复杂很多。</p><ol><li><p>拆分其变换过程，如下，近平面于原平面形成一个相似三角形<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/08.png" alt="透视投影过程" title="Tools"><br>得到变换后的x轴以及y轴值：y’ = y * n/z;  x’ = x * n/z; 而z轴暂时还不知道,得到如下变换后的坐标<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/09.png" alt="透视投影过程" title="Tools"></p></li><li><p>由第1部分求得坐标可以推算出变换矩阵的部分值：M * (x,y,z,1) = (nx,ny,unknown,z), M如下：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" alt="透视投影过程" title="Tools"></p></li><li><p>已知条件：<br>(1)所有近平面的点压缩后都保持不变<br>(2)远平面的点压缩z值不变<br>分别将其中的坐标带入矩阵计算：<br>(1) 近平面点带入： M * (x,y,n,1) = (nx,ny,n * n,n)，注释：变换后的z = n * n 于x,y不存在任何关系，因此可以得到(0,0,A,B)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" alt="透视投影过程" title="Tools"><br>(2) 远平面点带入： M * (x,y,f,1) = (unknown,unknown,f*f,f)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" alt="透视投影过程" title="Tools"><br>最终得到两条方程式：<br>(1)An + B = n * n<br>(2)Af + B = f * f<br>求解得：A = n + f；   B = -n * f</p></li></ol><p>最终其压缩矩阵如下图：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" alt="透视投影过程" title="Tools"></p><h2 id="Viewport-Tranform-视口变换"><a href="#Viewport-Tranform-视口变换" class="headerlink" title="Viewport Tranform(视口变换)"></a>Viewport Tranform(视口变换)</h2><p>原理：先定义好平面的height和width，即平面的像素比，屏幕坐标空间中左下角为(0,0)，再经过MVP变换后，当前图片所在空间为[x:[-1,1],y:[-1,1]]，需要将其大小变大，再平移至左下角到(0,0)点</p><p><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" alt="视口变换" title="Tools"></p><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><p>经过视口变换后，所有图形信息都存在屏幕空间，这时需要考虑怎么将其显示出来，这个显示的过程就是光栅化。</p><h2 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h2><p>为什么使用的是三角形？</p><ol><li>三角形是最基本的图形，</li><li>一个三角形一定在一个平面上</li><li>可以很方便计算一个点在三角形的内外，使用叉乘</li></ol><p>三角形遍历原理：遍历每个可能的像素的中心点是否在三角形内部<br>但是通过这种方式遍历后，就会出现一个问题：走样(Aliasing)，或称为锯齿<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" alt="三角形遍历" title="Tools"></p><h2 id="反走样-抗锯齿-Anti-aliasing"><a href="#反走样-抗锯齿-Anti-aliasing" class="headerlink" title="反走样(抗锯齿) (Anti-aliasing)"></a>反走样(抗锯齿) (Anti-aliasing)</h2><p>走样是怎么形成的？根本原因是采样的频率跟不上变化的频率</p><ol><li>频域(Frequency Domain)</li></ol><ul><li><p>正弦/余弦频谱<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" alt="正弦/余弦频率" title="Tools"></p></li><li><p>傅里叶变换(Fourier Transform)<br>将非常多按照公式计算的频谱相加最终会越来越趋向于方形的频谱<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" alt="傅里叶变换" title="Tools"><br>(1) 通过傅里叶变换可以将图片从 空间域转换到频域<br>(2) 通过逆傅里叶变换可以将图片从 频域转换到空间域<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png" alt="傅里叶变换" title="Tools"></p></li><li><p>频谱采样的一种特殊情况，如下图：对于两个不同频谱采样结果相同造成了走样<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.png" alt="频谱采样" title="Tools"></p></li></ul><ol start="2"><li>滤波器(Filter)<br>滤波器是针对空间域(Spatial Domain)中的图片进行卷积计算，但滤波器实际可以表示为对频域的操作。<br>如下图傅里叶变换结果：低频越趋向于白色，高频趋向于黑色，低频普遍存在于图片中心部分。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png" alt="傅里叶变换" title="Tools"></li></ol><ul><li><p>低通滤波器：低频通过，实际对频域进行低通滤波，可以达到模糊图片的效果<br>实际原理就是将频域图片的高频部分全部过滤，只有低频通过。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.png" alt="低通滤波" title="Tools"></p></li><li><p>高通滤波器：高频通过，可以达到描边的效果（高频表示图片中变化差异很大的部分,相当于是描边）<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.png" alt="高通滤波" title="Tools"></p></li></ul><ol start="3"><li><p>卷积<br>如以3x3的box对图片进行卷积，每个像素的颜色至就相当于当前像素为中心周围9个像素点按照卷积核的比例相加。<br>在空间域对图片进行卷积，相当于在频域中的两个图片的乘积，如下图验证了这一点：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.png" alt="卷积" title="Tools"></p></li><li><p>实现反走样：在三角形遍历之前先进行模糊操作，再进行三角形遍历，每个像素保持模糊后的颜色值，模糊就是使用低通滤波对像素进行卷积操作<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.png" alt="反走样" title="Tools"></p></li></ol><h2 id="深度缓存-Z-Depth-Buffer"><a href="#深度缓存-Z-Depth-Buffer" class="headerlink" title="深度缓存(Z/Depth Buffer)"></a>深度缓存(Z/Depth Buffer)</h2><p>在三角形遍历后，我们知道了所有需要渲染的三角形，现在需要考虑将它们画出来，这时需要考虑绘制三角形的先后顺序，正确的先后顺序以保证最终显示的图形是我们想要的图形，最初有一种算法油画家算法，从远到近依次绘制所有三角形，但是对于多个三角形互相穿插的问题无法得到解决，ZBuffer可以很好的规避渲染顺序问题，通过对每一个像素维护一个深度值，绘制三角形不需要考虑顺序，每次绘制时只考虑深度值是否小于缓存值，小于则绘制，大于则剔除，绘制时间复杂度只有O(N)。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.png" alt="深度缓存" title="Tools"></p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色(Shading)"></a>着色(Shading)</h1><h2 id="渲染管线-Rendering-pipeline"><a href="#渲染管线-Rendering-pipeline" class="headerlink" title="渲染管线(Rendering pipeline)"></a>渲染管线(Rendering pipeline)</h2><p>实时渲染管线的整体顺序：应用阶段-&gt;几何阶段-&gt;光栅化阶段</p><ul><li>应用阶段：</li><li>几何阶段：</li><li>光栅化阶段：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.png" alt="渲染管线" title="Tools"></li></ul><h2 id="标准着色-Lambert-Ambient-Specular"><a href="#标准着色-Lambert-Ambient-Specular" class="headerlink" title="标准着色(Lambert + Ambient + Specular)"></a>标准着色(Lambert + Ambient + Specular)</h2><ul><li>漫反射(Lambert)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/26.png" alt="渲染管线" title="Tools"></li><li>高光反射(Specular)<br>Phone和Blinn-Phone<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/27.png" alt="Phone" title="Tools"><br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/28.png" alt="Blinn-Phone" title="Tools"></li><li>环境光(Ambient)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/29.png" alt="标准着色" title="Tools"></li></ul><h2 id="重心坐标-Barycentric-Coordinates"><a href="#重心坐标-Barycentric-Coordinates" class="headerlink" title="重心坐标(Barycentric Coordinates)"></a>重心坐标(Barycentric Coordinates)</h2><p>通过三角形的重心坐标可以做到由三角形的三个顶点插值到重心坐标处的值，这个值包括可以包括任何信息(法线，颜色等)<br>同时可以扩展：三角形内的顶点 Q = a<em>P1 + b</em>P2 + c*P3， 且 a+b+c = 1 &amp;&amp; a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; c&gt;0<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.png" alt="重心坐标" title="Tools"></p><h2 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射(Texture Mapping)"></a>纹理映射(Texture Mapping)</h2><p>通过使用一张纹理图片定义不同像素处的不同值。这些值可以用来做：颜色，高度图，噪声图等等。<br>将纹理贴图的长宽定义成u,v，范围[0,1]区间方便计算。</p><h3 id="纹理贴图"><a href="#纹理贴图" class="headerlink" title="纹理贴图"></a>纹理贴图</h3><p>首先定义：一个像素在纹理中的名字叫做纹素(texel)，且一个像素内只存在同样的颜色信息<br>下面介绍纹理贴图在使用过程中遇到的问题以及如何优化</p><h4 id="当纹理图片太小"><a href="#当纹理图片太小" class="headerlink" title="当纹理图片太小"></a>当纹理图片太小</h4><ol><li>问题描述：如果需要渲染一个在屏幕上为200x200像素的网格而纹理只有100x100像素大小，这时为了达到完整的渲染会将纹理图片拉伸至200x200像素大小，拉伸后一个纹素相当于原来的4倍，然后网格通过uv读取，可以发现网格中的采样4个像素才相当于原先纹理的1个像素，这导致这些像素使用了相同的颜色信息，因此会出现模糊。</li></ol><p>解决方法：双线性插值(Bilinear Interpolation)，双立方插值(Bicubic Interpolation)</p><ol start="2"><li><p>双线性插值(Bilinear Interpolation)<br>核心思路：当采样一个点时，拿到其周围4个最近的采样坐标，拿到这4个采样像素的值，插值出当前采样点的颜色信息。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/31.png" alt="双线性插值" title="Tools"><br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/32.png" alt="双线性插值" title="Tools"></p></li><li><p>双立方插值(Bicubic Interpolation)<br>思路于双线性插值一样，只是采样点从4个增加到16个</p></li></ol><p><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.png" alt="当纹理图片太小" title="Tools"></p><h4 id="当纹理图片太大"><a href="#当纹理图片太大" class="headerlink" title="当纹理图片太大"></a>当纹理图片太大</h4><ol><li><p>问题描述：如果需要渲染一个三角形实际可能很大，但其在屏幕上占据像素为1x1px,而其纹理图片大小100x100px，进行普通采样只会获得其采样点对于的颜色，并不是我们想要的颜色，如下图可以看出摩尔纹以及锯齿(走样)问题。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/34.png" alt="当纹理图片太大" title="Tools"></p></li><li><p>在之前学习过走样形成的根本原因：采样频率低于变化频率，遇到这个问题当然可以通过超采样来避免，将1像素进行512个采样点采样，确实可以避免走样问题，采样结果如下，但是其消耗太大了：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.png" alt="超采样" title="Tools"></p></li><li><p>为什么普通点采样会出现上面的走样问题：越远的三角面在屏幕中占据的像素越少，而对于一个像素在纹理中占的范围就越大<br>这时通过点采样出来的信息一定是不满足的，采样范围的平均值反而更适合，那么怎么快速采样范围的平均值，一个新的概念使用MipMap。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36.png" alt="采样范围" title="Tools"></p></li><li><p>MipMap</p></li></ol><ul><li><p>MipMap允许做快速，近似的正方形的范围查询。</p></li><li><p>MipMap是预先生成的，从原图比例开始，每次长宽变小为原图的一半，直到像素为1x1px。</p></li><li><p>MipMap只多使用了原图的1/3的内存空间。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/37.png" alt="MipMap" title="Tools"></p></li><li><p>计算当前在MipMap中采样第几层的纹理数据<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38.png" alt="Compute MipMap" title="Tools"></p></li><li><p>三线性插值(Trilinear Interpolation)<br>在MipMap中如果得到层级在2.5层怎么正确获取颜色值？<br>同时拿到第2，3层，分别进行双线性插值，将其结果再进行一次插值。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/39.png" alt="Trilinear Interpolation" title="Tools"></p></li><li><p>MipMap处理后的效果图，出现了一个新的问题，远处过度模糊(OverBlur)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.png" alt="Trilinear Interpolation" title="Tools"></p></li></ul><ol start="5"><li>各向异性过滤(Anisotropic Filtering)<br>使用更多的内存保存更多分辨率的图片，MipMap只保存正方形大小，而各项异性过滤需要额外保存长方形的图片。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/41.png" alt="各项异性过滤" title="各项异性过滤"><br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/42.png" alt="各项异性过滤" title="各项异性过滤"><br>效果图：<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/43.png" alt="各项异性过滤" title="各项异性过滤"></li></ol><h3 id="环境贴图-Environment-Map-立方体贴图-Cube-Map"><a href="#环境贴图-Environment-Map-立方体贴图-Cube-Map" class="headerlink" title="环境贴图(Environment Map)/立方体贴图(Cube Map)"></a>环境贴图(Environment Map)/立方体贴图(Cube Map)</h3><ul><li>环境贴图：将环境反射的颜色信息存储在一个球上<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/44.png" alt="法线贴图" title="法线贴图"></li><li>立方体贴图：将环境反射信息存储在立方体上<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/45.png" alt="法线贴图" title="法线贴图"></li></ul><h3 id="法线贴图-凹凸贴图-Bump-Mapping"><a href="#法线贴图-凹凸贴图-Bump-Mapping" class="headerlink" title="法线贴图/凹凸贴图(Bump Mapping)"></a>法线贴图/凹凸贴图(Bump Mapping)</h3><ul><li><p>作用于顶点法线上，使得表面看起来有一定凹凸感</p></li><li><p>作用原理：相当于将法线贴图的信息当作顶点的偏移值，就会造成一些顶点凹，一些凸，但是并不实际作用于顶点，只是用偏移后的顶点坐标再进行法线计算，就可以得到新的法线，将这个法线用于光照即得到新的视觉效果。</p></li><li><p>二维法线计算过程：如计算n，取贴图当前坐标值以及偏移1的值的差求出dp = c * [h(p+1) - h(p)],(注：h(p)，凹凸贴图定义的是切线，通过贴图拿到值)，逆时针旋转90度求得n，如图<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/46.png" alt="法线贴图" title="法线贴图"></p></li><li><p>三维法线计算过程： 注：其h(u)，也是通过贴图直接拿到值，h:纹理高度，w:纹理宽度<br>(1) dp/du = c1 * [h(u+1/w,v) - h(u,v)]<br>(2) dp/dv = c2 * [h(u,v+1/h) - h(u,v)]<br>(3) 最终：n = (-dp/du, -dp/dv, 1)</p></li><li><p>位移法线：将贴图影响的偏移应用到顶点上，其效果更好<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47.png" alt="法线贴图" title="法线贴图"></p></li></ul><h2 id="阴影-Shadow"><a href="#阴影-Shadow" class="headerlink" title="阴影 (Shadow)"></a>阴影 (Shadow)</h2><ul><li><p>相机可以看到，而光线看不到即有阴影，如下图：相机看到的深度与光线位置看到的深度不同则说明光线被阻挡，即该点产生阴影。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/48.png" alt="阴影" title="阴影"></p></li><li><p>阴影又分为硬阴影，软阴影，硬阴影是由于将光线源当成点光源处理，而软阴影是将光源当成范围光处理。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/49.png" alt="阴影" title="阴影"></p></li></ul><h1 id="几何-Geometry"><a href="#几何-Geometry" class="headerlink" title="几何(Geometry)"></a>几何(Geometry)</h1><p>什么是几何？几何就是拥有某种空间结构的形状。</p><h2 id="几何模型"><a href="#几何模型" class="headerlink" title="几何模型"></a>几何模型</h2><ul><li>几何模型的隐式表达式，通过函数来表示一个几何模型。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.png" alt="几何模型" title="几何模型"></li><li>通过函数可以表达一些基本的几何模型如立方体，球，圆环，圆等规则的模型，但对于非常复杂的模型，使用隐式表达式几乎不现实，且不直观，因此需要显示表达来表示各种复杂模型：(三角面模型)Triangle Mesh,(贝塞尔曲面)Bezier surfaces,(点云)point clouds,(曲面细分)subdivision surfaces等等方式来表示复杂模型。</li></ul><h3 id="贝塞尔曲线-Bezier-Curves"><a href="#贝塞尔曲线-Bezier-Curves" class="headerlink" title="贝塞尔曲线 (Bézier Curves)"></a>贝塞尔曲线 (Bézier Curves)</h3><ul><li>由多个点共同决定的曲线，关于贝塞尔曲线的计算，如下图黑点左到右a,b,c,d，计算过程。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51.png" alt="贝塞尔曲线" title="贝塞尔曲线"></li><li>由于通过超多个点决定贝塞尔曲线，会由于点越来越多，越难控制，因此在实际使用时，通常使用分段式的贝塞尔曲线，将一条分成多条，方便控制。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/52.png" alt="贝塞尔曲线" title="贝塞尔曲线"></li></ul><h3 id="贝塞尔曲面-Bezier-Surfaces"><a href="#贝塞尔曲面-Bezier-Surfaces" class="headerlink" title="贝塞尔曲面 (Bézier Surfaces)"></a>贝塞尔曲面 (Bézier Surfaces)</h3><ul><li>由多个点共同决定的曲面，计算过程描述，如图4x4的曲面，对4条边做贝塞尔曲线，取4条边的值再做一次贝塞尔曲线，对所有uv做同样操作就形成了贝塞尔曲面。<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/54.png" alt="贝塞尔曲面" title="贝塞尔曲面"></li></ul><h2 id="模型-Mesh"><a href="#模型-Mesh" class="headerlink" title="模型 (Mesh)"></a>模型 (Mesh)</h2><ul><li>一个Mesh由很多面组成</li><li>一个模型文件.obj中存储的数据内容包括：顶点，顶点切线，顶点法线，三角面(一组顶点链接的顺序并组成面)<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/55.png" alt="模型" title="模型"></li></ul><h2 id="模型优化方法"><a href="#模型优化方法" class="headerlink" title="模型优化方法"></a>模型优化方法</h2><h3 id="模型细分-Mesh-subdivision"><a href="#模型细分-Mesh-subdivision" class="headerlink" title="模型细分(Mesh subdivision)"></a>模型细分(Mesh subdivision)</h3><p>目的：达到更精细的显示效果，细分后模型面会增多，顶点数量也会增多<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/56.png" alt="模型细分" title="模型细分"></p><h4 id="Loop-Subdivision-只适用于三角面细分"><a href="#Loop-Subdivision-只适用于三角面细分" class="headerlink" title="Loop Subdivision (只适用于三角面细分)"></a>Loop Subdivision (只适用于三角面细分)</h4><p>思路：将1个三角形等分成4个三角形<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/57.png" alt="Loop Subdivision" title="Loop Subdivision"></p><h4 id="Catmull-Clark-Subdivision-通常模型的细分-将多边形统一细分成四边形"><a href="#Catmull-Clark-Subdivision-通常模型的细分-将多边形统一细分成四边形" class="headerlink" title="Catmull-Clark Subdivision (通常模型的细分,将多边形统一细分成四边形)"></a>Catmull-Clark Subdivision (通常模型的细分,将多边形统一细分成四边形)</h4><p>思路：将所有不是四边形的面都转换成四边形，再将1个四边形分成4个四边形<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/58.png" alt="Catmull-Clark Subdivision" title="Catmull-Clark Subdivision"></p><h3 id="模型简化-Mesh-simplification"><a href="#模型简化-Mesh-simplification" class="headerlink" title="模型简化(Mesh simplification)"></a>模型简化(Mesh simplification)</h3><p>目的：减少渲染计算压力，避免不必要的计算<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/59.png" alt="模型简化" title="Tools"></p><h3 id="模型规则化-Mesh-regularization"><a href="#模型规则化-Mesh-regularization" class="headerlink" title="模型规则化(Mesh regularization)"></a>模型规则化(Mesh regularization)</h3><p>目的：提高模型质量，将所有三角面都转成等边三角形<br><img src="/blog/2021/03/31/Graphics/Games101%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/60.png" alt="模型规则化" title="Tools"></p><h1 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪(Ray Tracing)"></a>光线追踪(Ray Tracing)</h1><h2 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h2><h3 id="如何检测射线命中三角面"><a href="#如何检测射线命中三角面" class="headerlink" title="如何检测射线命中三角面"></a>如何检测射线命中三角面</h3><h2 id="加速射线检测"><a href="#加速射线检测" class="headerlink" title="加速射线检测"></a>加速射线检测</h2><h3 id="如何进行射线检测"><a href="#如何进行射线检测" class="headerlink" title="如何进行射线检测"></a>如何进行射线检测</h3><h3 id="如何进行场景分块"><a href="#如何进行场景分块" class="headerlink" title="如何进行场景分块"></a>如何进行场景分块</h3><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><h1 id="材质-Materials-and-Appearances"><a href="#材质-Materials-and-Appearances" class="headerlink" title="材质(Materials and Appearances)"></a>材质(Materials and Appearances)</h1><h1 id="动画-Animation"><a href="#动画-Animation" class="headerlink" title="动画(Animation)"></a>动画(Animation)</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744">GAMES101-现代计算机图形学入门-闫令琪</a></p>]]></content>
    
    
    <summary type="html">图形学基础入门</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>雾效学习</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/%E9%9B%BE%E6%95%88/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/%E9%9B%BE%E6%95%88/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-11-24T08:59:46.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>了解如下效果原理，并实现以及运用</p><ul><li>深度雾</li><li>高度雾</li><li>体积雾</li></ul><h1 id="高度雾"><a href="#高度雾" class="headerlink" title="高度雾"></a>高度雾</h1><h1 id="深度雾"><a href="#深度雾" class="headerlink" title="深度雾"></a>深度雾</h1><h1 id="体积雾"><a href="#体积雾" class="headerlink" title="体积雾"></a>体积雾</h1>]]></content>
    
    
    <summary type="html">雾效学习</summary>
    
    
    
    <category term="Fog" scheme="https://skierhou.github.io/categories/Fog/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="Fog" scheme="https://skierhou.github.io/tags/Fog/"/>
    
  </entry>
  
  <entry>
    <title>3D数学基础：图形与游戏开发</title>
    <link href="https://skierhou.github.io/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/"/>
    <id>https://skierhou.github.io/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/</id>
    <published>2021-03-12T06:30:01.000Z</published>
    <updated>2021-12-21T12:18:14.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h2><p>公式：a*b = |a||b|cosθ<br>几何意义：<br>(1) 判断前后<br>(2) 投影<br>用矩阵表示：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/01.png" alt="向量点乘矩阵表示" title="Tools"></p><h2 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h2><p>公式：|a×b| = |a||b|sinθ<br>几何意义：<br>(1) 判断左右<br>(2) 计算垂直a,b所形成平面的向量，该向量的朝向由左手定则(左手坐标系)，右手定则(右手坐标系)决定<br>用矩阵表示：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/02.png" alt="向量叉乘矩阵表示" title="Tools"></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ul><li><p>矩阵转置(M(T))：通俗解释,行变列，列变行<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/03.png" alt="矩阵转置" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/04.png" alt="矩阵转置" title="Tools"></p></li><li><p>矩阵乘法<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/05.png" alt="矩阵乘法" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/06.png" alt="矩阵乘法" title="Tools"></p></li><li><p>矩阵变换过程<br>(1)v=(x,y,z) 拆解成v=xp+yq+zr，p,q,r为一个坐标系的+x轴，+y轴，+z轴的单位向量<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/07.png" alt="矩阵乘法" title="Tools"><br>(2)其(p,q,r)可以拆分为一个3<em>3矩阵即<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/08.png" alt="矩阵乘法" title="Tools"><br>(3)矩阵变换相当于 变换矩阵</em>列向量=新的向量</p></li><li><p>旋转矩阵<br>(1) 2D旋转矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/09.png" alt="2D旋转矩阵" title="Tools"><br>(2) 3D绕正坐标轴旋转与2D同样<br>(3) 3D绕任意轴旋转 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/10.png" alt="2D旋转矩阵" title="Tools"></p></li><li><p>缩放矩阵<br>(1) 三轴的缩放因子kx,ky,kz 乘对应的p，q，r即是缩放矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/11.png" alt="缩放矩阵" title="Tools"><br>(2) 沿任意轴缩放矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/12.png" alt="沿任意轴缩放矩阵" title="Tools"><br>(3) 关于沿任意轴缩放矩阵因子k的特殊解释：<br>  k=-1：镜像，n相当于平面法向量<br>  k=0：投影，n相当于平面法向量<br>  k&gt;0：普通缩放</p></li><li><p>切变 (扭曲变换)<br>一个/多个轴的坐标被另外一个轴以及一个/多个系数影响，2D切变如：将y乘因子s再加到x轴上，x’ = x + y*s。可以解释为，切变y轴，因子s，x轴受y轴切变影响<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/13.png" alt="切变" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/14.png" alt="切变" title="Tools"></p></li><li><p>行列式 (矩阵M的行列式表示为：|M|)<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/16.png" alt="行列式" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/17.png" alt="行列式" title="Tools"></p></li><li><p>余子式 (M(ij)表示从M矩阵中去掉第 i 行以及第 j 列后剩余的矩阵)<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/18.png" alt="余子式" title="Tools"></p></li><li><p>代数余子式<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/19.png" alt="代数余子式" title="Tools"></p></li><li><p>行列式性质<br>(1).|A*B|=|A||B|<br>(2).|M(T)|=|M|     注：M(T)为M的转置<br>(3).矩阵任意行或列都为零，则行列式为零<br>(4).交换矩阵的任意两行或两列，行列式变负<br>(5).任意行或列的非零积加到另一行或列上，行列式值不变<br>(6).行列式的值=2D中的面积，3D中的体积<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/20.png" alt="行列式性质" title="Tools"></p></li><li><p>矩阵的逆 M(-1)<br>矩阵的逆 公式： “标准伴随矩阵” / 行列式 = 矩阵的逆<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/21.png" alt="矩阵的逆" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/22.png" alt="矩阵的逆" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/23.png" alt="矩阵的逆" title="Tools"></p></li><li><p>正交矩阵 (通常表示为Q)<br>M * M(T) = I，M * M(-1) = I，M(T) = M(-1)<br>(1)M(T)，M(-1)也为正交矩阵<br>(2)|M| = +1或-1<br>(3)M(T)各行为单位向量且两两相交<br>几何意义：在已知该矩阵为正交矩阵的前提下，求矩阵的逆只需要求矩阵的转置而不用复杂计算。<br>在坐标转换中旋转矩阵都是正交矩阵</p></li><li><p>4X4齐次矩阵<br>平移是一个特殊的变换矩阵，在3X3矩阵中无法表示，因此添加了一个唯独存放平移信息，其中W分量为1表示向量，而W分量为0表示点<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/25.png" alt="4X4齐次矩阵" title="Tools"></p></li></ul><h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><ul><li>比较常见的表达旋转的方式，用三个旋转角度表示当前的旋转值，分别对应：绕x，y，z轴旋转度数。</li><li>优点：表达简单易懂，任意3个数表示欧拉角都是有效的</li><li>缺点：插值困难，如+190°与-170°实际表现是一样的但是普通插值会造成360°以上的旋转，旋转中某种特殊情况会出现万向锁问题</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ol><li>Q = [w v] = [w x y z]</li><li>单位四元数：Q = [1 0]</li><li>带入角度以及旋转轴：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/26.png" alt="四元数" title="Tools"></li><li>四元数的模<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/27.png" alt="四元数" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/28.png" alt="四元数" title="Tools"></li><li>四元数的共轭：q(*) ，向量变负<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/29.png" alt="四元数" title="Tools"></li><li>四元数的逆：q(-1) * q = [1 0] （单位四元数），由共轭除以模获得<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/30.png" alt="四元数" title="Tools"></li><li>四元数的乘法（叉乘）：（满足乘法结合律，不满足交换律）<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/31.png" alt="四元数" title="Tools"></li><li>使用四元数旋转<br>标准3D坐标（x,y,z）转成p=[0 (x,y,z)]，q为旋转矩阵：[cos(θ/2) n*sin(θ/2)]<br>再通过以下公式<br>由右向左旋转： <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/32.png" alt="四元数" title="Tools"><br>由左向右旋转： <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/33.png" alt="四元数" title="Tools"></li><li>四元数的差：计算四元数’a’旋转到’b’的角位移，用’d’表示 a*d = b ，同时左乘一个a的逆（四元数不支持除法）<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/34.png" alt="四元数" title="Tools"></li><li>四元数点乘 几何意义：a·b的绝对值越大，说明a与b角位移越相似<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/35.png" alt="四元数" title="Tools"></li><li>四元数求幂：（比较常用）<br>一个四元数q(1/3)  表示1/3的q的角位移;  q(2)：两倍q的角位移</li></ol><h1 id="几何图元"><a href="#几何图元" class="headerlink" title="几何图元"></a>几何图元</h1><ul><li>自由度概念：自由度是决定一个图元可用的最少参数。 如：球：半径，矩形：长，宽，高</li><li>边界球检测相交</li><li>AABB包围盒检测相交：矩形的边于世界坐标系平行，满足相交条件Xmin &lt;= X &lt;= Xmax , Ymin &lt;= Y &lt;= Ymax , Zmin &lt;= Z &lt;= Zmax<br>关于AABB包围盒的变换，当物体变换时，并不能直接设置AABB盒子(旋转等，盒子大小会变化)，而需要重新计算</li><li>点到平面的距离计算：取平面任意一点，得向量a以及于平面的夹角θ，sinθ*|a|即最短距离</li><li>三角形面积计算：1.bh/2 ，2.海伦公式(在不知道高的情况下)：</li><li>三角形重心，内心，外心计算， <strong>重心</strong>：三角形平衡点，<strong>内心</strong>：到三条边距离相等，<strong>外心</strong>：到三个顶点距离相等</li><li>证明点在三角形内部，只需要用三角形的三个点于点P的向量分别于其三条边的向量做叉乘，求得点P在边的左侧或右侧，但三条边都在内部则点P在三角形内部</li></ul><h1 id="几何检测-重点-重复查看"><a href="#几何检测-重点-重复查看" class="headerlink" title="几何检测 (重点 重复查看)"></a>几何检测 (重点 重复查看)</h1><h1 id="三角网格-没看懂"><a href="#三角网格-没看懂" class="headerlink" title="三角网格 (没看懂)"></a>三角网格 (没看懂)</h1><h1 id="图形数学"><a href="#图形数学" class="headerlink" title="图形数学"></a>图形数学</h1><h1 id="可见性检测"><a href="#可见性检测" class="headerlink" title="可见性检测"></a>可见性检测</h1>]]></content>
    
    
    <summary type="html">3D数学基础：图形与游戏开发</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Math" scheme="https://skierhou.github.io/tags/Math/"/>
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Addressable 深度理解与使用</title>
    <link href="https://skierhou.github.io/2021/03/05/Unity/Resource/Addressable/"/>
    <id>https://skierhou.github.io/2021/03/05/Unity/Resource/Addressable/</id>
    <published>2021-03-05T06:30:01.000Z</published>
    <updated>2021-03-10T04:48:10.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Addressable是什么"><a href="#Addressable是什么" class="headerlink" title="Addressable是什么"></a>Addressable是什么</h2><p>是Unity官方出的资源管理器，Addressable即可寻址的资源系统<br>Addressable的优点：</p><ul><li>通过一个key，可以直接获取资源，不需要在意资源的实际位置</li><li>有完整的可视化界面，不需要写大量资源管理代码即可管理资源</li><li>方便自定义打包，自带增量更新等</li></ul><h2 id="Addressable的使用心得"><a href="#Addressable的使用心得" class="headerlink" title="Addressable的使用心得"></a>Addressable的使用心得</h2><ul><li><p>操作界面入口<br><img src="/blog/2021/03/05/Unity/Resource/Addressable/01.png" alt="Tools" title="Tools"></p></li><li><p>初次打开需要创建Setting之后会看到Assets目录下的文件结构，先做简单介绍后面在工具使用时会依次讲到所有资源文件使用方式</p><table><thead><tr><th align="left">路径</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">AddressableAssetsData</td><td align="left"><strong>根目录，AddressableAssetSettings是整个Addressable设置</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroups</td><td align="left"><strong>资源管理组，管理多个Schema处理该组内资源的读取/加载/保存等逻辑</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroups/Schemas</td><td align="left"><strong>处理模式，处理数据的实际逻辑类，继承自AddressableAssetGroupSchema，默认提供了三个Schema，分别对应两个AssetGroups：Built In Data以及Default Local Group</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroupTemplates</td><td align="left"><strong>这个路径下只是一个模板，在创建Group时会复制一份这个模板</strong></td></tr><tr><td align="left">AddressableAssetsData/DataBuilders</td><td align="left"><strong>在不同构建模式下，在游戏运行中的数据提供者，可选择项有InstanceProvider以及SceneProvider</strong></td></tr><tr><td align="left">AddressableAssetsData/Windows</td><td align="left"><strong>这个路径是打包才会自动生成的本地对应文件，记录上一次打包信息，可以用于增量更新，通过保存的文件判断哪些文件需要更新</strong></td></tr></tbody></table></li><li><p>Groups界面，管理所有Groups，即资源组，默认资源组存在两个:<strong>Build In Data</strong>，<strong>Default Local Group</strong>。</p><table><thead><tr><th align="left">Group</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">Build In Data</td><td align="left">点击Build In Data，对应Assets/AddressableAssetsData/AssetGroups/Build In Data.asset，只有两个设置：包含Resources路径下资源，BuildSetting设置的场景，即这部分资源会打进游戏包中，不进行资源加载，这个资源组官方已经设置好了，不需要做任何其他设置。 Build In Data.asset目前没有方式主动创建，不要误删即可（不然只能重新创建数据了）。</td></tr><tr><td align="left">Default Local Group</td><td align="left">对应Assets/AddressableAssetsData/AssetGroups/Default Local Group.asset，其中包含两个Schema：<strong>BundledAssetGroupSchema</strong>,<strong>ContentUpdateGroupSchema</strong>。 ContentUpdateSchema：只有一个设置，设置为全量更新或者增量更新，全量：更新即替换，增量：不替换原资源情况下多打一个资源包，BundledAssetGroupSchema：设置资源打包/加载路径，以及Bundle模式：crc缓存，bundle名，以什么方式分组等，通常使用默认即可</td></tr></tbody></table></li><li><p>Groups界面操作<br>资源可以通过拖拽文件夹，拖拽单个文件，或再Inspector面板直接勾选Addressable</p><table><thead><tr><th align="left">按钮</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">Profile</td><td align="left">路径配置，远程/本地的加载/构建路径，<strong>不管构建再哪个路径底下，加载Key都保持不变，这也是Addressable基本思想所在</strong></td></tr><tr><td align="left">Tools</td><td align="left">工具，可以快捷打开所有界面，关于’Check For Content Update’按钮是用于增量更新的，当group设置为增量模式，且相比较上一次存在变换，点击这个按钮增量打包，会产生一个新的资源组管理增量资源，增量打包后原资源不会删除，但对应key下的hash指向的资源会变成新包资源。</td></tr><tr><td align="left">Play Mode Script</td><td align="left">游戏中使用的资源加载模式：1.fastest：AssetsDataset加载，2.advanced：模拟ab包加载，3.requires built groups：实际ab包加载。选择每种模式后对应AddressableAssetsData/DataBuilders的构建设置也会修改，对应1.BuildScriptFastMode,2.BuildScriptPackedPlayMode,3.BuildScriptVirtualMode，其中多的一个BuildScriptPackedMode为实现构建资源时的默认构建模式</td></tr><tr><td align="left">Build</td><td align="left">New Build 下的按钮对应AddressableAssetsData/DataBuilders/BuildScriptPackedMode.asset，第二个按钮即增量更新按钮与Tools中的Content Update配合使用，Clean按钮即清除已构建的资源</td></tr></tbody></table></li><li><p>Profile 界面：管理Profile，设置打包，加载等路径</p></li><li><p>AddressableAssetSettings设置：通常使用默认即可，对应按钮名称标记很明显了，不进行详细介绍</p></li><li><p>EventViewer界面：查看运行时资源使用情况，启动时需设置AddressableAssetSettings中的Send Profiler Event</p></li><li><p>Analyze界面：用于分析资源的依赖关系，Fixable Rule：可修复的规则，分析器自动修复，UnFixable Rule：不可修复的规则，会列出来需要手动修复</p></li><li><p>Hosting界面：创建远程或者本地的服务器，方便测试，默认使用HTTP Service，查看HttpHostingService.cs代码可自定义服务器模式</p></li></ul><h2 id="Addressable的使用说明"><a href="#Addressable的使用说明" class="headerlink" title="Addressable的使用说明"></a>Addressable的使用说明</h2><h4 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h4><p>Addressable中加载任何资源都需要异步加载，不过可以使用Task多线程方式加载，使用非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField]</span><br><span class="line">    private string _entryName &#x3D; &quot;Assets&#x2F;Prefabs&#x2F;Cube.prefab&quot;;</span><br><span class="line"></span><br><span class="line">    public AssetReference ar;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用Task异步加载</span><br><span class="line">        StartAsync();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用AssetReference引用直接加载</span><br><span class="line">        ar.LoadAssetAsync&lt;GameObject&gt;().Completed +&#x3D; LoadFinish;</span><br><span class="line">        ar.InstantiateAsync(Vector3.one, Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void LoadFinish(AsyncOperationHandle&lt;GameObject&gt; loadHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        if (loadHandle.IsDone &amp;&amp; loadHandle.Status &#x3D;&#x3D; AsyncOperationStatus.Succeeded)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;这里Result是预制体</span><br><span class="line">            Debug.Log(loadHandle.Result);</span><br><span class="line">            Addressables.Release(loadHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private async Task StartAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        var instance &#x3D; await Addressables.InstantiateAsync(_entryName).Task;</span><br><span class="line">        Addressables.ReleaseInstance(instance);</span><br><span class="line">        instance &#x3D; await Addressables.InstantiateAsync(_entryName).Task;</span><br><span class="line">        Addressables.ReleaseInstance(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><p>使用Addressables提供的接口即可完成更新检查，以及下载，详细请阅读代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private async void UpdateAndDownLoad()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 检查更新</span><br><span class="line">    AsyncOperationHandle&lt;List&lt;string&gt;&gt; updateHandle &#x3D; Addressables.CheckForCatalogUpdates(false);</span><br><span class="line">    await updateHandle.Task;</span><br><span class="line">    if (updateHandle.Status &#x3D;&#x3D; AsyncOperationStatus.Succeeded)</span><br><span class="line">    &#123;</span><br><span class="line">        updateList &#x3D; updateHandle.Result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.开始更新</span><br><span class="line">    AsyncOperationHandle&lt;List&lt;IResourceLocator&gt;&gt; updateHandler &#x3D; Addressables.UpdateCatalogs(updateList, false);</span><br><span class="line">    await updateHandler.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3.获取更新资源的key</span><br><span class="line">    List&lt;string&gt; updateKeys &#x3D; new List&lt;string&gt;();</span><br><span class="line">    foreach (IResourceLocator locator in updateHandler.Result)</span><br><span class="line">    &#123;</span><br><span class="line">        if (locator is ResourceLocationMap map)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var item in map.Locations)</span><br><span class="line">            &#123;</span><br><span class="line">                if (item.Value.Count &#x3D;&#x3D; 0) continue;</span><br><span class="line">                string key &#x3D; item.Key.ToString();</span><br><span class="line">                if (int.TryParse(key, out int resKey)) continue;</span><br><span class="line"></span><br><span class="line">                if (!updateKeys.Contains(key))</span><br><span class="line">                    updateKeys.Add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4.判断下载资源大小</span><br><span class="line">    AsyncOperationHandle&lt;long&gt; downLoadSize &#x3D; Addressables.GetDownloadSizeAsync(updateKeys);</span><br><span class="line">    await downLoadSize.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5.下载</span><br><span class="line">    AsyncOperationHandle downLoad &#x3D; Addressables.DownloadDependenciesAsync(updateKeys, MergeMode.None);</span><br><span class="line">    await downLoad.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 6.清除</span><br><span class="line">    Addressables.Release(updateHandler);</span><br><span class="line">    Addressables.Release(downLoad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Addressable的扩展"><a href="#Addressable的扩展" class="headerlink" title="Addressable的扩展"></a>Addressable的扩展</h2><h3 id="自动化打包"><a href="#自动化打包" class="headerlink" title="自动化打包"></a>自动化打包</h3><ul><li>在实际项目中资源打包通常不会人工手动设置，而是通过一些模式自动化打包，Addressable虽然提供了非常完善的功能界面，但是打包自动化还是需要用户自己扩展。以下是我个人理解的打包策略，与上篇<a href="../AssetBundle/index">AssetBundle文章</a>的一样的策略，一个文件夹下所有的资源都按当前文件夹名称设置AB包一个文件一个AB包，子文件递归设置。</li><li>Groups界面可以直接拖拽文件夹进去，但是打包设置中只有三个选项：1.一组打成一个包，2.文件夹打成一个包(一次拖进去的文件夹子目录也包括进去)，3.按标签打包。我这里使用的是按标签打包，相同标签一个包。</li><li>扩展代码请查看末尾的项目。</li></ul><p><img src="/blog/2021/03/05/Unity/Resource/Addressable/02.PNG" alt="自动化打包" title="自动化打包"></p><h3 id="场景加载以及游戏物体实例化扩展"><a href="#场景加载以及游戏物体实例化扩展" class="headerlink" title="场景加载以及游戏物体实例化扩展"></a>场景加载以及游戏物体实例化扩展</h3><ul><li>Addressable默认有提供InstanceProvider以及SceneProvider，但是InstanceProvider中并没有使用到对象池，且在使用Addressables.InstantiateAsync()多次后，同样的资源引用会存在多个，可以通过EventViewer中看到资源占用的堆内存空间，通过继承IInstanceProvider以及ISceneProvider自己实现加载完实际资源后的实例化对象即可。其实就是将对象池写入IInstanceProvider，查看末尾的项目代码其中有InstanceProviderHelper.cs实现。</li></ul><blockquote><p><a href="https://github.com/Skierhou/ResourceManager">项目路径 https://github.com/Skierhou/ResourceManager</a></p></blockquote>]]></content>
    
    
    <summary type="html">Addressable原理，使用说明，扩展</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Resource" scheme="https://skierhou.github.io/categories/Unity/Resource/"/>
    
    <category term="Addressable" scheme="https://skierhou.github.io/categories/Unity/Resource/Addressable/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="Addressable" scheme="https://skierhou.github.io/tags/Addressable/"/>
    
  </entry>
  
</feed>
