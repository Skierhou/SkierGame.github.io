<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Skier</title>
  
  <subtitle>游戏开发</subtitle>
  <link href="https://skierhou.github.io/atom.xml" rel="self"/>
  
  <link href="https://skierhou.github.io/"/>
  <updated>2021-04-20T12:17:20.978Z</updated>
  <id>https://skierhou.github.io/</id>
  
  <author>
    <name>Skier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZeroMQ使用</title>
    <link href="https://skierhou.github.io/2021/04/20/Service/ZeroMQ%E4%BD%BF%E7%94%A8/"/>
    <id>https://skierhou.github.io/2021/04/20/Service/ZeroMQ%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-20T06:30:01.000Z</published>
    <updated>2021-04-20T12:17:20.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZeroMQ简介"><a href="#ZeroMQ简介" class="headerlink" title="ZeroMQ简介"></a>ZeroMQ简介</h1><h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><p>ZeroMQ将消息通信分成4种模型，分别是一对一结对模型（Exclusive-Pair）、请求回应模型（Request-Reply）、发布订阅模型（Publish-Subscribe）、推拉模型（Push-Pull）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zeromq.org/languages/csharp/">官方C#</a><br><a href="https://netmq.readthedocs.io/en/latest/">官方</a><br><a href="https://github.com/NetMQ/Samples">github Samples</a><br><a href="https://www.cnblogs.com/leijiangtao/p/12016200.html">文章1</a><br><a href="https://blog.csdn.net/weixin_30618985/article/details/95884164">文章2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ZeroMQ简介&quot;&gt;&lt;a href=&quot;#ZeroMQ简介&quot; class=&quot;headerlink&quot; title=&quot;ZeroMQ简介&quot;&gt;&lt;/a&gt;ZeroMQ简介&lt;/h1&gt;&lt;h1 id=&quot;消息模型&quot;&gt;&lt;a href=&quot;#消息模型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Service" scheme="https://skierhou.github.io/categories/Service/"/>
    
    
    <category term="ZeroMQ" scheme="https://skierhou.github.io/tags/ZeroMQ/"/>
    
  </entry>
  
  <entry>
    <title>KCP使用</title>
    <link href="https://skierhou.github.io/2021/04/20/Service/KCP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/"/>
    <id>https://skierhou.github.io/2021/04/20/Service/KCP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-20T06:30:01.000Z</published>
    <updated>2021-04-25T06:27:04.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><table><thead><tr><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">ikcp_waitsnd</td><td align="left">检查等待发送的消息，如果超出最大等待大小，应该断开连接</td></tr><tr><td align="left">ikcp_recv</td><td align="left">kcp将接收到的kcp数据包还原成之前kcp发送的buffer数据</td></tr><tr><td align="left">ikcp_input</td><td align="left">kcp接收到下层协议UDP传进来的数据底层数据buffer转换成kcp的数据包格式</td></tr><tr><td align="left">ikcp_flush</td><td align="left">将发送队列中的数据通过下层协议UDP进行发送</td></tr><tr><td align="left">ikcp_send</td><td align="left">把要发送的buffer分片成KCP的数据包格式，插入待发送队列中</td></tr><tr><td align="left">ikcp_nodelay</td><td align="left"></td></tr></tbody></table><p>//nodelay:   0 不启用，1启用快速重传模式<br>//interval： 内部flush刷新时间<br>//resend:    0（默认）表示关闭。可以自己设置值，若设置为2（则2次ACK跨越将会直接重传）<br>//nc:        是否关闭拥塞控制，0（默认）代表不关闭，1代表关闭</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_36748278/article/details/80171575">文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;API介绍&quot;&gt;&lt;a href=&quot;#API介绍&quot; class=&quot;headerlink&quot; title=&quot;API介绍&quot;&gt;&lt;/a&gt;API介绍&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;表头&lt;/th&gt;
&lt;th align=&quot;left</summary>
      
    
    
    
    <category term="Service" scheme="https://skierhou.github.io/categories/Service/"/>
    
    
    <category term="KCP" scheme="https://skierhou.github.io/tags/KCP/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/OpenGL/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/OpenGL/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-03-31T05:44:17.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p><a href="https://blog.csdn.net/sigmarising/article/details/80470054">OpenGL安装教程</a><br><a href="https://www.bilibili.com/video/BV1X7411F744?from=search&seid=7915905348717479996">计算机图形学入门教程</a></p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1>]]></content>
    
    
    <summary type="html">OpenGL学习</summary>
    
    
    
    <category term="OpenGL" scheme="https://skierhou.github.io/categories/OpenGL/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="OpenGL" scheme="https://skierhou.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>UnityShader基础渲染知识点概况</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/UnityShader/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/UnityShader/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-04-25T08:56:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><h1 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h1><ol><li>“LightMode” = “ForwardBase”，</li></ol><h1 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h1><h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><h1 id="灯光设置"><a href="#灯光设置" class="headerlink" title="灯光设置"></a>灯光设置</h1><ol><li>灯光可以设置Auto/Important/UnImportant，Auto：当满足逐像素光照则为逐像素，不满足则为逐顶点，都不满足则SH处理，Important：逐像素光照，UnImportant：逐顶点光照或SH处理。</li><li>光源的Cookie：灯光照下的样子，点光源使用立方体贴图CubeMap，聚光灯使用2D贴图，使用时需要将贴图类型设置为Cookie</li><li>平行光(Directional Light)，全局平行光，</li><li>点光源(Point Light)，球形灯光，一般用SH球谐函数在ForwardBase中就算顶点光照</li><li>聚光灯(Spot Light)，锥形灯光,一般用SH球谐函数在ForwardBase中就算顶点光照</li></ol><h1 id="伽马-Gamma"><a href="#伽马-Gamma" class="headerlink" title="伽马(Gamma)"></a>伽马(Gamma)</h1><ol><li>显示器用于颜色矫正，通常值为2.2，对颜色进行灰度，亮度矫正<br>打个比方，功率为50%的灰色，人眼实际感知亮度为：0.5的2.2开根 = 0.7297<br>而人眼认为的50%中灰色，实际功率为：0.5的2.2次幂 = 0.2176</li><li>Unity中可选择的颜色空间线性空间，伽马空间。</li></ol><h1 id="常用API记录"><a href="#常用API记录" class="headerlink" title="常用API记录"></a>常用API记录</h1><table><thead><tr><th align="left">API</th><th align="left">定义</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">EnergyConservationBetweenDiffuseAndSpecular</td><td align="left">定义于UnityStandardUtils.cgine</td><td align="left">漫反射和镜面反射的能力守恒函数</td></tr><tr><td align="left">DiffuseAndSpecularFromMetallic</td><td align="left">定义于UnityStandardUtils.cgine</td><td align="left">金属性设置,其中金属性参数需要标记[Gamma]，受Gamma矫正后的参数</td></tr><tr><td align="left">UNITY_BDRP_PBS</td><td align="left">定义于UnityPBSLighting.cgine</td><td align="left">基于物理的着色，双向反射率分布函数</td></tr><tr><td align="left">UNITY_LIGHT_ATTENUATION</td><td align="left">定义于AutoLight.cginc</td><td align="left">光照衰减值</td></tr><tr><td align="left">#pragma multi_compile</td><td align="left">多重定义宏</td><td align="left">如#pragma multi_compile DIRECTIONAL POINT SPOT 可以define(..)判断哪些宏被定义了，然后执行特定的逻辑，C#处可以启用/关闭Shader宏：Shader.EnableKeyword(string);Shader.DisableKeyword(string);</td></tr><tr><td align="left">ShadeSH9</td><td align="left">UnityCG.cginc</td><td align="left">球谐函数，</td></tr><tr><td align="left">ComputeScreenPos</td><td align="left">计算屏幕坐标</td><td align="left">计算屏幕坐标：参数 顶点坐标</td></tr><tr><td align="left">COMPUTE_EYEDEPTH</td><td align="left">计算视野深度</td><td align="left">计算视野深度：参数 返回值(视野深度)</td></tr><tr><td align="left">UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture)</td><td align="left">获取相机深度图</td><td align="left">获取相机深度图</td></tr><tr><td align="left">SAMPLE_DEPTH_TEXTURE_PROJ</td><td align="left">采样深度图</td><td align="left">相当于：tex2Dproj(sampler, uv).r</td></tr><tr><td align="left">LinearEyeDepth</td><td align="left"></td><td align="left">线性视野深度0-1区间</td></tr><tr><td align="left">ddx,ddy</td><td align="left"></td><td align="left">求当前像素的值其临近像素上的变化率，分别对应x轴/y轴</td></tr></tbody></table><h1 id="常见效果实现记录"><a href="#常见效果实现记录" class="headerlink" title="常见效果实现记录"></a>常见效果实现记录</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/137429554">基础渲染系列教程20篇</a><br><a href>UnityShader入门精要</a><br><a href="https://sp4ghet.github.io/grad/">计算渐变颜色网站</a><br><a href="https://www.textures.com/library">免费材质贴图</a></p>]]></content>
    
    
    <summary type="html">UnityShader基础渲染学习与总结</summary>
    
    
    
    <category term="UnityShader" scheme="https://skierhou.github.io/categories/UnityShader/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
    <category term="UnityShader" scheme="https://skierhou.github.io/tags/UnityShader/"/>
    
  </entry>
  
  <entry>
    <title>图形学基础</title>
    <link href="https://skierhou.github.io/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>https://skierhou.github.io/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-31T06:30:01.000Z</published>
    <updated>2021-04-25T06:43:46.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵向量等基础3D数学知识"><a href="#矩阵向量等基础3D数学知识" class="headerlink" title="矩阵向量等基础3D数学知识"></a><a href="https://gameframework.cn/api/index.html">矩阵向量等基础3D数学知识</a></h1><h1 id="几何变换应用（几何变换的详细计算步骤）"><a href="#几何变换应用（几何变换的详细计算步骤）" class="headerlink" title="几何变换应用（几何变换的详细计算步骤）"></a>几何变换应用（几何变换的详细计算步骤）</h1><h2 id="Model-Tranform-模型变换"><a href="#Model-Tranform-模型变换" class="headerlink" title="Model Tranform(模型变换)"></a>Model Tranform(模型变换)</h2><p>在空间中摆放需要相机，模型等操作，放置模型。</p><h2 id="View-Tranform-视图变换"><a href="#View-Tranform-视图变换" class="headerlink" title="View Tranform(视图变换)"></a>View Tranform(视图变换)</h2><p>原理：将场景相机移动到坐标原点，并朝向-z方向，其他物体顶点于相机相对位置保持一致，即乘上相同的变换矩阵<br>移动相机到坐标原点需要平移+旋转矩阵，平移矩阵可以直接通过坐标得出<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/01.png" alt="平移矩阵" title="Tools"><br>旋转矩阵计算步骤：</p><ol><li><p>需要将原y轴旋转至(0,1,0)方向，将原z轴旋转至(0,0,-1)方向，将原x轴旋转至(1,0,0)方向</p></li><li><p>先设当前相机坐标轴表示为[X:g×t,Y:t,Z:g] (注：g×t，g叉乘t)，原点规范的坐标轴为X(1,0,0),Y(0,1,0),Z(0,0,1)。从当前旋转至规范坐标轴较为困难，但从规范坐标轴旋转至当前坐标轴非常简单，<br>求y轴旋转：M1*(0,1,0,1)=( X(t),Y(t),Z(t),1 )<br>求z轴旋转：M2*(0,0,-1,1)=( X(g),Y(g),Z(g),1 )   注：朝向-z轴<br>求x轴旋转：M3*(1,0,0,1)=( X(gxt),Y(gxt),Z(gxt),1 )<br>M1+M2+M3最终计算的旋转矩阵如下：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/02.png" alt="规范朝向 旋转至 相机朝向" title="Tools"></p></li><li><p>得到的旋转矩阵为：规范朝向-相机当前朝向的矩阵，我们需要求出：相机当前朝向-规范朝向的矩阵，这相当于求矩阵的逆<br>需要掌握前提条件：旋转矩阵满足一个原则，矩阵的转置=矩阵的逆。 通过转置这个矩阵得到最终旋转矩阵如下：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/03.png" alt="相机朝向 旋转至 规范朝向" title="Tools"></p></li><li><p>旋转矩阵*平移矩阵即得到最终的MV矩阵</p></li></ol><h2 id="Projection-Tranform-投影变换"><a href="#Projection-Tranform-投影变换" class="headerlink" title="Projection Tranform(投影变换)"></a>Projection Tranform(投影变换)</h2><p>投影分为:正交投影(Orthographic Projection)，透视投影(Perspective Projection)。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/04.png" alt="正交投影 透视投影" title="Tools"></p><h3 id="正交投影计算过程"><a href="#正交投影计算过程" class="headerlink" title="正交投影计算过程"></a>正交投影计算过程</h3><p>最终目的：将可视范围移动到x:[-1,1],y:[-1,1],z:[-1,1]的原点Cube中<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/05.png" alt="正交投影过程" title="Tools"></p><ol><li>通过可视范围的中心点得到平移矩阵</li><li>由于正交投影：其可是范围为长方体，只需要通过缩放矩阵，将大小压缩到标准大小即可<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/06.png" alt="正交投影过程" title="Tools"></li></ol><h3 id="透视投影计算过程"><a href="#透视投影计算过程" class="headerlink" title="透视投影计算过程"></a>透视投影计算过程</h3><p>由于透视投影的可视范围是一个锥形，为了计算压缩成长方体，再进行正交投影，原理如下图所示，将Frustum压缩成Cuboid<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/07.png" alt="透视投影过程" title="Tools"><br>虽然只是压缩，但其中的计算过程比前面的都要复杂很多。</p><ol><li><p>拆分其变换过程，如下，近平面于原平面形成一个相似三角形<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/08.png" alt="透视投影过程" title="Tools"><br>得到变换后的x轴以及y轴值：y’ = y * n/z;  x’ = x * n/z; 而z轴暂时还不知道,得到如下变换后的坐标<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/09.png" alt="透视投影过程" title="Tools"></p></li><li><p>由第1部分求得坐标可以推算出变换矩阵的部分值：M * (x,y,z,1) = (nx,ny,unknown,z), M如下：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/10.png" alt="透视投影过程" title="Tools"></p></li><li><p>已知条件：<br>(1)所有近平面的点压缩后都保持不变<br>(2)远平面的点压缩z值不变<br>分别将其中的坐标带入矩阵计算：<br>(1) 近平面点带入： M * (x,y,n,1) = (nx,ny,n * n,n)，注释：变换后的z = n * n 于x,y不存在任何关系，因此可以得到(0,0,A,B)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/11.png" alt="透视投影过程" title="Tools"><br>(2) 远平面点带入： M * (x,y,f,1) = (unknown,unknown,f*f,f)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/12.png" alt="透视投影过程" title="Tools"><br>最终得到两条方程式：<br>(1)An + B = n * n<br>(2)Af + B = f * f<br>求解得：A = n + f；   B = -n * f</p></li></ol><p>最终其压缩矩阵如下图：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/13.png" alt="透视投影过程" title="Tools"></p><h2 id="Viewport-Tranform-视口变换"><a href="#Viewport-Tranform-视口变换" class="headerlink" title="Viewport Tranform(视口变换)"></a>Viewport Tranform(视口变换)</h2><p>原理：先定义好平面的height和width，即平面的像素比，屏幕坐标空间中左下角为(0,0)，再经过MVP变换后，当前图片所在空间为[x:[-1,1],y:[-1,1]]，需要将其大小变大，再平移至左下角到(0,0)点</p><p><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/14.png" alt="视口变换" title="Tools"></p><h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><p>经过视口变换后，所有图形信息都存在屏幕空间，这时需要考虑怎么将其显示出来，这个显示的过程就是光栅化。</p><h2 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h2><p>为什么使用的是三角形？</p><ol><li>三角形是最基本的图形，</li><li>一个三角形一定在一个平面上</li><li>可以很方便计算一个点在三角形的内外，使用叉乘</li></ol><p>三角形遍历原理：遍历每个可能的像素的中心点是否在三角形内部<br>但是通过这种方式遍历后，就会出现一个问题：走样(Aliasing)，或称为锯齿<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/15.png" alt="三角形遍历" title="Tools"></p><h2 id="反走样-抗锯齿-Anti-aliasing"><a href="#反走样-抗锯齿-Anti-aliasing" class="headerlink" title="反走样(抗锯齿) (Anti-aliasing)"></a>反走样(抗锯齿) (Anti-aliasing)</h2><p>走样是怎么形成的？根本原因是采样的频率跟不上变化的频率</p><ol><li>频域(Frequency Domain)</li></ol><ul><li><p>正弦/余弦频谱<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/16.png" alt="正弦/余弦频率" title="Tools"></p></li><li><p>傅里叶变换(Fourier Transform)<br>将非常多按照公式计算的频谱相加最终会越来越趋向于方形的频谱<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/17.png" alt="傅里叶变换" title="Tools"><br>(1) 通过傅里叶变换可以将图片从 空间域转换到频域<br>(2) 通过逆傅里叶变换可以将图片从 频域转换到空间域<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/18.png" alt="傅里叶变换" title="Tools"></p></li><li><p>频谱采样的一种特殊情况，如下图：对于两个不同频谱采样结果相同造成了走样<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/19.png" alt="频谱采样" title="Tools"></p></li></ul><ol start="2"><li>滤波器(Filter)<br>滤波器是针对空间域(Spatial Domain)中的图片进行卷积计算，但滤波器实际可以表示为对频域的操作。<br>如下图傅里叶变换结果：低频越趋向于白色，高频趋向于黑色，低频普遍存在于图片中心部分。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/18.png" alt="傅里叶变换" title="Tools"></li></ol><ul><li><p>低通滤波器：低频通过，实际对频域进行低通滤波，可以达到模糊图片的效果<br>实际原理就是将频域图片的高频部分全部过滤，只有低频通过。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/20.png" alt="低通滤波" title="Tools"></p></li><li><p>高通滤波器：高频通过，可以达到描边的效果（高频表示图片中变化差异很大的部分,相当于是描边）<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/21.png" alt="高通滤波" title="Tools"></p></li></ul><ol start="3"><li><p>卷积<br>如以3x3的box对图片进行卷积，每个像素的颜色至就相当于当前像素为中心周围9个像素点按照卷积核的比例相加。<br>在空间域对图片进行卷积，相当于在频域中的两个图片的乘积，如下图验证了这一点：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/22.png" alt="卷积" title="Tools"></p></li><li><p>实现反走样：在三角形遍历之前先进行模糊操作，再进行三角形遍历，每个像素保持模糊后的颜色值，模糊就是使用低通滤波对像素进行卷积操作<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/23.png" alt="反走样" title="Tools"></p></li></ol><h2 id="深度缓存-Z-Depth-Buffer"><a href="#深度缓存-Z-Depth-Buffer" class="headerlink" title="深度缓存(Z/Depth Buffer)"></a>深度缓存(Z/Depth Buffer)</h2><p>在三角形遍历后，我们知道了所有需要渲染的三角形，现在需要考虑将它们画出来，这时需要考虑绘制三角形的先后顺序，正确的先后顺序以保证最终显示的图形是我们想要的图形，最初有一种算法油画家算法，从远到近依次绘制所有三角形，但是对于多个三角形互相穿插的问题无法得到解决，ZBuffer可以很好的规避渲染顺序问题，通过对每一个像素维护一个深度值，绘制三角形不需要考虑顺序，每次绘制时只考虑深度值是否小于缓存值，小于则绘制，大于则剔除，绘制时间复杂度只有O(N)。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/24.png" alt="深度缓存" title="Tools"></p><h1 id="着色-Shading"><a href="#着色-Shading" class="headerlink" title="着色(Shading)"></a>着色(Shading)</h1><h2 id="渲染管线-Rendering-pipeline"><a href="#渲染管线-Rendering-pipeline" class="headerlink" title="渲染管线(Rendering pipeline)"></a>渲染管线(Rendering pipeline)</h2><p>实时渲染管线的整体顺序：应用阶段-&gt;几何阶段-&gt;光栅化阶段</p><ul><li>应用阶段：</li><li>几何阶段：</li><li>光栅化阶段：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/25.png" alt="渲染管线" title="Tools"></li></ul><h2 id="标准着色-Lambert-Ambient-Specular"><a href="#标准着色-Lambert-Ambient-Specular" class="headerlink" title="标准着色(Lambert + Ambient + Specular)"></a>标准着色(Lambert + Ambient + Specular)</h2><ul><li>漫反射(Lambert)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/26.png" alt="渲染管线" title="Tools"></li><li>高光反射(Specular)<br>Phone和Blinn-Phone<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/27.png" alt="Phone" title="Tools"><br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/28.png" alt="Blinn-Phone" title="Tools"></li><li>环境光(Ambient)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/29.png" alt="标准着色" title="Tools"></li></ul><h2 id="重心坐标-Barycentric-Coordinates"><a href="#重心坐标-Barycentric-Coordinates" class="headerlink" title="重心坐标(Barycentric Coordinates)"></a>重心坐标(Barycentric Coordinates)</h2><p>通过三角形的重心坐标可以做到由三角形的三个顶点插值到重心坐标处的值，这个值包括可以包括任何信息(法线，颜色等)<br>同时可以扩展：三角形内的顶点 Q = a<em>P1 + b</em>P2 + c*P3， 且 a+b+c = 1 &amp;&amp; a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; c&gt;0<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/30.png" alt="重心坐标" title="Tools"></p><h2 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射(Texture Mapping)"></a>纹理映射(Texture Mapping)</h2><p>通过使用一张纹理图片定义不同像素处的不同值。这些值可以用来做：颜色，高度图，噪声图等等。<br>将纹理贴图的长宽定义成u,v，范围[0,1]区间方便计算。</p><h3 id="纹理贴图"><a href="#纹理贴图" class="headerlink" title="纹理贴图"></a>纹理贴图</h3><p>首先定义：一个像素在纹理中的名字叫做纹素(texel)，且一个像素内只存在同样的颜色信息<br>下面介绍纹理贴图在使用过程中遇到的问题以及如何优化</p><h4 id="当纹理图片太小"><a href="#当纹理图片太小" class="headerlink" title="当纹理图片太小"></a>当纹理图片太小</h4><ol><li>问题描述：如果需要渲染一个在屏幕上为200x200像素的网格而纹理只有100x100像素大小，这时为了达到完整的渲染会将纹理图片拉伸至200x200像素大小，拉伸后一个纹素相当于原来的4倍，然后网格通过uv读取，可以发现网格中的采样4个像素才相当于原先纹理的1个像素，这导致这些像素使用了相同的颜色信息，因此会出现模糊。</li></ol><p>解决方法：双线性插值(Bilinear Interpolation)，双立方插值(Bicubic Interpolation)</p><ol start="2"><li><p>双线性插值(Bilinear Interpolation)<br>核心思路：当采样一个点时，拿到其周围4个最近的采样坐标，拿到这4个采样像素的值，插值出当前采样点的颜色信息。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/31.png" alt="双线性插值" title="Tools"><br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/32.png" alt="双线性插值" title="Tools"></p></li><li><p>双立方插值(Bicubic Interpolation)<br>思路于双线性插值一样，只是采样点从4个增加到16个</p></li></ol><p><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/33.png" alt="当纹理图片太小" title="Tools"></p><h4 id="当纹理图片太大"><a href="#当纹理图片太大" class="headerlink" title="当纹理图片太大"></a>当纹理图片太大</h4><ol><li><p>问题描述：如果需要渲染一个三角形实际可能很大，但其在屏幕上占据像素为1x1px,而其纹理图片大小100x100px，进行普通采样只会获得其采样点对于的颜色，并不是我们想要的颜色，如下图可以看出摩尔纹以及锯齿(走样)问题。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/34.png" alt="当纹理图片太大" title="Tools"></p></li><li><p>在之前学习过走样形成的根本原因：采样频率低于变化频率，遇到这个问题当然可以通过超采样来避免，将1像素进行512个采样点采样，确实可以避免走样问题，采样结果如下，但是其消耗太大了：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/35.png" alt="超采样" title="Tools"></p></li><li><p>为什么普通点采样会出现上面的走样问题：越远的三角面在屏幕中占据的像素越少，而对于一个像素在纹理中占的范围就越大<br>这时通过点采样出来的信息一定是不满足的，采样范围的平均值反而更适合，那么怎么快速采样范围的平均值，一个新的概念使用MipMap。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/36.png" alt="采样范围" title="Tools"></p></li><li><p>MipMap</p></li></ol><ul><li><p>MipMap允许做快速，近似的正方形的范围查询。</p></li><li><p>MipMap是预先生成的，从原图比例开始，每次长宽变小为原图的一半，直到像素为1x1px。</p></li><li><p>MipMap只多使用了原图的1/3的内存空间。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/37.png" alt="MipMap" title="Tools"></p></li><li><p>计算当前在MipMap中采样第几层的纹理数据<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/38.png" alt="Compute MipMap" title="Tools"></p></li><li><p>三线性插值(Trilinear Interpolation)<br>在MipMap中如果得到层级在2.5层怎么正确获取颜色值？<br>同时拿到第2，3层，分别进行双线性插值，将其结果再进行一次插值。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/39.png" alt="Trilinear Interpolation" title="Tools"></p></li><li><p>MipMap处理后的效果图，出现了一个新的问题，远处过度模糊(OverBlur)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/40.png" alt="Trilinear Interpolation" title="Tools"></p></li></ul><ol start="5"><li>各向异性过滤(Anisotropic Filtering)<br>使用更多的内存保存更多分辨率的图片，MipMap只保存正方形大小，而各项异性过滤需要额外保存长方形的图片。<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/41.png" alt="各项异性过滤" title="Tools"><br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/42.png" alt="各项异性过滤" title="Tools"><br>效果图：<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/43.png" alt="各项异性过滤" title="Tools"></li></ol><h3 id="环境贴图-Environment-Map-立方体贴图-Cube-Map"><a href="#环境贴图-Environment-Map-立方体贴图-Cube-Map" class="headerlink" title="环境贴图(Environment Map)/立方体贴图(Cube Map)"></a>环境贴图(Environment Map)/立方体贴图(Cube Map)</h3><ul><li>环境贴图：将环境反射的颜色信息存储在一个球上<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/44.png" alt="法线贴图" title="Tools"></li><li>立方体贴图：将环境反射信息存储在立方体上<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/45.png" alt="法线贴图" title="Tools"></li></ul><h3 id="法线贴图-凹凸贴图-Bump-Mapping"><a href="#法线贴图-凹凸贴图-Bump-Mapping" class="headerlink" title="法线贴图/凹凸贴图(Bump Mapping)"></a>法线贴图/凹凸贴图(Bump Mapping)</h3><ul><li><p>作用于顶点法线上，使得表面看起来有一定凹凸感</p></li><li><p>作用原理：相当于将法线贴图的信息当作顶点的偏移值，就会造成一些顶点凹，一些凸，但是并不实际作用于顶点，只是用偏移后的顶点坐标再进行法线计算，就可以得到新的法线，将这个法线用于光照即得到新的视觉效果。</p></li><li><p>二维法线计算过程：如计算n，取贴图当前坐标值以及偏移1的值的差求出dp = c * [h(p+1) - h(p)],(注：h(p)，凹凸贴图定义的是切线，通过贴图拿到值)，逆时针旋转90度求得n，如图<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/46.png" alt="法线贴图" title="Tools"></p></li><li><p>三维法线计算过程： 注：其h(u)，也是通过贴图直接拿到值<br>(1) dp/du = c1 * [h(u+1) - h(u)]<br>(2) dp/dv = c2 * [h(v+1) - h(v)]<br>(3) 最终：n = (-dp/du, -dp/dv, 1)</p></li><li><p>位移法线：将贴图影响的偏移应用到顶点上，其效果更好<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/47.png" alt="法线贴图" title="Tools"></p></li></ul><h2 id="阴影-Shadow"><a href="#阴影-Shadow" class="headerlink" title="阴影 (Shadow)"></a>阴影 (Shadow)</h2><h1 id="几何-Geometry"><a href="#几何-Geometry" class="headerlink" title="几何(Geometry)"></a>几何(Geometry)</h1><p>什么是几何？几何就是拥有某种空间结构的形状。</p><h2 id="几何模型"><a href="#几何模型" class="headerlink" title="几何模型"></a>几何模型</h2><h2 id="曲线-Curves"><a href="#曲线-Curves" class="headerlink" title="曲线 (Curves)"></a>曲线 (Curves)</h2><h3 id="贝塞尔曲线-Bezier-Curves"><a href="#贝塞尔曲线-Bezier-Curves" class="headerlink" title="贝塞尔曲线 (Bézier Curves)"></a>贝塞尔曲线 (Bézier Curves)</h3><h2 id="曲面-Surfaces"><a href="#曲面-Surfaces" class="headerlink" title="曲面 (Surfaces)"></a>曲面 (Surfaces)</h2><h3 id="贝塞尔曲线-Bezier-Surfaces"><a href="#贝塞尔曲线-Bezier-Surfaces" class="headerlink" title="贝塞尔曲线 (Bézier Surfaces)"></a>贝塞尔曲线 (Bézier Surfaces)</h3><h2 id="模型-Mesh"><a href="#模型-Mesh" class="headerlink" title="模型 (Mesh)"></a>模型 (Mesh)</h2><ul><li>一个Mesh由很多</li><li>一个模型文件.obj中存储的数据内容包括：顶点，顶点切线，顶点法线，三角面(一组顶点链接的顺序并组成面)<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/48.png" alt="几何模型" title="Tools"></li></ul><h2 id="模型细分-Mesh-subdivision"><a href="#模型细分-Mesh-subdivision" class="headerlink" title="模型细分(Mesh subdivision)"></a>模型细分(Mesh subdivision)</h2><p>目的：达到更精细的显示效果<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/49.png" alt="模型细分" title="Tools"></p><h3 id="Loop-Subdivision-只适用于三角面细分"><a href="#Loop-Subdivision-只适用于三角面细分" class="headerlink" title="Loop Subdivision (只适用于三角面细分)"></a>Loop Subdivision (只适用于三角面细分)</h3><h3 id="Catmull-Clark-Subdivision-通常模型的细分-将多边形统一细分成四边形"><a href="#Catmull-Clark-Subdivision-通常模型的细分-将多边形统一细分成四边形" class="headerlink" title="Catmull-Clark Subdivision (通常模型的细分,将多边形统一细分成四边形)"></a>Catmull-Clark Subdivision (通常模型的细分,将多边形统一细分成四边形)</h3><h2 id="模型简化-Mesh-simplification"><a href="#模型简化-Mesh-simplification" class="headerlink" title="模型简化(Mesh simplification)"></a>模型简化(Mesh simplification)</h2><p>目的：减少渲染计算压力，避免不必要的计算<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/50.png" alt="模型简化" title="Tools"></p><h2 id="模型规则化-Mesh-regularization"><a href="#模型规则化-Mesh-regularization" class="headerlink" title="模型规则化(Mesh regularization)"></a>模型规则化(Mesh regularization)</h2><p>目的：提高模型质量<br><img src="/blog/2021/03/31/Graphics/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80/50.png" alt="模型规则化" title="Tools"></p><h1 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪(Ray Tracing)"></a>光线追踪(Ray Tracing)</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1X7411F744">GAMES101-现代计算机图形学入门-闫令琪</a></p>]]></content>
    
    
    <summary type="html">图形学基础学习</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>3D数学基础：图形与游戏开发</title>
    <link href="https://skierhou.github.io/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/"/>
    <id>https://skierhou.github.io/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/</id>
    <published>2021-03-12T06:30:01.000Z</published>
    <updated>2021-04-08T08:04:29.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h2><p>公式：a*b = |a||b|cosθ<br>几何意义：<br>(1) 判断前后<br>(2) 投影<br>用矩阵表示：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/01.png" alt="向量点乘矩阵表示" title="Tools"></p><h2 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h2><p>公式：|a×b| = |a||b|sinθ<br>几何意义：<br>(1) 判断左右<br>(2) 计算垂直a,b所形成平面的向量，该向量的朝向由左手定则(左手坐标系)，右手定则(右手坐标系)决定<br>用矩阵表示：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/02.png" alt="向量叉乘矩阵表示" title="Tools"></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ul><li><p>矩阵转置(M(T))：通俗解释,行变列，列变行<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/03.png" alt="矩阵转置" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/04.png" alt="矩阵转置" title="Tools"></p></li><li><p>矩阵乘法<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/05.png" alt="矩阵乘法" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/06.png" alt="矩阵乘法" title="Tools"></p></li><li><p>矩阵变换过程<br>(1)v=(x,y,z) 拆解成v=xp+yq+zr，p,q,r为一个坐标系的+x轴，+y轴，+z轴的单位向量<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/07.png" alt="矩阵乘法" title="Tools"><br>(2)其(p,q,r)可以拆分为一个3<em>3矩阵即<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/08.png" alt="矩阵乘法" title="Tools"><br>(3)矩阵变换相当于 变换矩阵</em>列向量=新的向量</p></li><li><p>旋转矩阵<br>(1) 2D旋转矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/09.png" alt="2D旋转矩阵" title="Tools"><br>(2) 3D绕正坐标轴旋转与2D同样<br>(3) 3D绕任意轴旋转 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/10.png" alt="2D旋转矩阵" title="Tools"></p></li><li><p>缩放矩阵<br>(1) 三轴的缩放因子kx,ky,kz 乘对应的p，q，r即是缩放矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/11.png" alt="缩放矩阵" title="Tools"><br>(2) 沿任意轴缩放矩阵 <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/12.png" alt="沿任意轴缩放矩阵" title="Tools"><br>(3) 关于沿任意轴缩放矩阵因子k的特殊解释：<br>  k=-1：镜像，n相当于平面法向量<br>  k=0：投影，n相当于平面法向量<br>  k&gt;0：普通缩放</p></li><li><p>切变 (扭曲变换)<br>一个/多个轴的坐标被另外一个轴以及一个/多个系数影响，2D切变如：将y乘因子s再加到x轴上，x’ = x + y*s。可以解释为，切变y轴，因子s，x轴受y轴切变影响<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/13.png" alt="切变" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/14.png" alt="切变" title="Tools"></p></li><li><p>行列式 (矩阵M的行列式表示为：|M|)<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/16.png" alt="行列式" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/17.png" alt="行列式" title="Tools"></p></li><li><p>余子式 (M(ij)表示从M矩阵中去掉第 i 行以及第 j 列后剩余的矩阵)<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/18.png" alt="余子式" title="Tools"></p></li><li><p>代数余子式<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/19.png" alt="代数余子式" title="Tools"></p></li><li><p>行列式性质<br>(1).|A*B|=|A||B|<br>(2).|M(T)|=|M|     注：M(T)为M的转置<br>(3).矩阵任意行或列都为零，则行列式为零<br>(4).交换矩阵的任意两行或两列，行列式变负<br>(5).任意行或列的非零积加到另一行或列上，行列式值不变<br>(6).行列式的值=2D中的面积，3D中的体积<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/20.png" alt="行列式性质" title="Tools"></p></li><li><p>矩阵的逆 M(-1)<br>矩阵的逆 公式： “标准伴随矩阵” / 行列式 = 矩阵的逆<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/21.png" alt="矩阵的逆" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/22.png" alt="矩阵的逆" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/23.png" alt="矩阵的逆" title="Tools"></p></li><li><p>正交矩阵 (通常表示为Q)<br>M * M(T) = I，M * M(-1) = I，M(T) = M(-1)<br>(1)M(T)，M(-1)也为正交矩阵<br>(2)|M| = +1或-1<br>(3)M(T)各行为单位向量且两两相交<br>几何意义：在已知该矩阵为正交矩阵的前提下，求矩阵的逆只需要求矩阵的转置而不用复杂计算。<br>在坐标转换中旋转矩阵都是正交矩阵</p></li><li><p>4X4齐次矩阵<br>平移是一个特殊的变换矩阵，在3X3矩阵中无法表示，因此添加了一个唯独存放平移信息，其中W分量为1表示向量，而W分量为0表示点<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/25.png" alt="4X4齐次矩阵" title="Tools"></p></li></ul><h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><ul><li>比较常见的表达旋转的方式，用三个旋转角度表示当前的旋转值，分别对应：绕x，y，z轴旋转度数。</li><li>优点：表达简单易懂，任意3个数表示欧拉角都是有效的</li><li>缺点：插值困难，如+190°与-170°实际表现是一样的但是普通插值会造成360°以上的旋转，旋转中某种特殊情况会出现万向锁问题</li></ul><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><ol><li>Q = [w v] = [w x y z]</li><li>单位四元数：Q = [1 0]</li><li>带入角度以及旋转轴：<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/26.png" alt="四元数" title="Tools"></li><li>四元数的模<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/27.png" alt="四元数" title="Tools"><br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/28.png" alt="四元数" title="Tools"></li><li>四元数的共轭：q(*) ，向量变负<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/29.png" alt="四元数" title="Tools"></li><li>四元数的逆：q(-1) * q = [1 0] （单位四元数），由共轭除以模获得<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/30.png" alt="四元数" title="Tools"></li><li>四元数的乘法（叉乘）：（满足乘法结合律，不满足交换律）<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/31.png" alt="四元数" title="Tools"></li><li>使用四元数旋转<br>标准3D坐标（x,y,z）转成p=[0 (x,y,z)]，q为旋转矩阵：[cos(θ/2) n*sin(θ/2)]<br>再通过以下公式<br>由右向左旋转： <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/32.png" alt="四元数" title="Tools"><br>由左向右旋转： <img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/33.png" alt="四元数" title="Tools"></li><li>四元数的差：计算四元数’a’旋转到’b’的角位移，用’d’表示 a*d = b ，同时左乘一个a的逆（四元数不支持除法）<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/34.png" alt="四元数" title="Tools"></li><li>四元数点乘 几何意义：a·b的绝对值越大，说明a与b角位移越相似<br><img src="/blog/2021/03/12/Graphics/3D%20Math%20Primer%20for%20Graphics%20and%20Game%202nd/35.png" alt="四元数" title="Tools"></li><li>四元数求幂：（比较常用）<br>一个四元数q(1/3)  表示1/3的q的角位移;  q(2)：两倍q的角位移</li></ol><h1 id="几何图元"><a href="#几何图元" class="headerlink" title="几何图元"></a>几何图元</h1><ul><li>自由度概念：自由度是决定一个图元可用的最少参数。 如：球：半径，矩形：长，宽，高</li><li>边界球检测相交</li><li>AABB包围盒检测相交：矩形的边于世界坐标系平行，满足相交条件Xmin &lt;= X &lt;= Xmax , Ymin &lt;= Y &lt;= Ymax , Zmin &lt;= Z &lt;= Zmax<br>关于AABB包围盒的变换，当物体变换时，并不能直接设置AABB盒子(旋转等，盒子大小会变化)，而需要重新计算</li><li>点到平面的距离计算：取平面任意一点，得向量a以及于平面的夹角θ，sinθ*|a|即最短距离</li><li>三角形面积计算：1.bh/2 ，2.海伦公式(在不知道高的情况下)：</li><li>三角形重心，内心，外心计算， <strong>重心</strong>：三角形平衡点，<strong>内心</strong>：到三条边距离相等，<strong>外心</strong>：到三个顶点距离相等</li><li>证明点在三角形内部，只需要用三角形的三个点于点P的向量分别于其三条边的向量做叉乘，求得点P在边的左侧或右侧，但三条边都在内部则点P在三角形内部</li></ul><h1 id="几何检测-重点-重复查看"><a href="#几何检测-重点-重复查看" class="headerlink" title="几何检测 (重点 重复查看)"></a>几何检测 (重点 重复查看)</h1><h1 id="三角网格-没看懂"><a href="#三角网格-没看懂" class="headerlink" title="三角网格 (没看懂)"></a>三角网格 (没看懂)</h1><h1 id="图形数学"><a href="#图形数学" class="headerlink" title="图形数学"></a>图形数学</h1><h1 id="可见性检测"><a href="#可见性检测" class="headerlink" title="可见性检测"></a>可见性检测</h1>]]></content>
    
    
    <summary type="html">3D数学基础：图形与游戏开发</summary>
    
    
    
    <category term="Graphics" scheme="https://skierhou.github.io/categories/Graphics/"/>
    
    
    <category term="Math" scheme="https://skierhou.github.io/tags/Math/"/>
    
    <category term="Graphics" scheme="https://skierhou.github.io/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Addressable 深度理解与使用</title>
    <link href="https://skierhou.github.io/2021/03/05/Unity/Resource/Addressable/"/>
    <id>https://skierhou.github.io/2021/03/05/Unity/Resource/Addressable/</id>
    <published>2021-03-05T06:30:01.000Z</published>
    <updated>2021-03-10T04:48:10.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Addressable是什么"><a href="#Addressable是什么" class="headerlink" title="Addressable是什么"></a>Addressable是什么</h2><p>是Unity官方出的资源管理器，Addressable即可寻址的资源系统<br>Addressable的优点：</p><ul><li>通过一个key，可以直接获取资源，不需要在意资源的实际位置</li><li>有完整的可视化界面，不需要写大量资源管理代码即可管理资源</li><li>方便自定义打包，自带增量更新等</li></ul><h2 id="Addressable的使用心得"><a href="#Addressable的使用心得" class="headerlink" title="Addressable的使用心得"></a>Addressable的使用心得</h2><ul><li><p>操作界面入口<br><img src="/blog/2021/03/05/Unity/Resource/Addressable/01.png" alt="Tools" title="Tools"></p></li><li><p>初次打开需要创建Setting之后会看到Assets目录下的文件结构，先做简单介绍后面在工具使用时会依次讲到所有资源文件使用方式</p><table><thead><tr><th align="left">路径</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">AddressableAssetsData</td><td align="left"><strong>根目录，AddressableAssetSettings是整个Addressable设置</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroups</td><td align="left"><strong>资源管理组，管理多个Schema处理该组内资源的读取/加载/保存等逻辑</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroups/Schemas</td><td align="left"><strong>处理模式，处理数据的实际逻辑类，继承自AddressableAssetGroupSchema，默认提供了三个Schema，分别对应两个AssetGroups：Built In Data以及Default Local Group</strong></td></tr><tr><td align="left">AddressableAssetsData/AssetGroupTemplates</td><td align="left"><strong>这个路径下只是一个模板，在创建Group时会复制一份这个模板</strong></td></tr><tr><td align="left">AddressableAssetsData/DataBuilders</td><td align="left"><strong>在不同构建模式下，在游戏运行中的数据提供者，可选择项有InstanceProvider以及SceneProvider</strong></td></tr><tr><td align="left">AddressableAssetsData/Windows</td><td align="left"><strong>这个路径是打包才会自动生成的本地对应文件，记录上一次打包信息，可以用于增量更新，通过保存的文件判断哪些文件需要更新</strong></td></tr></tbody></table></li><li><p>Groups界面，管理所有Groups，即资源组，默认资源组存在两个:<strong>Build In Data</strong>，<strong>Default Local Group</strong>。</p><table><thead><tr><th align="left">Group</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">Build In Data</td><td align="left">点击Build In Data，对应Assets/AddressableAssetsData/AssetGroups/Build In Data.asset，只有两个设置：包含Resources路径下资源，BuildSetting设置的场景，即这部分资源会打进游戏包中，不进行资源加载，这个资源组官方已经设置好了，不需要做任何其他设置。 Build In Data.asset目前没有方式主动创建，不要误删即可（不然只能重新创建数据了）。</td></tr><tr><td align="left">Default Local Group</td><td align="left">对应Assets/AddressableAssetsData/AssetGroups/Default Local Group.asset，其中包含两个Schema：<strong>BundledAssetGroupSchema</strong>,<strong>ContentUpdateGroupSchema</strong>。 ContentUpdateSchema：只有一个设置，设置为全量更新或者增量更新，全量：更新即替换，增量：不替换原资源情况下多打一个资源包，BundledAssetGroupSchema：设置资源打包/加载路径，以及Bundle模式：crc缓存，bundle名，以什么方式分组等，通常使用默认即可</td></tr></tbody></table></li><li><p>Groups界面操作<br>资源可以通过拖拽文件夹，拖拽单个文件，或再Inspector面板直接勾选Addressable</p><table><thead><tr><th align="left">按钮</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">Profile</td><td align="left">路径配置，远程/本地的加载/构建路径，<strong>不管构建再哪个路径底下，加载Key都保持不变，这也是Addressable基本思想所在</strong></td></tr><tr><td align="left">Tools</td><td align="left">工具，可以快捷打开所有界面，关于’Check For Content Update’按钮是用于增量更新的，当group设置为增量模式，且相比较上一次存在变换，点击这个按钮增量打包，会产生一个新的资源组管理增量资源，增量打包后原资源不会删除，但对应key下的hash指向的资源会变成新包资源。</td></tr><tr><td align="left">Play Mode Script</td><td align="left">游戏中使用的资源加载模式：1.fastest：AssetsDataset加载，2.advanced：模拟ab包加载，3.requires built groups：实际ab包加载。选择每种模式后对应AddressableAssetsData/DataBuilders的构建设置也会修改，对应1.BuildScriptFastMode,2.BuildScriptPackedPlayMode,3.BuildScriptVirtualMode，其中多的一个BuildScriptPackedMode为实现构建资源时的默认构建模式</td></tr><tr><td align="left">Build</td><td align="left">New Build 下的按钮对应AddressableAssetsData/DataBuilders/BuildScriptPackedMode.asset，第二个按钮即增量更新按钮与Tools中的Content Update配合使用，Clean按钮即清除已构建的资源</td></tr></tbody></table></li><li><p>Profile 界面：管理Profile，设置打包，加载等路径</p></li><li><p>AddressableAssetSettings设置：通常使用默认即可，对应按钮名称标记很明显了，不进行详细介绍</p></li><li><p>EventViewer界面：查看运行时资源使用情况，启动时需设置AddressableAssetSettings中的Send Profiler Event</p></li><li><p>Analyze界面：用于分析资源的依赖关系，Fixable Rule：可修复的规则，分析器自动修复，UnFixable Rule：不可修复的规则，会列出来需要手动修复</p></li><li><p>Hosting界面：创建远程或者本地的服务器，方便测试，默认使用HTTP Service，查看HttpHostingService.cs代码可自定义服务器模式</p></li></ul><h2 id="Addressable的使用说明"><a href="#Addressable的使用说明" class="headerlink" title="Addressable的使用说明"></a>Addressable的使用说明</h2><h4 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h4><p>Addressable中加载任何资源都需要异步加载，不过可以使用Task多线程方式加载，使用非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField]</span><br><span class="line">    private string _entryName &#x3D; &quot;Assets&#x2F;Prefabs&#x2F;Cube.prefab&quot;;</span><br><span class="line"></span><br><span class="line">    public AssetReference ar;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用Task异步加载</span><br><span class="line">        StartAsync();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用AssetReference引用直接加载</span><br><span class="line">        ar.LoadAssetAsync&lt;GameObject&gt;().Completed +&#x3D; LoadFinish;</span><br><span class="line">        ar.InstantiateAsync(Vector3.one, Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void LoadFinish(AsyncOperationHandle&lt;GameObject&gt; loadHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        if (loadHandle.IsDone &amp;&amp; loadHandle.Status &#x3D;&#x3D; AsyncOperationStatus.Succeeded)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;这里Result是预制体</span><br><span class="line">            Debug.Log(loadHandle.Result);</span><br><span class="line">            Addressables.Release(loadHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private async Task StartAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        var instance &#x3D; await Addressables.InstantiateAsync(_entryName).Task;</span><br><span class="line">        Addressables.ReleaseInstance(instance);</span><br><span class="line">        instance &#x3D; await Addressables.InstantiateAsync(_entryName).Task;</span><br><span class="line">        Addressables.ReleaseInstance(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><p>使用Addressables提供的接口即可完成更新检查，以及下载，详细请阅读代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private async void UpdateAndDownLoad()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 检查更新</span><br><span class="line">    AsyncOperationHandle&lt;List&lt;string&gt;&gt; updateHandle &#x3D; Addressables.CheckForCatalogUpdates(false);</span><br><span class="line">    await updateHandle.Task;</span><br><span class="line">    if (updateHandle.Status &#x3D;&#x3D; AsyncOperationStatus.Succeeded)</span><br><span class="line">    &#123;</span><br><span class="line">        updateList &#x3D; updateHandle.Result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.开始更新</span><br><span class="line">    AsyncOperationHandle&lt;List&lt;IResourceLocator&gt;&gt; updateHandler &#x3D; Addressables.UpdateCatalogs(updateList, false);</span><br><span class="line">    await updateHandler.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3.获取更新资源的key</span><br><span class="line">    List&lt;string&gt; updateKeys &#x3D; new List&lt;string&gt;();</span><br><span class="line">    foreach (IResourceLocator locator in updateHandler.Result)</span><br><span class="line">    &#123;</span><br><span class="line">        if (locator is ResourceLocationMap map)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var item in map.Locations)</span><br><span class="line">            &#123;</span><br><span class="line">                if (item.Value.Count &#x3D;&#x3D; 0) continue;</span><br><span class="line">                string key &#x3D; item.Key.ToString();</span><br><span class="line">                if (int.TryParse(key, out int resKey)) continue;</span><br><span class="line"></span><br><span class="line">                if (!updateKeys.Contains(key))</span><br><span class="line">                    updateKeys.Add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4.判断下载资源大小</span><br><span class="line">    AsyncOperationHandle&lt;long&gt; downLoadSize &#x3D; Addressables.GetDownloadSizeAsync(updateKeys);</span><br><span class="line">    await downLoadSize.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5.下载</span><br><span class="line">    AsyncOperationHandle downLoad &#x3D; Addressables.DownloadDependenciesAsync(updateKeys, MergeMode.None);</span><br><span class="line">    await downLoad.Task;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 6.清除</span><br><span class="line">    Addressables.Release(updateHandler);</span><br><span class="line">    Addressables.Release(downLoad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Addressable的扩展"><a href="#Addressable的扩展" class="headerlink" title="Addressable的扩展"></a>Addressable的扩展</h2><h3 id="自动化打包"><a href="#自动化打包" class="headerlink" title="自动化打包"></a>自动化打包</h3><ul><li>在实际项目中资源打包通常不会人工手动设置，而是通过一些模式自动化打包，Addressable虽然提供了非常完善的功能界面，但是打包自动化还是需要用户自己扩展。以下是我个人理解的打包策略，与上篇<a href="../AssetBundle/index">AssetBundle文章</a>的一样的策略，一个文件夹下所有的资源都按当前文件夹名称设置AB包一个文件一个AB包，子文件递归设置。</li><li>Groups界面可以直接拖拽文件夹进去，但是打包设置中只有三个选项：1.一组打成一个包，2.文件夹打成一个包(一次拖进去的文件夹子目录也包括进去)，3.按标签打包。我这里使用的是按标签打包，相同标签一个包。</li><li>扩展代码请查看末尾的项目。</li></ul><p><img src="/blog/2021/03/05/Unity/Resource/Addressable/02.PNG" alt="自动化打包" title="自动化打包"></p><h3 id="场景加载以及游戏物体实例化扩展"><a href="#场景加载以及游戏物体实例化扩展" class="headerlink" title="场景加载以及游戏物体实例化扩展"></a>场景加载以及游戏物体实例化扩展</h3><ul><li>Addressable默认有提供InstanceProvider以及SceneProvider，但是InstanceProvider中并没有使用到对象池，且在使用Addressables.InstantiateAsync()多次后，同样的资源引用会存在多个，可以通过EventViewer中看到资源占用的堆内存空间，通过继承IInstanceProvider以及ISceneProvider自己实现加载完实际资源后的实例化对象即可。其实就是将对象池写入IInstanceProvider，查看末尾的项目代码其中有InstanceProviderHelper.cs实现。</li></ul><blockquote><p><a href="https://github.com/Skierhou/ResourceManager">项目路径 https://github.com/Skierhou/ResourceManager</a></p></blockquote>]]></content>
    
    
    <summary type="html">Addressable原理，使用说明，扩展</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Resource" scheme="https://skierhou.github.io/categories/Unity/Resource/"/>
    
    <category term="Addressable" scheme="https://skierhou.github.io/categories/Unity/Resource/Addressable/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="Addressable" scheme="https://skierhou.github.io/tags/Addressable/"/>
    
  </entry>
  
  <entry>
    <title>AssetBundle 注意事项以及使用</title>
    <link href="https://skierhou.github.io/2021/03/05/Unity/Resource/AssetBundle/"/>
    <id>https://skierhou.github.io/2021/03/05/Unity/Resource/AssetBundle/</id>
    <published>2021-03-05T06:30:01.000Z</published>
    <updated>2021-03-10T02:11:57.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AssetBundle是什么"><a href="#AssetBundle是什么" class="headerlink" title="AssetBundle是什么"></a>AssetBundle是什么</h2><p>AssetBundle是Unity的资源管理包，用于资源加载卸载。<br>AssetBundle分为数据头和数据段：</p><ul><li>数据头：存储一些设置，如压缩类型，索引，manifest等</li><li>数据段：存储序列化后Asset数据</li></ul><p>AssetBundle的优点：</p><ul><li>自带压缩算法</li><li>方便管理，适合增量更新</li><li>可随意加载卸载Asset</li><li>内部包含Asset的引用关系，不需要怕引用丢失</li></ul><h2 id="AssetBundle的压缩"><a href="#AssetBundle的压缩" class="headerlink" title="AssetBundle的压缩"></a>AssetBundle的压缩</h2><p>压缩格式分为：LZ4，LZMA</p><ul><li>LZMA打包成字节流，包体会比LZ4小</li><li>LZMA打包运行时占用运行内存空间会比LZ4大很多,在使用是LZMA包在初始化时先解压再压缩成LZ4使用，个人理解实际情况：LZMA解压完的数据会先存在内存中，再压缩成LZ4，但是使用时又需要将LZ4解压，感觉上是极度没必要的。</li><li>通常情况下使用LZ4打包，不需要考虑太多内存空间的事，只是包体会稍微大一些</li></ul><h2 id="AssetBundle的读取"><a href="#AssetBundle的读取" class="headerlink" title="AssetBundle的读取"></a>AssetBundle的读取</h2><p>有两种方式LoadFromMemory，LoadFromFile</p><ul><li>LoadFromMemory：需要反复读取byte数组，会有额外的内存消耗</li><li>LoadFromFile: 直接从硬盘文件中读取，注意：LoadFromFile在Editor模式下会直接读取整个AssetBundle，而运行时只会读取AssetBundle的头数据，在Editor下性能分析需要注意这一项</li></ul><h2 id="AssetBundle的卸载"><a href="#AssetBundle的卸载" class="headerlink" title="AssetBundle的卸载"></a>AssetBundle的卸载</h2><p>AssetBundle.UnLoad(bool unloadAllLoadedObject)</p><ul><li>卸载时需要注意，当使用UnLoad(false)，且有实际使用资源时，该资源并不会卸载会缓存一份，再下一次加载出AssetBundle时，会复制另一份资源，导致同样的资源内存中存在两份。</li><li>卸载时使用UnLoad(true),会卸载所有加载资源，使用这类资源的将丢失，但是下一次加载出AssetBundle时，内存中只会有一份资源</li></ul><h2 id="AssetBundle的依赖关系"><a href="#AssetBundle的依赖关系" class="headerlink" title="AssetBundle的依赖关系"></a>AssetBundle的依赖关系</h2><p>编辑器下由AssetDatabase 和 AssetImporter管理，AssetDatabase管理依赖，AssetImporter为AssetBundle数据</p><ul><li>通过AssetDatabase.GetDependencies(path) 来获取该Asset的依赖文件</li><li>通过AssetImporter可以修改Asset的AssetBundle设置</li><li>实际打包时，会将Asset的依赖关系打进manifest文件，但是加载一个AssetBundle时Unity并不会将其依赖AssetBundle一同加载出来，需要自己主动进行管理</li></ul><h2 id="AssetBundle在项目中使用"><a href="#AssetBundle在项目中使用" class="headerlink" title="AssetBundle在项目中使用"></a>AssetBundle在项目中使用</h2><p>通常在实际项目中使用并不会去手动一一设置AssetBundle名称再进行打包，而会根据项目需求自定义打包模式，下面由我介绍一下个人感觉非常实用的打包策略。</p><ul><li>将一个文件夹路径下所有的文件统一自动打成AssetBundle包，所有Asset按文件夹名称设置ABName并递归所有子文件夹，使用这种做法只需要管理好项目资源的目录结构就可以很好管理AssetBundle了</li><li>在打包的同时将保存所有Asset的数据：crc, path, assetName, assetBundleName, dependceAssetBundles。保存成二进制一同打进config包中,游戏启动先加载config，在加载一个资源时再加载对应包以及依赖包即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[System.Serializable]</span><br><span class="line">public class AssetBundleConfig</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 资源路径转crc</span><br><span class="line">    public uint crc;</span><br><span class="line">    &#x2F;&#x2F; 资源路径</span><br><span class="line">    public string path;</span><br><span class="line">    &#x2F;&#x2F; 资源包名</span><br><span class="line">    public string assetBundleName;</span><br><span class="line">    &#x2F;&#x2F; 资源名：从资源包中加载的名称</span><br><span class="line">    public string assetName;</span><br><span class="line">    &#x2F;&#x2F; 依赖包</span><br><span class="line">    public List&lt;string&gt; dependceAssetBundles;</span><br><span class="line">&#125;</span><br><span class="line">[System.Serializable]</span><br><span class="line">public class AssetBundleContainer</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;AssetBundleConfig&gt; configList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现两个管理器AssetBundleManager，以及ResourceManager，使用时ResourceManager按路径加载资源，ResourceManager从AssetBundleManager拿到AssetBundle包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface IAssetBundleManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 同步加载AB包</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    AssetBundle LoadAssetBundle(string assetBundleName);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 异步加载AB包</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    void LoadAssetBundleAsync(string assetBundleName, Action&lt;AssetBundle&gt; callback);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 卸载AB包</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    void UnLoadAssetBundle(string assetBundleName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IResourceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 同步加载资源</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    T LoadAsset&lt;T&gt;(string path) where T : UnityEngine.Object;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 异步加载资源</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    void LoadAssetAsync(string path, Action&lt;UnityEngine.Object, object&gt; onLoaded, int priority &#x3D; 0, object userData &#x3D; null);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 卸载资源</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    void UnLoadAsset(string path, bool isDestroy &#x3D; false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><a href="https://github.com/Skierhou/ResourceManager">项目路径 https://github.com/Skierhou/ResourceManager</a></p></blockquote>]]></content>
    
    
    <summary type="html">AssetBundle使用以及扩展</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="Resource" scheme="https://skierhou.github.io/categories/Unity/Resource/"/>
    
    <category term="AssetBundle" scheme="https://skierhou.github.io/categories/Unity/Resource/AssetBundle/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="AssetBundle" scheme="https://skierhou.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法</title>
    <link href="https://skierhou.github.io/2021/03/02/Base/markdown/"/>
    <id>https://skierhou.github.io/2021/03/02/Base/markdown/</id>
    <published>2021-03-02T06:30:01.000Z</published>
    <updated>2021-03-10T04:40:45.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>初于方便写文章考虑，整理一下markdown语法规则 <a href="https://www.jianshu.com/p/191d1e21f7ed">转载链接</a></p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt;&gt; 引用</span><br><span class="line">&gt;&gt;&gt; 引用</span><br></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><hr><hr><hr><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line">参考：![default](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;butterfly-extsrc@1&#x2F;img&#x2F;default.jpg &quot;标题&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="default" title="标题"></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">参考：[简书](http:&#x2F;&#x2F;jianshu.com)</span><br></pre></td></tr></table></figure><p><a href="http://jianshu.com/">简书</a></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无序： * - +</span><br><span class="line">有序： 1. 2. 3.</span><br></pre></td></tr></table></figure><ul><li>无序</li><li>无序</li><li>无序</li></ul><ol><li>有序</li><li>有序</li><li>有序</li></ol><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">    代码块...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;sequence</span><br><span class="line">Title:时序图示例</span><br><span class="line">客户端-&gt;服务端: 我想找你拿下数据 SYN</span><br><span class="line">服务端--&gt;客户端: 我收到你的请求啦 ACK+SYN</span><br><span class="line">客户端-&gt;&gt;服务端: 我收到你的确认啦，我们开始通信吧 ACK</span><br><span class="line">Note right of 服务端: 我是一个服务端</span><br><span class="line">Note left of 客户端: 我是一个客户端</span><br><span class="line">Note over 服务端,客户端: TCP 三次握手</span><br><span class="line">participant 观察者</span><br><span class="line"></span><br><span class="line">这里也不支持流程图</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;初于方便写文章考虑，整理一下markdown语法规则 &lt;a href=&quot;https://www.jianshu.com/p/191d1e21f7ed&quot;&gt;转载链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="通用" scheme="https://skierhou.github.io/categories/%E9%80%9A%E7%94%A8/"/>
    
    
    <category term="Markdown" scheme="https://skierhou.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>2021年规划</title>
    <link href="https://skierhou.github.io/2021/03/01/Plan/plan2021/"/>
    <id>https://skierhou.github.io/2021/03/01/Plan/plan2021/</id>
    <published>2021-03-01T06:30:01.000Z</published>
    <updated>2021-04-09T05:00:32.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每年需持续整理个人任务，个人任务可以规划为年度任务，月任务，详细再到周任务<br>记录个人任务完成情况，如未完成，需写下原因以检讨<br>在工作空闲时间，假期，周末等时期完成的任务</p></blockquote><h1 id="年度任务规划"><a href="#年度任务规划" class="headerlink" title="年度任务规划"></a>年度任务规划</h1><table><thead><tr><th align="left">任务描述</th><th align="center">完成情况(%)</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left"><strong>客户端方向</strong></td><td align="center"></td><td align="left"></td></tr><tr><td align="left">Dots技术栈深度学习，需要能做到运用到项目中去，使用Dots制作鱼群，鸟群等效果Demo</td><td align="center">10%</td><td align="left">目前已掌握基础使用</td></tr><tr><td align="left">EGameTang框架深度学习，掌握EGameTang网络架构原理并制作联机RPGDemo</td><td align="center">10%</td><td align="left">目前已掌握基础使用</td></tr><tr><td align="left">GameFramework框架深度学习，学习其代码规范，底层原理，架构思想</td><td align="center">50%</td><td align="left">目前以运用于项目中</td></tr><tr><td align="left">Ability技能系统搭建完成，并完成多个模式的Demo</td><td align="center">50%</td><td align="left">技能系统已搭建，准备Demo即可</td></tr><tr><td align="left">AI行为系统的深度学习，主要参考UE4 AI系统</td><td align="center">10%</td><td align="left">掌握基本使用</td></tr><tr><td align="left">AssetBundle,Addressable的深度学习</td><td align="center">80%</td><td align="left"></td></tr></tbody></table><p><strong>TA方向</strong>||<br><a href="https://www.bilibili.com/video/BV1X7411F744">Game101 计算机图形学入门</a>|50%|看完教程后总结<br>OpenGL，看完书籍红皮书，蓝皮书|10%|<br>3D数学基础，总结提炼|50%|<br>UnityShader，光照GI，渲染管线|20%|<br>Unity实现天气系统，下雨打雷，下雪，风|0%|<br>Unity草地|50%|<br>ShaderGraph使用|0%|<br>PS，基本使用|0%|<br>3DMax，基本使用|0%|<br>粒子特效制作|0%|<br>Real-Time Rendering 3rd书籍详细学习|0%|在3D数学UnityShader编程OpenGL都完成后学习<br>GPU Gems等系列书籍|0%|放到将TA基础都看完了之后进行学习</p><p><strong>整体技术方向</strong>||<br>完成一款游戏Demo,未来考虑长期制作并发布的Demo|0%|</p><h1 id="月任务规划"><a href="#月任务规划" class="headerlink" title="月任务规划"></a>月任务规划</h1><table><thead><tr><th align="center">时间(月)</th><th align="center">任务描述</th><th align="center">完成情况(%)</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">无</td><td align="center">无</td><td align="center">3月启动</td></tr><tr><td align="center">2</td><td align="center">无</td><td align="center">无</td><td align="center">3月启动</td></tr><tr><td align="center">3</td><td align="center">1.GF框架深度学习，代码解剖；2.PS,3DMax,粒子特效制作；3.AssetBundle,Addressable的深度学习</td><td align="center">80%</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">1.OpenGL红皮书，蓝皮书；2.EGameTang框架深度学习，代码解剖；3.整理个人项目结构，第一个项目单机可热更 4. <a href="https://www.bilibili.com/video/BV1X7411F744">Game101 计算机图形学入门</a> 5.PS,3DMax,粒子特效制作</td><td align="center">80%</td><td align="center">无</td></tr><tr><td align="center">5</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">6</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">7</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">8</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">9</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">10</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">11</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">12</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr></tbody></table><!-- # 关于生活的规划任务描述|注释:--|:--**年度目标**|改善肠胃，健身，增肥20斤|存钱***元|**月目标**|每月消费<4500 (包括房租)|每月增重>2斤|**日目标**|每日消费<60| -->]]></content>
    
    
    <summary type="html">每年需整理的任务规划</summary>
    
    
    
    <category term="年度规划" scheme="https://skierhou.github.io/categories/%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"/>
    
    
    <category term="Plan" scheme="https://skierhou.github.io/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework 底层解析</title>
    <link href="https://skierhou.github.io/2021/03/01/Unity/GameFramework/GF1/"/>
    <id>https://skierhou.github.io/2021/03/01/Unity/GameFramework/GF1/</id>
    <published>2021-03-01T06:30:01.000Z</published>
    <updated>2021-03-22T02:34:23.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对GF的源码解析，学习设计思路，学习代码规范 <a href="https://gameframework.cn/">GF官网</a> <a href="https://gameframework.cn/api/index.html">GF-API</a><br>看了GF的源码，感觉自己之前写的代码都是一堆垃圾!!!<br>源码阅读建议：与<a href="https://github.com/EllanJiang/StarForce">StarForce</a>项目一同阅读</p></blockquote><h2 id="Base层"><a href="#Base层" class="headerlink" title="Base层"></a>Base层</h2><p>数据处理器，序列化工具，Log，事件池，引用池，任务代理池，其他扩展：Action，Func，变量封装(用于自定义数据结构)，自定义链表</p><h3 id="DataProvider-数据处理器"><a href="#DataProvider-数据处理器" class="headerlink" title="DataProvider 数据处理器"></a>DataProvider 数据处理器</h3><p>主要细节只需要看IDataProvider，IDataProviderHelper的实现上<br>IDataProvider，IDataProviderHelper主要实现2个接口：ReadData，ParseData</p><ol><li>IDataProvider 从ResourceManager中读取资源，为数据提供者</li><li>IDataProviderHelper负责对具体数据的解析，为数据提供者帮助接口，<strong>用户使用上只需要实现帮助类即可</strong><br>对于IDataProviderHelper可能会引起误区，这里的ReadData是在IDataProvider读取资源成功时调用，这时已经拿到了需要的资源，可以直接使用或者再主动调用ParseData解析数据再使用。</li><li>执行顺序如：<br>ConfigManager.ReadData()-&gt;IDataProvider.ReadData()-&gt;读取成功后-&gt;IDataProviderHelper.ReadData()，<br>这时主动调用ConfigManager.ParseData()-&gt;IDataProvider.ParseData()-&gt;IDataProviderHelper.ParseData()</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">IDataProvider</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 数据提供者接口。</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;数据提供者的持有者的类型。&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IDataProvider&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据成功事件。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    event EventHandler&lt;ReadDataSuccessEventArgs&gt; ReadDataSuccess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据失败事件。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    event EventHandler&lt;ReadDataFailureEventArgs&gt; ReadDataFailure;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据更新事件。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    event EventHandler&lt;ReadDataUpdateEventArgs&gt; ReadDataUpdate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据时加载依赖资源事件。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    event EventHandler&lt;ReadDataDependencyAssetEventArgs&gt; ReadDataDependencyAsset;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;priority&quot;&gt;加载数据资源的优先级。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    void ReadData(string dataAssetName, int priority, object userData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 解析内容。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;要解析的内容二进制流。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt;</span><br><span class="line">    bool ParseData(byte[] dataBytes, int startIndex, int length, object userData);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 数据提供者辅助器接口。</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IDataProviderHelper&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAsset&quot;&gt;内容资源。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否读取数据成功。&lt;&#x2F;returns&gt;</span><br><span class="line">    bool ReadData(T dataProviderOwner, string dataAssetName, object dataAsset, object userData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 读取数据。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;内容二进制流。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否读取数据成功。&lt;&#x2F;returns&gt;</span><br><span class="line">    bool ReadData(T dataProviderOwner, string dataAssetName, byte[] dataBytes, int startIndex, int length, object userData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 解析内容。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataString&quot;&gt;要解析的内容字符串。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt;</span><br><span class="line">    bool ParseData(T dataProviderOwner, string dataString, object userData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 解析内容。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;要解析的内容二进制流。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt;</span><br><span class="line">    bool ParseData(T dataProviderOwner, byte[] dataBytes, int startIndex, int length, object userData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 释放内容资源。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAsset&quot;&gt;要释放的内容资源。&lt;&#x2F;param&gt;</span><br><span class="line">    void ReleaseDataAsset(T dataProviderOwner, object dataAsset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventPool-事件池"><a href="#EventPool-事件池" class="headerlink" title="EventPool 事件池"></a>EventPool 事件池</h3><p>实现事件接口：订阅，取消订阅，抛出事件，立即抛出事件</p><ol><li>Fire 抛出事件：线程安全，将待执行事件放入队列，下一帧执行</li><li>FireNow 立即抛出事件：线程不安全</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 摘要:</span><br><span class="line">&#x2F;&#x2F;     事件管理器接口。</span><br><span class="line">public interface IEventManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 摘要:</span><br><span class="line">    &#x2F;&#x2F;     抛出事件，这个操作是线程安全的，即使不在主线程中抛出，也可保证在主线程中回调事件处理函数，但事件会在抛出后的下一帧分发。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参数:</span><br><span class="line">    &#x2F;&#x2F;   sender:</span><br><span class="line">    &#x2F;&#x2F;     事件源。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;   e:</span><br><span class="line">    &#x2F;&#x2F;     事件参数。</span><br><span class="line">    void Fire(object sender, GameEventArgs e);</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 摘要:</span><br><span class="line">    &#x2F;&#x2F;     抛出事件立即模式，这个操作不是线程安全的，事件会立刻分发。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参数:</span><br><span class="line">    &#x2F;&#x2F;   sender:</span><br><span class="line">    &#x2F;&#x2F;     事件源。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;   e:</span><br><span class="line">    &#x2F;&#x2F;     事件参数。</span><br><span class="line">    void FireNow(object sender, GameEventArgs e);</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 摘要:</span><br><span class="line">    &#x2F;&#x2F;     设置默认事件处理函数。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参数:</span><br><span class="line">    &#x2F;&#x2F;   handler:</span><br><span class="line">    &#x2F;&#x2F;     要设置的默认事件处理函数。</span><br><span class="line">    void SetDefaultHandler(EventHandler&lt;GameEventArgs&gt; handler);</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 摘要:</span><br><span class="line">    &#x2F;&#x2F;     订阅事件处理函数。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参数:</span><br><span class="line">    &#x2F;&#x2F;   id:</span><br><span class="line">    &#x2F;&#x2F;     事件类型编号。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;   handler:</span><br><span class="line">    &#x2F;&#x2F;     要订阅的事件处理函数。</span><br><span class="line">    void Subscribe(int id, EventHandler&lt;GameEventArgs&gt; handler);</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 摘要:</span><br><span class="line">    &#x2F;&#x2F;     取消订阅事件处理函数。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 参数:</span><br><span class="line">    &#x2F;&#x2F;   id:</span><br><span class="line">    &#x2F;&#x2F;     事件类型编号。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;   handler:</span><br><span class="line">    &#x2F;&#x2F;     要取消订阅的事件处理函数。</span><br><span class="line">    void Unsubscribe(int id, EventHandler&lt;GameEventArgs&gt; handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>对Log进行封装，ILogHelper对Log的具体实现</p><h3 id="ReferencePool-引用池"><a href="#ReferencePool-引用池" class="headerlink" title="ReferencePool 引用池"></a>ReferencePool 引用池</h3><p>为了降低因大量产生类对象而导致的内存分配，设计了引用池的概念，来将用完的对象清理并缓存起来，供后续使用。<br>实现IReference接口，通过ReferencePool.Acquire<T>()获取</T></p><h3 id="TaskPool-任务池"><a href="#TaskPool-任务池" class="headerlink" title="TaskPool 任务池"></a>TaskPool 任务池</h3><p>这个任务池主要做资源异步加载，下载等异步操作的任务</p><ul><li>TaskBase：只是任务数据</li><li>ITaskAgent：任务代理，处理任务的具体行为<br>如DownloadAgent.cs处的使用，Agent只处理该Task中数据，并在执行中通知对应Helper执行具体下载逻辑</li><li>TaskInfo：用于Debug等展示的信息</li><li>TaskPool：任务池,管理ITaskAgent并执行</li></ul><h3 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable 变量"></a>Variable 变量</h3><p>变量封装</p><h3 id="Version-版本号"><a href="#Version-版本号" class="headerlink" title="Version 版本号"></a>Version 版本号</h3><p>方便版本号管理，版本号在资源更新时需要使用，判断旧资源与新资源的版本号。</p><h3 id="封装的基础类型"><a href="#封装的基础类型" class="headerlink" title="封装的基础类型"></a>封装的基础类型</h3><table><thead><tr><th align="left">类</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">GaneFrameworkAction</td><td align="left">封装多参数委托</td></tr><tr><td align="left">GameFrameworkFunc</td><td align="left">封装多参数委托</td></tr><tr><td align="left">GameFrameworkEntry</td><td align="left">游戏入口</td></tr><tr><td align="left">GameFrameworkEventArgs</td><td align="left">事件数据封装</td></tr><tr><td align="left">GameFrameworkException</td><td align="left">异常抛出封装</td></tr><tr><td align="left">GameFrameworkLinkedList</td><td align="left">带缓存的LinkedList（链表）</td></tr><tr><td align="left">GameFrameworkLinkedListRange</td><td align="left">有范围的链表，即理解为LinkedList中的一小段</td></tr><tr><td align="left">GameFrameworkModule</td><td align="left">模块的封装基类，统一管理各类模块Manager</td></tr><tr><td align="left">GameFrameworkMultiDictionary</td><td align="left">多值字典,Value为链表</td></tr><tr><td align="left">GameFrameworkSerializer</td><td align="left">序列化器,</td></tr></tbody></table><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>经过了对Base层的理解，Config层就很轻松弄明白了。<br>主要封装了数据读取，解析，获取。<br>执行顺序：<br>ConfigManager.ReadData()-&gt;IDataProvider.ReadData()-&gt;读取成功后-&gt;IDataProviderHelper.ReadData()，<br>ConfigManager.ParseData()-&gt;IDataProvider.ParseData()-&gt;IDataProviderHelper.ParseData()<br>使用上只需要：修改对应Helper即可</p><h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><p>树状数据节点，个人使用最多就是GetOrAddNode(string)</p><h2 id="DataTable"><a href="#DataTable" class="headerlink" title="DataTable"></a>DataTable</h2><ul><li>使用DataTable，扩展一下可以很方便与excel使用</li><li>实现Helper类解析Excel产生的bytes数据即可</li></ul><table><thead><tr><th align="left">接口</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">IDataTable</td><td align="left">表(数据容器,管理多条数据)</td></tr><tr><td align="left">IDataRow</td><td align="left">数据项(一条数据)</td></tr><tr><td align="left">IDataHelper</td><td align="left">数据解析帮助类</td></tr><tr><td align="left">IDataTableManager</td><td align="left">管理所有表</td></tr></tbody></table><h2 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h2><p>运行时的Debugger界面，使用上很方便，具体就是打印多种不同信息</p><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>下载任务都是异步操作，因此需要等待，这时Base层定义好的TaskPool就有了作用<br>下载步骤：</p><ol><li>DownloadTask携带下载数据：下载路径，保存路径，下载状态，缓冲区大小等</li><li>DownloadAgent处理任务数据，监听下载状态变化：下载数据更新，下载长度更新，下载完成，下载失败</li><li>IDownloadAgentHelper实现实际下载逻辑，如UnityWebRequestDownloadAgentHelper为例,使用UnityWebRequest发送实际下载请求，DownloadHandler抛出下载数据更新事件</li><li>DownloadCounter计算下载速度</li><li>IDownloadManager即下载管理器，管理任务池以及开放对应下载接口</li></ol><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>Entity即实体<br>EntityManager-&gt;EntityGroup-&gt;Entity<br>每个Entity有独一无二的id，Manager通过字典存储，方便管理Entity<br>每个EntityManager管理EntityGroup,EntityGroup只管理组内的Entity<br>每个Entity实际生成时通过EntityGroup中的对象池子管理<br>ShowEntity流程：ReourcesManager加载资源-&gt;IEntityHelper实例化-&gt;注册进EntityGroup的对象池中-&gt;调用Entity生命周期函数OnInit-&gt;OnShow</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>对Base层的EventPool的一层封装</p><h2 id="FileSystem"><a href="#FileSystem" class="headerlink" title="FileSystem"></a>FileSystem</h2><ul><li>FileSystem对应一个物理文件,其中保存多个文件数据,每个文件数据可理解为一个数据类型的二进制数据，加载时解析成对应类型的数据<br>其中有一个概念数据块，即每一个文件数据都是一个数据块，但是当同名数据更新时，文件数据会更换一个空闲块进行存储。</li><li>IFileSystem fileSystem = fileSystemComponent.CreateFileSystem(fullPath, FileSystemAccess.ReadWrite, maxFileCount, maxBlockCount);<br>创建文件系统时，输入的maxFileCount，以及maxBlockCount对应最大文件个数以及最大数据块个数，目前FileSystem还不支持文件系统自动扩容，需一开始设定好，且maxFileCount &lt;= maxBlockCount，在更新文件数据时会更换数据块，因此更新越频繁的数据maxBlockCount需要越大，以保证数据更新有足够的碎片空间进行修改。</li></ul><h2 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h2><p>有限状态机</p><h2 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h2><p>本地化语言,实现上与Config类似，只是在不同Language下读取不同的文件下存储的keyValue</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><table><thead><tr><th align="left">接口</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">INetworkManager</td><td align="left">管理NetworkChannel</td></tr><tr><td align="left">INetworkChannel</td><td align="left">建立链接，处理消息接收发送</td></tr><tr><td align="left">INetworkChannelHelper</td><td align="left">消息序列化反序列化帮助类</td></tr><tr><td align="left">IPacketHandler</td><td align="left">处理协议，每个协议有其ID，通过ID区分</td></tr><tr><td align="left">IPacketHeader</td><td align="left">消息头部信息主要记录长度，可自行添加头部信息携带数据，实际消息存在长度，发包是存在数据的粘包以及分包，这时需要头部信息判断消息是否接收完毕</td></tr></tbody></table><ul><li>使用上，客户端需要链接几处服务器就创建几个INetworkChannel分别链接，发消息也是同样每个链接处理各自的消息如：实际服务器一般存在：Gate服务器，Game服务器，Chat服务器，Friend服务器等等，使用NetworkManager可以很方便管理这种分布式服务器的链接</li><li>使用网络通信的数据结构最好使用protobuf，是目前最适合用于网络通信的数据结构，可以参考<a href="https://github.com/EllanJiang/StarForce">StarForce</a>中Network模块心跳包实现</li><li>发送以及接收消息都是异步的，且客户端收到消息在非主线程，需要事件系统通过线程安全方式抛出</li></ul><h2 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h2><p>对象池，其中有提供CreateSingleSpawnObjectPool，CreateMultiSpawnObjectPool<br>理解为：池子里的资源<strong>能够同时被使用一次或使用多次</strong>，缓存资源在Spawn后以及Release前都算是在使用下，MultiSpawnObjectPool能多次Spawn同一资源(目前还没使用过，感觉没什么作用，我目前理解为这个池子只管理了一个缓存资源，在任何情况下都能Spawn出来使用)，SingleSpawnObjectPool是我们通常情况下的对象池。</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><p>游戏进程管理，是FSM的实现，可以参考<a href="https://github.com/EllanJiang/StarForce">StarForce</a>的游戏启动流程</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><ul><li>资源管理模块设计整个框架，几乎每个模块都使用到资源管理器，普通的资源管理只是提供资源打包，加载，卸载等操作，这个强大的资源管理器还提供了可视化操作界面，资源使用分析，以及资源更新处理。</li><li>资源模式一共有三种：单机模式，预下载的可更新模式，使用时下载的可更新模式。 关于三种模式的使用方法参考<a href="https://github.com/EllanJiang/StarForce">StarForce</a>的启动流程，非常详细。</li><li>关于资源组的思想，资源组类似于Unity中的AssetBundle包即压缩包，一个包里包含多个资源文件，方便管理，资源还可以设置文件系统，多个资源组放进一个文件中。</li></ul><h3 id="编辑器中的使用方式"><a href="#编辑器中的使用方式" class="headerlink" title="编辑器中的使用方式"></a>编辑器中的使用方式</h3><ol><li>使用前需要先设置ResourceEditor.xml文件配置，是ResourceEditor的过滤配置，再导入GF框架后可以直接复制<a href="https://github.com/EllanJiang/StarForce">StarForce</a>中的配置</li><li>关于ResourceEditor有些无法过滤的文件：如bytes文件，atlas文件(将图片打成一个包并不会自动生成图集，Load出来还是Texture2D格式)等，可以手动扩展ResourceEditor的过滤配置修改脚本ResourceEditorController.cs过滤文件设置</li><li>进行第一步后就可看到设置路径下的所有合法资源文件了</li><li>Resource Builder：选择打包平台，以及路径，还可以选择打包事件处理器，如<a href="https://github.com/EllanJiang/StarForce">StarForce</a>将打完的包复制了一份到StreamingAssets路径下，具体查看接口IBuildEventHandler.cs</li></ol><h3 id="实际运行中检查并更新资源流程"><a href="#实际运行中检查并更新资源流程" class="headerlink" title="实际运行中检查并更新资源流程"></a>实际运行中检查并更新资源流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据StarForce启动流程</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---单机模式</span><br><span class="line">&#x2F;&#x2F; 注意：使用单机模式并初始化资源前，需要先构建 AssetBundle 并复制到 StreamingAssets 中，否则会产生 HTTP 404 错误</span><br><span class="line">GameEntry.Resource.InitResources(OnInitResourcesComplete);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---更新模式</span><br><span class="line">&#x2F;&#x2F; 1.向服务器请求版本信息</span><br><span class="line">GameEntry.WebRequest.AddWebRequest(Utility.Text.Format(GameEntry.BuiltinData.BuildInfo.CheckVersionUrl, GetPlatformPath()), this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.拿到服务器的VersionInfo，包含：最新版本信息，下载地址等等信息，设置资源更新下载地址并检查是否有更新</span><br><span class="line">GameEntry.Resource.UpdatePrefixUri &#x3D; Utility.Path.GetRegularPath(m_VersionInfo.UpdatePrefixUri);</span><br><span class="line">GameEntry.Resource.CheckVersionList(m_VersionInfo.InternalResourceVersion); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.进行版本更新</span><br><span class="line">GameEntry.Resource.UpdateVersionList(m_VersionInfo.VersionListLength,m_VersionInfo.VersionListHashCode,m_VersionInfo.VersionListZipLength,m_VersionInfo.VersionListZipHashCode);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.检查资源是否需要更新</span><br><span class="line">GameEntry.Resource.CheckResources(OnCheckResourcesComplete);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5.更新资源</span><br><span class="line">GameEntry.Resource.UpdateResources(OnUpdateResourcesComplete);</span><br></pre></td></tr></table></figure><h3 id="dll源码解析"><a href="#dll源码解析" class="headerlink" title="dll源码解析"></a>dll源码解析</h3><h2 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h2><p>场景加载，卸载管理，对ResourceManager的LoadScene，UnLoadScene封装了一层</p><h2 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h2><p>游戏设置，与Config实现类似</p><h2 id="Sound"><a href="#Sound" class="headerlink" title="Sound"></a>Sound</h2><p>非常好用的音效管理器，高效，简洁，功能强大</p><table><thead><tr><th align="left">接口</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">ISoundAgent</td><td align="left">一个音效有一个代理，内部逻辑代理接口，主要负责处理声音开启暂停等</td></tr><tr><td align="left">ISoundAgentHelper</td><td align="left">声音播放实际逻辑</td></tr><tr><td align="left">ISoundGroup</td><td align="left">声音组</td></tr><tr><td align="left">ISoundGroupHelper</td><td align="left">声音组帮助器，<a href="https://github.com/EllanJiang/StarForce">StarForce</a>提供默认用于处理混音的组</td></tr><tr><td align="left">ISoundHelper</td><td align="left">释放资源</td></tr><tr><td align="left">ISoundManager</td><td align="left">管理音效播放，暂停，恢复以及音效组</td></tr></tbody></table><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>设计思路与Sound以及Entity类似，UIGroup组管理UIForm，UIManager一起管理，需要注意的是同类型UIForm可以开启多个，只单个存在的界面需要自己判断是否再次开启，可以参考Demo中的写法</p><h2 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h2><p>提供了各种通用函数，方便使用</p><h2 id="WebRequest"><a href="#WebRequest" class="headerlink" title="WebRequest"></a>WebRequest</h2><p>Web请求是异步的，通过TaskPool来代理Web请求，使用上带来的好处是可以不需要使用协程，监听成功失败事件即可。</p>]]></content>
    
    
    <summary type="html">GF的dll层源码解析，学习设计思路，学习代码规范</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="GameFramework" scheme="https://skierhou.github.io/categories/Unity/GameFramework/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="GameFramework" scheme="https://skierhou.github.io/tags/GameFramework/"/>
    
  </entry>
  
  <entry>
    <title>DOTS 详细介绍</title>
    <link href="https://skierhou.github.io/2021/03/01/Unity/DOTS/"/>
    <id>https://skierhou.github.io/2021/03/01/Unity/DOTS/</id>
    <published>2021-03-01T06:30:01.000Z</published>
    <updated>2021-04-12T09:53:27.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOTS概述"><a href="#DOTS概述" class="headerlink" title="DOTS概述"></a>DOTS概述</h1><p>DATA-ORIENTED TECH STACK(多线程数据导向型技术堆栈)，是由ECS+JobSystem+Burst组成。</p><h1 id="ECS-Entity-Component-System"><a href="#ECS-Entity-Component-System" class="headerlink" title="ECS (Entity Component System)"></a>ECS (Entity Component System)</h1><h1 id="JobSystem"><a href="#JobSystem" class="headerlink" title="JobSystem"></a>JobSystem</h1><h1 id="Burst-编译"><a href="#Burst-编译" class="headerlink" title="Burst (编译)"></a>Burst (编译)</h1><ul><li>同时使用Unity.Mathematics以及JobSystem后使用[BurstCompile]标记，可使性能提升100倍以上。</li></ul><h1 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/UnityTechnologies/AngryBots_ECS">AngryBots_ECS项目</a><br><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/">Dots一些群体行为模板(鱼群等)</a><br><a href="http://dingxiaowei.cn/2020/02/09/">一些文章</a></p>]]></content>
    
    
    <summary type="html">DOTS 详细介绍</summary>
    
    
    
    <category term="Unity" scheme="https://skierhou.github.io/categories/Unity/"/>
    
    <category term="DOTS" scheme="https://skierhou.github.io/categories/Unity/DOTS/"/>
    
    
    <category term="Unity" scheme="https://skierhou.github.io/tags/Unity/"/>
    
    <category term="DOTS" scheme="https://skierhou.github.io/tags/DOTS/"/>
    
  </entry>
  
</feed>
