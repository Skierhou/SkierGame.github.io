{"meta":{"title":"SkierHou","subtitle":"123","description":"123","author":"Skier","url":"https://SkierHou.github.io","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-24T10:53:02.300Z","updated":"2021-02-24T06:49:42.121Z","comments":false,"path":"/404.html","permalink":"https://skierhou.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-02-24T07:10:29.486Z","updated":"2021-02-24T06:49:42.122Z","comments":false,"path":"books/index.html","permalink":"https://skierhou.github.io/books/index.html","excerpt":"","text":""},{"title":"EGameTang学习","date":"2021-03-01T10:53:57.000Z","updated":"2021-03-01T11:14:08.404Z","comments":true,"path":"categories/index.html","permalink":"https://skierhou.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-01T11:28:48.994Z","updated":"2021-02-24T06:49:42.122Z","comments":false,"path":"about/index.html","permalink":"https://skierhou.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"GameFramework学习","date":"2021-03-01T10:53:57.000Z","updated":"2021-03-01T11:14:26.729Z","comments":true,"path":"categories/index3.html","permalink":"https://skierhou.github.io/categories/index3.html","excerpt":"","text":""},{"title":"link","date":"2021-03-01T11:11:07.000Z","updated":"2021-03-01T11:22:22.199Z","comments":true,"path":"link/index.html","permalink":"https://skierhou.github.io/link/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-24T07:10:08.086Z","updated":"2021-02-24T06:49:42.123Z","comments":false,"path":"repository/index.html","permalink":"https://skierhou.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签1","date":"2021-03-01T11:09:41.000Z","updated":"2021-03-01T11:10:24.304Z","comments":true,"path":"tags/index.html","permalink":"https://skierhou.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-24T07:10:18.722Z","updated":"2021-02-24T06:49:42.123Z","comments":true,"path":"links/index.html","permalink":"https://skierhou.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Addressable 深度理解与使用","slug":"Unity/Resource/Addressable","date":"2021-03-05T06:30:01.000Z","updated":"2021-03-05T05:42:10.557Z","comments":true,"path":"2021/03/05/Unity/Resource/Addressable/","link":"","permalink":"https://skierhou.github.io/2021/03/05/Unity/Resource/Addressable/","excerpt":"","text":"Addressable是什么是Unity官方出的资源管理器，Addressable即可寻址的资源系统Addressable的优点： 通过一个key，可以直接获取资源，不需要在意资源的实际位置 有完整的可视化界面，不需要写大量资源管理代码即可管理资源 方便自定义打包，自带增量更新等 Addressable的使用Addressable的内部结构Addressable的扩展 项目路径 https://github.com/Skierhou/ResourceManager","categories":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/categories/Unity/"},{"name":"Resource","slug":"Unity/Resource","permalink":"https://skierhou.github.io/categories/Unity/Resource/"},{"name":"Addressable","slug":"Unity/Resource/Addressable","permalink":"https://skierhou.github.io/categories/Unity/Resource/Addressable/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/tags/Unity/"},{"name":"Addressable","slug":"Addressable","permalink":"https://skierhou.github.io/tags/Addressable/"}]},{"title":"AssetBundle 注意事项以及使用","slug":"Unity/Resource/AssetBundle","date":"2021-03-05T06:30:01.000Z","updated":"2021-03-05T05:54:21.913Z","comments":true,"path":"2021/03/05/Unity/Resource/AssetBundle/","link":"","permalink":"https://skierhou.github.io/2021/03/05/Unity/Resource/AssetBundle/","excerpt":"","text":"AssetBundle是什么AssetBundle是Unity的资源管理包，用于资源加载卸载。AssetBundle分为数据头和数据段： 数据头：存储一些设置，如压缩类型，索引，manifest等 数据段：存储序列化后Asset数据 AssetBundle的优点： 自带压缩算法 方便管理，适合增量更新 可随意加载卸载Asset 内部包含Asset的引用关系，不需要怕引用丢失 AssetBundle的压缩压缩格式分为：LZ4，LZMA LZMA打包成字节流，包体会比LZ4小 LZMA打包运行时占用运行内存空间会比LZ4大很多,在使用是LZMA包在初始化时先解压再压缩成LZ4使用，个人理解实际情况：LZMA解压完的数据会先存在内存中，再压缩成LZ4，但是使用时又需要将LZ4解压，感觉上是极度没必要的。 通常情况下使用LZ4打包，不需要考虑太多内存空间的事，只是包体会稍微大一些 AssetBundle的读取有两种方式LoadFromMemory，LoadFromFile LoadFromMemory：需要反复读取byte数组，会有额外的内存消耗 LoadFromFile: 直接从硬盘文件中读取，注意：LoadFromFile在Editor模式下会直接读取整个AssetBundle，而运行时只会读取AssetBundle的头数据，在Editor下性能分析需要注意这一项 AssetBundle的卸载AssetBundle.UnLoad(bool unloadAllLoadedObject) 卸载时需要注意，当使用UnLoad(false)，且有实际使用资源时，该资源并不会卸载会缓存一份，再下一次加载出AssetBundle时，会复制另一份资源，导致同样的资源内存中存在两份。 卸载时使用UnLoad(true),会卸载所有加载资源，使用这类资源的将丢失，但是下一次加载出AssetBundle时，内存中只会有一份资源 AssetBundle的依赖关系编辑器下由AssetDatabase 和 AssetImporter管理，AssetDatabase管理依赖，AssetImporter为AssetBundle数据 通过AssetDatabase.GetDependencies(path) 来获取该Asset的依赖文件 通过AssetImporter可以修改Asset的AssetBundle设置 实际打包时，会将Asset的依赖关系打进manifest文件，但是加载一个AssetBundle时Unity并不会将其依赖AssetBundle一同加载出来，需要自己主动进行管理 AssetBundle在项目中使用通常在实际项目中使用并不会去手动一一设置AssetBundle名称再进行打包，而会根据项目需求自定义打包模式，下面由我介绍一下个人感觉非常实用的打包策略。 将一个文件夹路径下所有的文件统一自动打成AssetBundle包，所有Asset按文件夹名称设置ABName并递归所有子文件夹，使用这种做法只需要管理好项目资源的目录结构就可以很好管理AssetBundle了 在打包的同时将保存所有Asset的数据：crc, path, assetName, assetBundleName, dependceAssetBundles。保存成二进制一同打进config包中,游戏启动先加载config，在加载一个资源时再加载对应包以及依赖包即可12345678910111213141516171819[System.Serializable]public class AssetBundleConfig&#123; &#x2F;&#x2F; 资源路径转crc public uint crc; &#x2F;&#x2F; 资源路径 public string path; &#x2F;&#x2F; 资源包名 public string assetBundleName; &#x2F;&#x2F; 资源名：从资源包中加载的名称 public string assetName; &#x2F;&#x2F; 依赖包 public List&lt;string&gt; dependceAssetBundles;&#125;[System.Serializable]public class AssetBundleContainer&#123; public List&lt;AssetBundleConfig&gt; configList;&#125; 实现两个管理器AssetBundleManager，以及ResourceManager，使用时ResourceManager按路径加载资源，ResourceManager从AssetBundleManager拿到AssetBundle包12345678910111213141516171819202122232425262728293031public interface IAssetBundleManager&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 同步加载AB包 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; AssetBundle LoadAssetBundle(string assetBundleName); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 异步加载AB包 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; void LoadAssetBundleAsync(string assetBundleName, Action&lt;AssetBundle&gt; callback); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 卸载AB包 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; void UnLoadAssetBundle(string assetBundleName);&#125;public interface IResourceManager&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 同步加载资源 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; T LoadAsset&lt;T&gt;(string path) where T : UnityEngine.Object; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 异步加载资源 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; void LoadAssetAsync(string path, Action&lt;UnityEngine.Object, object&gt; onLoaded, int priority &#x3D; 0, object userData &#x3D; null); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 卸载资源 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; void UnLoadAsset(string path, bool isDestroy &#x3D; false);&#125; 项目路径 https://github.com/Skierhou/ResourceManager","categories":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/categories/Unity/"},{"name":"Resource","slug":"Unity/Resource","permalink":"https://skierhou.github.io/categories/Unity/Resource/"},{"name":"AssetBundle","slug":"Unity/Resource/AssetBundle","permalink":"https://skierhou.github.io/categories/Unity/Resource/AssetBundle/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/tags/Unity/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://skierhou.github.io/tags/AssetBundle/"}]},{"title":"Markdown基础语法","slug":"Base/markdown","date":"2021-03-02T06:30:01.000Z","updated":"2021-03-02T05:48:37.352Z","comments":true,"path":"2021/03/02/Base/markdown/","link":"","permalink":"https://skierhou.github.io/2021/03/02/Base/markdown/","excerpt":"","text":"初于方便写文章考虑，整理一下markdown语法规则 转载链接 标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体1234**这是加粗的文字***这是倾斜的文字*&#96;***这是斜体加粗的文字***~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 引用123&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用 引用 引用 引用 分割线1234-------******** 图片12格式：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)参考：![default](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;butterfly-extsrc@1&#x2F;img&#x2F;default.jpg &quot;标题&quot;) 超链接12格式：[超链接名](超链接地址 &quot;超链接title&quot;)参考：[简书](http:&#x2F;&#x2F;jianshu.com) 简书 列表12无序： * - +有序： 1. 2. 3. 无序 无序 无序 有序 有序 有序 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 表头 表头 表头 内容 内容 内容 内容 内容 内容 代码块123(&#96;&#96;&#96;) 代码块...(&#96;&#96;&#96;) 流程图1234567891011&#96;&#96;&#96;sequenceTitle:时序图示例客户端-&gt;服务端: 我想找你拿下数据 SYN服务端--&gt;客户端: 我收到你的请求啦 ACK+SYN客户端-&gt;&gt;服务端: 我收到你的确认啦，我们开始通信吧 ACKNote right of 服务端: 我是一个服务端Note left of 客户端: 我是一个客户端Note over 服务端,客户端: TCP 三次握手participant 观察者这里也不支持流程图","categories":[{"name":"通用","slug":"通用","permalink":"https://skierhou.github.io/categories/%E9%80%9A%E7%94%A8/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://skierhou.github.io/tags/Markdown/"}]},{"title":"2021年规划","slug":"Plan/plan2021","date":"2021-03-01T06:30:01.000Z","updated":"2021-03-03T09:45:44.180Z","comments":true,"path":"2021/03/01/Plan/plan2021/","link":"","permalink":"https://skierhou.github.io/2021/03/01/Plan/plan2021/","excerpt":"","text":"每年需持续整理个人任务，个人任务可以规划为年度任务，月任务，详细再到周任务记录个人任务完成情况，如未完成，需写下原因以检讨在工作空闲时间，假期，周末等时期完成的任务 年度任务规划 任务描述 完成情况(%) 注释 客户端方向 Dots技术栈深度学习，需要能做到运用到项目中去，使用Dots制作鱼群，鸟群等效果Demo 10% 目前已掌握基础使用 EGameTang框架深度学习，掌握EGameTang网络架构原理并制作联机RPGDemo 10% 目前已掌握基础使用 GameFramework框架深度学习，学习其代码规范，底层原理，架构思想 50% 目前以运用于项目中 Ability技能系统搭建完成，并完成多个模式的Demo 50% 技能系统已搭建，准备Demo即可 AI行为系统的深度学习，主要参考UE4 AI系统 10% 掌握基本使用 AssetBundle,Addressable的深度学习 40% TA方向 OpenGL，看完书籍红皮书，蓝皮书 10% UnityShader，光照GI，渲染管线 20% Unity实现天气系统 0% PS，基本使用 0% 3DMax，基本使用 0% 粒子特效制作 0% 整体技术方向 完成一款游戏Demo,未来考虑长期制作并发布的Demo 0% 月任务规划 时间(月) 任务描述 完成情况(%) 注释 1 无 无 3月启动 2 无 无 3月启动 3 1.GF框架深度学习，代码解剖；2.PS,3DMax,粒子特效制作；3.AssetBundle,Addressable的深度学习 0% 4 无 无 无 5 无 无 无 6 无 无 无 7 无 无 无 8 无 无 无 9 无 无 无 10 无 无 无 11 无 无 无 12 无 无 无 关于生活的规划 任务描述 注释 年度目标 改善肠胃，健身，增肥20斤 存钱***元 月目标 每月消费&lt;4500 (包括房租) 每月增重&gt;2斤 日目标 每日消费&lt;60","categories":[{"name":"年度规划","slug":"年度规划","permalink":"https://skierhou.github.io/categories/%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://skierhou.github.io/tags/Plan/"}]},{"title":"GameFramework 底层解析","slug":"Unity/GameFramework/GF1","date":"2021-03-01T06:30:01.000Z","updated":"2021-03-03T08:51:04.595Z","comments":true,"path":"2021/03/01/Unity/GameFramework/GF1/","link":"","permalink":"https://skierhou.github.io/2021/03/01/Unity/GameFramework/GF1/","excerpt":"","text":"对GF的源码解析，学习设计思路，学习代码规范 GF官网 GF-API看了GF的源码，感觉自己之前写的代码都是一堆垃圾!!!源码阅读建议：与StarForce项目一同阅读 Base层数据处理器，序列化工具，Log，事件池，引用池，任务代理池，其他扩展：Action，Func，变量封装(用于自定义数据结构)，自定义链表 DataProvider 数据处理器主要细节只需要看IDataProvider，IDataProviderHelper的实现上IDataProvider，IDataProviderHelper主要实现2个接口：ReadData，ParseData IDataProvider 从ResourceManager中读取资源，为数据提供者 IDataProviderHelper负责对具体数据的解析，为数据提供者帮助接口，用户使用上只需要实现帮助类即可对于IDataProviderHelper可能会引起误区，这里的ReadData是在IDataProvider读取资源成功时调用，这时已经拿到了需要的资源，可以直接使用或者再主动调用ParseData解析数据再使用。 执行顺序如：ConfigManager.ReadData()-&gt;IDataProvider.ReadData()-&gt;读取成功后-&gt;IDataProviderHelper.ReadData()，这时主动调用ConfigManager.ParseData()-&gt;IDataProvider.ParseData()-&gt;IDataProviderHelper.ParseData() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899IDataProvider&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; 数据提供者接口。&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;数据提供者的持有者的类型。&lt;&#x2F;typeparam&gt;public interface IDataProvider&lt;T&gt;&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据成功事件。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; event EventHandler&lt;ReadDataSuccessEventArgs&gt; ReadDataSuccess; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据失败事件。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; event EventHandler&lt;ReadDataFailureEventArgs&gt; ReadDataFailure; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据更新事件。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; event EventHandler&lt;ReadDataUpdateEventArgs&gt; ReadDataUpdate; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据时加载依赖资源事件。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; event EventHandler&lt;ReadDataDependencyAssetEventArgs&gt; ReadDataDependencyAsset; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;priority&quot;&gt;加载数据资源的优先级。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; void ReadData(string dataAssetName, int priority, object userData); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 解析内容。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;要解析的内容二进制流。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt; bool ParseData(byte[] dataBytes, int startIndex, int length, object userData);&#125;&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; 数据提供者辅助器接口。&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;public interface IDataProviderHelper&lt;T&gt;&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAsset&quot;&gt;内容资源。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否读取数据成功。&lt;&#x2F;returns&gt; bool ReadData(T dataProviderOwner, string dataAssetName, object dataAsset, object userData); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 读取数据。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAssetName&quot;&gt;内容资源名称。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;内容二进制流。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否读取数据成功。&lt;&#x2F;returns&gt; bool ReadData(T dataProviderOwner, string dataAssetName, byte[] dataBytes, int startIndex, int length, object userData); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 解析内容。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataString&quot;&gt;要解析的内容字符串。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt; bool ParseData(T dataProviderOwner, string dataString, object userData); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 解析内容。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataBytes&quot;&gt;要解析的内容二进制流。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;startIndex&quot;&gt;内容二进制流的起始位置。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;内容二进制流的长度。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;userData&quot;&gt;用户自定义数据。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;是否解析内容成功。&lt;&#x2F;returns&gt; bool ParseData(T dataProviderOwner, byte[] dataBytes, int startIndex, int length, object userData); &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 释放内容资源。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataProviderOwner&quot;&gt;数据提供者的持有者。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;dataAsset&quot;&gt;要释放的内容资源。&lt;&#x2F;param&gt; void ReleaseDataAsset(T dataProviderOwner, object dataAsset);&#125; EventPool 事件池实现事件接口：订阅，取消订阅，抛出事件，立即抛出事件 Fire 抛出事件：线程安全，将待执行事件放入队列，下一帧执行 FireNow 立即抛出事件：线程不安全 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F;&#x2F;&#x2F; 摘要:&#x2F;&#x2F; 事件管理器接口。public interface IEventManager&#123; &#x2F;&#x2F; &#x2F;&#x2F; 摘要: &#x2F;&#x2F; 抛出事件，这个操作是线程安全的，即使不在主线程中抛出，也可保证在主线程中回调事件处理函数，但事件会在抛出后的下一帧分发。 &#x2F;&#x2F; &#x2F;&#x2F; 参数: &#x2F;&#x2F; sender: &#x2F;&#x2F; 事件源。 &#x2F;&#x2F; &#x2F;&#x2F; e: &#x2F;&#x2F; 事件参数。 void Fire(object sender, GameEventArgs e); &#x2F;&#x2F; &#x2F;&#x2F; 摘要: &#x2F;&#x2F; 抛出事件立即模式，这个操作不是线程安全的，事件会立刻分发。 &#x2F;&#x2F; &#x2F;&#x2F; 参数: &#x2F;&#x2F; sender: &#x2F;&#x2F; 事件源。 &#x2F;&#x2F; &#x2F;&#x2F; e: &#x2F;&#x2F; 事件参数。 void FireNow(object sender, GameEventArgs e); &#x2F;&#x2F; &#x2F;&#x2F; 摘要: &#x2F;&#x2F; 设置默认事件处理函数。 &#x2F;&#x2F; &#x2F;&#x2F; 参数: &#x2F;&#x2F; handler: &#x2F;&#x2F; 要设置的默认事件处理函数。 void SetDefaultHandler(EventHandler&lt;GameEventArgs&gt; handler); &#x2F;&#x2F; &#x2F;&#x2F; 摘要: &#x2F;&#x2F; 订阅事件处理函数。 &#x2F;&#x2F; &#x2F;&#x2F; 参数: &#x2F;&#x2F; id: &#x2F;&#x2F; 事件类型编号。 &#x2F;&#x2F; &#x2F;&#x2F; handler: &#x2F;&#x2F; 要订阅的事件处理函数。 void Subscribe(int id, EventHandler&lt;GameEventArgs&gt; handler); &#x2F;&#x2F; &#x2F;&#x2F; 摘要: &#x2F;&#x2F; 取消订阅事件处理函数。 &#x2F;&#x2F; &#x2F;&#x2F; 参数: &#x2F;&#x2F; id: &#x2F;&#x2F; 事件类型编号。 &#x2F;&#x2F; &#x2F;&#x2F; handler: &#x2F;&#x2F; 要取消订阅的事件处理函数。 void Unsubscribe(int id, EventHandler&lt;GameEventArgs&gt; handler);&#125; Log对Log进行封装，ILogHelper对Log的具体实现 ReferencePool 引用池为了降低因大量产生类对象而导致的内存分配，设计了引用池的概念，来将用完的对象清理并缓存起来，供后续使用。实现IReference接口，通过ReferencePool.Acquire()获取 TaskPool 任务池这个任务池主要做资源异步加载，下载等异步操作的任务 TaskBase：只是任务数据 ITaskAgent：任务代理，处理任务的具体行为如DownloadAgent.cs处的使用，Agent只处理该Task中数据，并在执行中通知对应Helper执行具体下载逻辑 TaskInfo：用于Debug等展示的信息 TaskPool：任务池,管理ITaskAgent并执行 Variable 变量变量封装 Version 版本号方便版本号管理，版本号在资源更新时需要使用，判断旧资源与新资源的版本号。 封装的基础类型 类 注释 GaneFrameworkAction 封装多参数委托 GameFrameworkFunc 封装多参数委托 GameFrameworkEntry 游戏入口 GameFrameworkEventArgs 事件数据封装 GameFrameworkException 异常抛出封装 GameFrameworkLinkedList 带缓存的LinkedList（链表） GameFrameworkLinkedListRange 有范围的链表，即理解为LinkedList中的一小段 GameFrameworkModule 模块的封装基类，统一管理各类模块Manager GameFrameworkMultiDictionary 多值字典,Value为链表 GameFrameworkSerializer 序列化器, Config经过了对Base层的理解，Config层就很轻松弄明白了。主要封装了数据读取，解析，获取。执行顺序：ConfigManager.ReadData()-&gt;IDataProvider.ReadData()-&gt;读取成功后-&gt;IDataProviderHelper.ReadData()，ConfigManager.ParseData()-&gt;IDataProvider.ParseData()-&gt;IDataProviderHelper.ParseData()使用上只需要：修改对应Helper即可 DataNode树状数据节点，个人使用最多就是GetOrAddNode(string) DataTable 使用DataTable，扩展一下可以很方便与excel使用 实现Helper类解析Excel产生的bytes数据即可 接口 注释 IDataTable 表(数据容器,管理多条数据) IDataRow 数据项(一条数据) IDataHelper 数据解析帮助类 IDataTableManager 管理所有表 Debugger运行时的Debugger界面，使用上很方便，具体就是打印多种不同信息 Download下载任务都是异步操作，因此需要等待，这时Base层定义好的TaskPool就有了作用下载步骤： DownloadTask携带下载数据：下载路径，保存路径，下载状态，缓冲区大小等 DownloadAgent处理任务数据，监听下载状态变化：下载数据更新，下载长度更新，下载完成，下载失败 IDownloadAgentHelper实现实际下载逻辑，如UnityWebRequestDownloadAgentHelper为例,使用UnityWebRequest发送实际下载请求，DownloadHandler抛出下载数据更新事件 DownloadCounter计算下载速度 IDownloadManager即下载管理器，管理任务池以及开放对应下载接口 EntityEntity即实体EntityManager-&gt;EntityGroup-&gt;Entity每个Entity有独一无二的id，Manager通过字典存储，方便管理Entity每个EntityManager管理EntityGroup,EntityGroup只管理组内的Entity每个Entity实际生成时通过EntityGroup中的对象池子管理ShowEntity流程：ReourcesManager加载资源-&gt;IEntityHelper实例化-&gt;注册进EntityGroup的对象池中-&gt;调用Entity生命周期函数OnInit-&gt;OnShow Event对Base层的EventPool的一层封装 FileSystem FileSystem对应一个物理文件,其中保存多个文件数据,每个文件数据可理解为一个数据类型的二进制数据，加载时解析成对应类型的数据其中有一个概念数据块，即每一个文件数据都是一个数据块，但是当同名数据更新时，文件数据会更换一个空闲块进行存储。 IFileSystem fileSystem = fileSystemComponent.CreateFileSystem(fullPath, FileSystemAccess.ReadWrite, maxFileCount, maxBlockCount);创建文件系统时，输入的maxFileCount，以及maxBlockCount对应最大文件个数以及最大数据块个数，目前FileSystem还不支持文件系统自动扩容，需一开始设定好，且maxFileCount &lt;= maxBlockCount，在更新文件数据时会更换数据块，因此更新越频繁的数据maxBlockCount需要越大，以保证数据更新有足够的碎片空间进行修改。 FSM有限状态机 Localization本地化语言,实现上与Config类似，只是在不同Language下读取不同的文件下存储的keyValue NetworkObjectPool对象池，其中有提供CreateSingleSpawnObjectPool，CreateMultiSpawnObjectPool理解为：池子里的资源能够同时被使用一次或使用多次，缓存资源在Spawn后以及Release前都算是在使用下，MultiSpawnObjectPool能多次Spawn同一资源(目前还没使用过，感觉没什么作用，我目前理解为这个池子只管理了一个缓存资源，在任何情况下都能Spawn出来使用)，SingleSpawnObjectPool是我们通常情况下的对象池。 Procedure游戏进程管理，是FSM的实现，可以参考StarForce的游戏启动流程 ResourceScene场景加载，卸载管理，对ResourceManager的LoadScene，UnLoadScene封装了一层 Setting游戏设置，与Config实现类似 Sound","categories":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/categories/Unity/"},{"name":"GameFramework","slug":"Unity/GameFramework","permalink":"https://skierhou.github.io/categories/Unity/GameFramework/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/tags/Unity/"},{"name":"GameFramework","slug":"GameFramework","permalink":"https://skierhou.github.io/tags/GameFramework/"}]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/categories/Unity/"},{"name":"Resource","slug":"Unity/Resource","permalink":"https://skierhou.github.io/categories/Unity/Resource/"},{"name":"Addressable","slug":"Unity/Resource/Addressable","permalink":"https://skierhou.github.io/categories/Unity/Resource/Addressable/"},{"name":"AssetBundle","slug":"Unity/Resource/AssetBundle","permalink":"https://skierhou.github.io/categories/Unity/Resource/AssetBundle/"},{"name":"通用","slug":"通用","permalink":"https://skierhou.github.io/categories/%E9%80%9A%E7%94%A8/"},{"name":"年度规划","slug":"年度规划","permalink":"https://skierhou.github.io/categories/%E5%B9%B4%E5%BA%A6%E8%A7%84%E5%88%92/"},{"name":"GameFramework","slug":"Unity/GameFramework","permalink":"https://skierhou.github.io/categories/Unity/GameFramework/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://skierhou.github.io/tags/Unity/"},{"name":"Addressable","slug":"Addressable","permalink":"https://skierhou.github.io/tags/Addressable/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://skierhou.github.io/tags/AssetBundle/"},{"name":"Markdown","slug":"Markdown","permalink":"https://skierhou.github.io/tags/Markdown/"},{"name":"Plan","slug":"Plan","permalink":"https://skierhou.github.io/tags/Plan/"},{"name":"GameFramework","slug":"GameFramework","permalink":"https://skierhou.github.io/tags/GameFramework/"}]}